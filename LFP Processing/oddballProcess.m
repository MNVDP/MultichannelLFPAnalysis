%% Oddball Processing


%This is a function version of Mk 14 (Basically just 13.5) designed to be run as a function
%There are no inputs, as everything is defined by modifying parameters in the code (e.g. commenting/uncommenting parameter groups)
%It has no outputs, as everything is either a figure or saved as a figure/matrix along the way


%Designed to analyse TDT LFP data of both short and overnight varieties (with optional integration of behavioural data)
%It is preceded in the pipeline by preprocess_01_converttdt_All (and OvernightBlockStitcher for overnight data)
%Formerly Oddball_Processing_ICA_02
%Mk 1 - Core functionality
%Mk 2 - Generalisability/automation
%    .5 - Separation of high/low probability, Carrier/Oddball cycle detection (Accuracy questionable)
%    .75 - Stim-file based cycle detection, Cycle extraction and averaging features
%    .85 - Baseline correction, altered m variable usage, Dynamic resampling frequency
%Mk 3 - Support for square wave stimuli, variable captureWindow geometry
%    .25 - Permutation statistics, added TTL half-width correction to improve cycle detection, added photodiode QA to hyperGroups
%Mk 4 - Automation across flies
%Mk 5 - Rereferencing code, better normalising
%Mk 6 - Adjusted normalising, optional subsampling (upstream AND post-hoc), fixed potential issue with perm normalising
%    .5 - More than one channel support for perm comparisons, filtered data ERPs
%    .75 - Overnight recording analysis & network-data support
%Mk 7 - Failsafe support, Improvements to colour normalisation calculation speed, Small improvements to PSD bad data handling
%    .15 - Slightly modified blockStruct/sentStimuli working to interface better with tdtCrash field
%    .5 - Comprehensive synchronisation implementation, Changed saveStruct locations away from Data folder (03/06/21)
%Mk 8 - Integration of behavioural data (Based on Overnight_Integrator_1_XM)
%    .15 - Onion plot for ERPs, Continued integration features
%    .25 - Adustments to photodiode data collection
%Mk 9 - Significant alteration to switch phot,OutP, to personalised ranges in light of desync issues (May consider splicing said data into blockStruct entirely, at cost of massive structure)
%    .25 - Seq dep improvements, dynamic channel specification, perm display changes (14/6/22)
%    .35 - Name change, improvements to grand av. ERP, perm plots (17/07/22), made AUCs (trapz) optional (03/08/22), red light modifications (XX/09/22)
%Mk 10 - (Attempted) Functionality to run without phot. data (In light of mid-2022 loss of photodode data), Rearrangement of specialEvals at top to simplify parameter batching
%     .25 - Ability to force PTT max to precede min or vice versa
%     .35 - Minor changes to normalisation, Added ability to force PTTs to be calculated post-stimulus
%     .4 - Relative PTT plot
%     .5 - Switch to using barStats (Rescinded)
%     .65 - Barplot for PTT latencies (w/ stats)
%Mk 11 - Improvements to phot/OutP/LFP sync and ditching (Shelved)
%     .15 - Addition of tools for calculating red pre/post bout
%     .2 - Minor hyperGroup changes
%     .25 - isDead curation
%     .35 - Merging cumulative groupSpecialEval updates from different branches
%     .45 - BigBird 2024 updates
%     .5 - Finishing rail labelling
%     .65 - Grand Av ERP modifications, Adjustments to captureWindowSize to support >1*f1 windows
%     .75 - Support for hyperGroups with multiple colours
%Mk 12 - Speed optimisations for specialEvals
%Mk 13 - Memory optimisations for running on PCs other than BigBird
%          .25 - Misc. improvements
%          .35 - New fallbacks for MAT finding (Mostly for DateModified/etc failure)
%          .5 - Alt event better incorporation
%Mk 14 - Testing function-ality (Had to alter usage of 'dataset' for some reason)

%To add:
%       - PPT precedence based on triangular method, rather than absolute min
%       - Bipolarity of LFP data across time checks for hyperGroups to detect for fly death
%       - Calib redundancy (Self ability to guess pol. reversal) 
%       - sentColour guessing where not specified in specialEvals

%Known bugs:
%   - Pattern matching less than functional for legacy data (Due to OutP deficiencies/differences)
%   - Phot data for Overnight experiments may drift over time

%% Bug notes

%#1 - syncArtUnderSignal and syncSentTTLResamp minor asynchrony (Non-critical, usually)
%Discovered when using 200Hz resampled data, rather than standard 1000Hz
%   (Bug report probably deprecated as long as synchronisation methods active)

%Notes taken along the way:
%"
%Errors in 200Hz data come from inequality in reference frames between syncArtUnderSignal and syncSentTTLResamp
%	Stim onset comes from finding peaks in syncArtUnderSignal that are separated by at least a phase
%		The TTL value of these points is then pulled from syncSentTTLResamp
	
%Note: Block #1012 has syncArtUnderSignal that is very slightly shorter than average
%	Comes from shorter than average range
%	Error stems from failure to detect terminal cycle (pos. 4007)
%		Under (apparently) normal detection conditions 201 cycles are found (with the extra one being a one-frame rise at the very end), but the first cycle is dropped because it precedes syncSentTTLResamp being high by one frame
%			But for #1012 only 200 blocks are found, which subtracts to 199 and thus fails

%Solution: Force artificial TTL drop in last frame for blocks where aberrantly low (by one) numbers of cycles detected?
%	Risk: Very short aberrant cycles may be detected now (But do these ever occur?)
%   Note: TTL ending on high value is not uncommon but only seems to cause issues with shorter than average blocks
%"

%#2 - TTL and TTL-like signals have periodic artefacts at rise and fall sections
%This is a known issue with the stock MATLAB 'resample' function as deployed in the preprocessing script and can be obviated by using index-based subsampling, although whether this affects LFP data has not been tested

%% Oddball_Processing_ICA.m
% The script is taken from the one to fix the single file in Martyna's
% version of the data... Instead of doing bipolar rereferencing I will do
% ICA analysis instead and save the files in a separate directory.

% - Rhiannon Jeans 2015-2016

%% NOTES
% 05/02/2020 RJ Added an Index variable to save in LFP
% 05/02/2020 RJ Added save_check and load_check variables to make sure
% everything loads and saves to the server correctly.
%{
% Turn off warnings
clc
clear all
close all
%}
function oddballProcess
warning('off','rmpath:DirNotFound');
warning('off','MATLAB:colon:nonIntegerIndex');
warning('off','MATLAB:plot:IgnoreImaginaryXYPart');
    %[lastmsg,lastid] = lastwarn; % to find last warning.

progIdent = mfilename;

networkMode = 0;
if networkMode == 0
    %procPath = 'D:\group_swinderen\Matthew\TDTs\Processed'
    %procPath = 'D:\group_vanswinderen\Matt\PROCESSED'
    %procPath = 'C:\Users\flylab\Desktop\Matt\LFP\PROCESSED'
    procPath = '..\PROCESSED'

    %rawPath = 'D:\group_swinderen\Matthew\TDTs\Data'
    %procPath = 'E:\Swinderen\Matt\PROCESSED' %Speedy
    %listPath = 'D:\group_swinderen\Matthew\TDTs\Lists'
    %listPath = 'D:\group_vanswinderen\Matt\Lists'
    %listPath = 'C:\Users\flylab\Desktop\Matt\LFP\Lists'
    listPath = '..\Lists'
else
    %procPath = 'I:\PHDMVDP002-Q1471\LFP\Analysis\Processed'
    procPath = 'I:\PHDMVDP002-Q1471\LFP\PROCESSED'
    %rawPath = 'I:\PHDMVDP002-Q1471\LFP\Analysis\Data'
    %listPath = 'D:\group_swinderen\Matthew\TDTs\Lists';
    listPath = 'I:\PHDMVDP002-Q1471\LFP\Lists'
end
%cd(procPath)

%toolPath = 'D:\group_swinderen\Matthew\Scripts\toolboxes';
%toolPath = 'D:\group_vanswinderen\Matt\Scripts\toolboxes';
%toolPath = 'C:\Users\flylab\Desktop\Matt\LFP\Scripts\toolboxes';
toolPath = '.\toolboxes';

addpath(toolPath)

%FieldTrip (Defined here but not added till later)
%ftPath = 'D:\group_swinderen\Matthew\Scripts\toolboxes\fieldtrip-20151223';
%ftPath = 'D:\group_vanswinderen\Matt\Scripts\toolboxes\fieldtrip-20151223';
%ftPath = 'C:\Users\flylab\Desktop\Matt\LFP\Scripts\toolboxes\fieldtrip-20151223';
ftPath = '.\toolboxes\fieldtrip-20151223';
if exist('fieldtrip') == 7
    rmpath(genpath(ftPath));
    disp(['# Pre-existing fieldtrip path found and removed #'])
end

%overVarPath = 'D:\group_swinderen\Matthew\TDTs\OverVars';
%overVarPath = 'D:\group_vanswinderen\Matt\OverVars';
%overVarPath = 'D:\group_vanswinderen\Matt\OverVars';
overVarPath = '.\OverVars';

%% Load your flies all together

addpath(genpath([toolPath filesep 'functions'])); % Bipolar Reference and other functions
addpath([toolPath filesep 'FastICA_25']);
%addpath(genpath(procPath)); % add to path
addpath([toolPath filesep 'basefindpeaks']); %Adds the base form of findpeaks as a function
    %This is necessary because chronux has a findpeaks that overwrites the (arguably superior) MATLAB inbuilt
addpath(genpath([toolPath filesep 'joyPlot'])); % Joy Division - Unknown Pleasures style 3D plot
addpath(genpath([toolPath filesep 'run_exiftool']));
%cd(procPath)
addpath(genpath([toolPath filesep 'barwitherr']));

%----------------------------------------

%############
%33 33 33 green-blank
%   ANNIHILUS REX
%{
groupTargets = [{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [1,3,1,3,0]; %0 - Carrieronly, 1 - Phasic, 2 - Normal uniform, 3 - Jittering
groupSpecialEval = [...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastCarrier(groupCyc) == 1'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastCarrier(groupCyc) == 1'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0'}]; %Special booleans to sub-select data points (such as by distance from last oddball, etc)
groupDescriptors = [{'Carr cyc >1 dist from last missing odd'},...
    {'Carr cyc >1 dist from last missing odd'},...
    {'Missing odd cyc exac. 1 from last carr'},...
    {'Missing odd cyc exac. 1 from last carr'},...
    {'Carrieronly cyc'}];
%}

%------------------------------------------------------------------------------

%33 33 33 green-blank and green-blue
%   BANE-SIDHE
%{
groupTargets = [{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}, ...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [1,3,1,3,1,3,1,3]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "blank")) ~= 1'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "blank")) ~= 1'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "blank")) ~= 1'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "blank")) ~= 1'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}];
groupDescriptors = [{'Carr cyc >1 dist from last missing odd'},...
    {'Carr cyc >1 dist from last missing odd'},...
    {'Missing odd cyc'},...
    {'Missing odd cyc'}, ...
    {'Carr cyc >1 dist from last coloured odd'},...
    {'Carr cyc >1 dist from last coloured odd'},...
    {'Coloured odd cyc'},...
    {'Coloured odd cyc'}];
%}

%------------------------------------------------------------------------------

%sparsening
%   COUR VALANT
%{
groupTargets = [{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [4,4]; 
groupSpecialEval = [ ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && ( blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 || isnan(blockStruct(i).allPeaksList.distFromLastOddball(groupCyc)) == 1 )'}, ...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'}]; %Special booleans to sub-select data points (such as by distance from last oddball, etc)
groupDescriptors = [...
    {'Carr cyc >1 dist from last missing odd'}, ...
    {'Missing odd cyc'}];
%}

%33 33 33 green-blank preceding-specific carrier
%   DEUS TEMPESTUS
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [3,3,3,3,3,3,3,3,3,3,3,3,1]; %0 - Carrieronly, 1 - Phasic, 2 - Normal uniform, 3 - Jittering
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 2'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 3'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 4'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 5'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 6'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 7'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 8'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 9'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 10'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 11'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-2) == 12'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1'}];
groupDescriptors = [{'First carr cyc after odd preceded by 1 carr'},...
    {'First carr cyc after odd preceded by 2 carrs'},...
    {'First carr cyc after odd preceded by 3 carrs'},...
    {'First carr cyc after odd preceded by 4 carrs'},...
    {'First carr cyc after odd preceded by 5 carrs'},...
    {'First carr cyc after odd preceded by 6 carrs'},...
    {'First carr cyc after odd preceded by 7 carrs'},...
    {'First carr cyc after odd preceded by 8 carrs'},...
    {'First carr cyc after odd preceded by 9 carrs'},...
    {'First carr cyc after odd preceded by 10 carrs'},...
    {'First carr cyc after odd preceded by 11 carrs'},...
    {'First carr cyc after odd preceded by 12 carrs'},...
    {'First carr cyc after phasic odd '}];
%}

%------------------------------------------------------------------------------

%33 33 33 green-blank preceding-specific oddball
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [3,3,3,3,3,3,3,3,3,3,3,3,1,1,3]; %0 - Carrieronly, 1 - Phasic, 2 - Normal uniform, 3 - Jittering
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 11'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 12'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1'},...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1'}];
groupDescriptors = [...
    {'Odd preceded by 1 carr'},...
    {'Odd preceded by 2 carrs'},...
    {'Odd preceded by 3 carrs'},...
    {'Odd preceded by 4 carrs'},...
    {'Odd preceded by 5 carrs'},...
    {'Odd preceded by 6 carrs'},...
    {'Odd preceded by 7 carrs'},...
    {'Odd preceded by 8 carrs'},...
    {'Odd preceded by 9 carrs'},...
    {'Odd preceded by 10 carrs'},...
    {'Odd preceded by 11 carrs'},...
    {'Odd preceded by 12 carrs'},...
    {'Phasic odd (preceded by 4 carrs)'},...
    {'Carr cyc >1 dist from last missing odd'},...
    {'Carr cyc >1 dist from last missing odd'}];
%}

%33 33 33 green-blue
%   
%{
groupTargets = [{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [1,3,1,3]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}];
groupDescriptors = [...
    {'Carr cyc >1 dist from last coloured odd'},...
    {'Carr cyc >1 dist from last coloured odd'},...
    {'Coloured odd cyc'},...
    {'Coloured odd cyc'}];
%}

%------------------------------------------------------------------------------

%80/20 phasic counterb.
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}, ...
    {'blockStruct(i).allPeaksList.relPos'}, {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}, {'blockStruct(i).allPeaksList.relPos'}...
    ]; 
groupJitters = [1,1,1,1,1,1,0,0]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'},...
    ];
groupDescriptors = [...
    {'Green carr cyc >1 dist from last blue odd'},...
    {'Blue carr cyc >1 dist from last green odd'},...
    {'Blue odd cyc'},...
    {'Green odd cyc'},...
    {'Green carr cyc exac. 1 from last blue odd'},...
    {'Blue carr cyc exac. 1 from last green odd'},...
    {'Green carrieronly'},...
    {'Blue carrieronly'},...
    ];
%}

%------------------------------------------------------------------------------

%33 33 33 green-blue and blue-green
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [...
    1,3,1,3, ...
    1,3,1,3]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}];
groupDescriptors = [...
    {'Green carr cyc >1 dist from last blue odd'},...
    {'Green carr cyc >1 dist from last blue odd'},...
    {'Blue odd cyc'},...
    {'Blue odd cyc'}...
    {'Blue carr cyc >1 dist from last green odd'},...
    {'Blue carr cyc >1 dist from last green odd'},...
    {'Green odd cyc'},...
    {'Green odd cyc'}];
%}

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen precede oddball (green)
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [3,3,3,3,3,3,3,3,3,3,3,3,1,1,3]; %0 - Carrieronly, 1 - Phasic, 2 - Normal uniform, 3 - Jittering
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 11 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 12 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}];
groupDescriptors = [...
    {'Green Odd preceded by 1 carr'},...
    {'Green Odd preceded by 2 carrs'},...
    {'Green Odd preceded by 3 carrs'},...
    {'Green Odd preceded by 4 carrs'},...
    {'Green Odd preceded by 5 carrs'},...
    {'Green Odd preceded by 6 carrs'},...
    {'Green Odd preceded by 7 carrs'},...
    {'Green Odd preceded by 8 carrs'},...
    {'Green Odd preceded by 9 carrs'},...
    {'Green Odd preceded by 10 carrs'},...
    {'Green Odd preceded by 11 carrs'},...
    {'Green Odd preceded by 12 carrs'},...
    {'Green Phasic odd (preceded by 4 carrs)'},...
    {'Green Carr cyc >1 dist from last missing odd'},...
    {'Green Carr cyc >1 dist from last missing odd'}];
%}

%------------------------------------------------------------------------------

%33 33 33 green-blank preceding-specific carrier
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,1]; %0 - Carrieronly, 1 - Phasic, 2 - Normal uniform, 3 - Jittering
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 11'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 12'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'}];
groupDescriptors = [...
    {'Carr preceded by 0 carr'},...
    {'Carr preceded by 1 carr'},...
    {'Carr preceded by 2 carrs'},...
    {'Carr preceded by 3 carrs'},...
    {'Carr preceded by 4 carrs'},...
    {'Carr preceded by 5 carrs'},...
    {'Carr preceded by 6 carrs'},...
    {'Carr preceded by 7 carrs'},...
    {'Carr preceded by 8 carrs'},...
    {'Carr preceded by 9 carrs'},...
    {'Carr preceded by 10 carrs'},...
    {'Carr preceded by 11 carrs'},...
    {'Carr preceded by 12 carrs'},...
    {'Phasic carr preceded by 0 carr'},...
    {'Phasic carr preceded by 1 carr'},...
    {'Phasic carr preceded by 2 carrs'},...
    {'Phasic carr preceded by 3 carrs'}];
%}

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen precede oddball (green)
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,1]; %0 - Carrieronly, 1 - Phasic, 2 - Normal uniform, 3 - Jittering
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 11 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 12 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}];
groupDescriptors = [...
    {'Green carr preceded by 0 carr'},...    
    {'Green carr preceded by 1 carr'},...
    {'Green carr preceded by 2 carrs'},...
    {'Green carr preceded by 3 carrs'},...
    {'Green carr preceded by 4 carrs'},...
    {'Green carr preceded by 5 carrs'},...
    {'Green carr preceded by 6 carrs'},...
    {'Green carr preceded by 7 carrs'},...
    {'Green carr preceded by 8 carrs'},...
    {'Green carr preceded by 9 carrs'},...
    {'Green carr preceded by 10 carrs'},...
    {'Green carr preceded by 11 carrs'},...
    {'Green carr preceded by 12 carrs'},...
    {'Green Phasic carr (preceded by 0 carr)'},...
    {'Green Phasic carr (preceded by 1 carr)'},...
    {'Green Phasic carr (preceded by 2 carrs)'},...
    {'Green Phasic carr (preceded by 3 carrs)'}];
%}

%------------------------------------------------------------------------------

%33 33 33 green-blank phasic early blocks vs late blocks
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},...
    ];
groupJitters = ones(1,26); %0 - Carrieronly, 1 - Phasic, 2 - Normal uniform, 3 - Jittering
groupSpecialEval = [ ...
    {'i >= 1 && i < 10 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 10 && i < 20 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 20 && i < 30 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 30 && i < 40 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 40 && i < 50 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 50 && i < 60 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 60 && i < 70 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 70 && i < 80 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 80 && i < 90 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 90 && i < 100 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 100 && i < 110 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 110 && i < 120 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 120 && i <= 128 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'i >= 1 && i < 10 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 10 && i < 20 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 20 && i < 30 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 30 && i < 40 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 40 && i < 50 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 50 && i < 60 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 60 && i < 70 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 70 && i < 80 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 80 && i < 90 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 90 && i < 100 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 100 && i < 110 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 110 && i < 120 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    {'i >= 120 && i <= 128 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'},...
    ];
groupDescriptors = [...
    {'P. odd(B1-9)'},...
    {'P. odd(B10-19)'},...
    {'P. odd(B20-29)'},...
    {'P. odd(B30-39)'},...
    {'P. odd(B40-49)'},...
    {'P. odd(B50-59)'},...
    {'P. odd(B60-69)'},...
    {'P. odd(B70-79)'},...
    {'P. odd(B80-89)'},...
    {'P. odd(B90-99)'},...
    {'P. odd(B100-109)'},...
    {'P. odd(B110-119)'},...
    {'P. odd(B120-128)'},...
    {'P. carr(B1-9)'},...
    {'P. carr(B10-19)'},...
    {'P. carr(B20-29)'},...
    {'P. carr(B30-39)'},...
    {'P. carr(B40-49)'},...
    {'P. carr(B50-59)'},...
    {'P. carr(B60-69)'},...
    {'P. carr(B70-79)'},...
    {'P. carr(B80-89)'},...
    {'P. carr(B90-99)'},...
    {'P. carr(B100-109)'},...
    {'P. carr(B110-119)'},...
    {'P. carr(B120-128)'},...
    ];
%}

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen phasic early blocks vs late blocks (green)
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ];
groupJitters = ones(1,16); %0 - Carrieronly, 1 - Phasic, 2 - Normal uniform, 3 - Jittering
groupSpecialEval = [ ...
    {'i >= 1 && i < 10 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'i >= 10 && i < 20 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'i >= 20 && i < 30 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'i >= 30 && i < 40 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'i >= 40 && i < 50 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'i >= 50 && i < 60 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'i >= 60 && i < 70 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'i >= 70 && i < 80 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'i >= 1 && i < 10 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'i >= 10 && i < 20 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'i >= 20 && i < 30 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'i >= 30 && i < 40 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'i >= 40 && i < 50 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'i >= 50 && i < 60 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'i >= 60 && i < 70 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'i >= 70 && i < 80 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    ];
groupDescriptors = [...
    {'P. odd(B1-9)'},...
    {'P. odd(B10-19)'},...
    {'P. odd(B20-29)'},...
    {'P. odd(B30-39)'},...
    {'P. odd(B40-49)'},...
    {'P. odd(B50-59)'},...
    {'P. odd(B60-69)'},...
    {'P. odd(B70-79)'},...
    {'P. carr(B1-9)'},...
    {'P. carr(B10-19)'},...
    {'P. carr(B20-29)'},...
    {'P. carr(B30-39)'},...
    {'P. carr(B40-49)'},...
    {'P. carr(B50-59)'},...
    {'P. carr(B60-69)'},...
    {'P. carr(B70-79)'},...
    ];
%}

%33 33 33 green-blue green specific carr (adjacent to blue)
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,3,1,3, ...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}];
groupDescriptors = [...
    {'Green carr cyc imm. aft. blue odd'},...
    {'Green carr cyc imm. aft. blue odd'},...
    {'Green odd cyc'},...
    {'Green odd cyc'}];
%}

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen precede oddball (green) specific carr
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [3,3,3,3,3,3,3,3,3,3,3,3,1,1,3]; %0 - Carrieronly, 1 - Phasic, 2 - Normal uniform, 3 - Jittering
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 11 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 12 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}];
groupDescriptors = [...
    {'G Odd pr. 1 carr'},...
    {'G Odd pr. 2 carrs'},...
    {'G Odd pr. 3 carrs'},...
    {'G Odd pr. 4 carrs'},...
    {'G Odd pr. 5 carrs'},...
    {'G Odd pr. 6 carrs'},...
    {'G Odd pr. 7 carrs'},...
    {'G Odd pr. 8 carrs'},...
    {'G Odd pr. 9 carrs'},...
    {'G Odd pr. 10 carrs'},...
    {'G Odd pr. 11 carrs'},...
    {'G Odd pr. 12 carrs'},...
    {'G Ph. odd'},...
    {'G Carr. pr. 3 carr'},...
    {'G Carr. pr. 3 carr'}];
%}

%------------------------------------------------------------------------------

%80/20 phasic greenblank 80/20 and 20/80
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}, ...
    {'blockStruct(i).allPeaksList.relPos'}, {'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [1,1,1,1,0,0]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && blockStruct(i).sentCarrierSwitch == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).sentCarrierSwitch == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1 && blockStruct(i).sentCarrierSwitch == 2'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).sentCarrierSwitch == 2'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).sentCarrierSwitch == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).sentCarrierSwitch == 2'}, ...
    ];
groupDescriptors = [...
    {'Green carr cyc >1 dist from last missing odd (Carr 80%)'},...
    {'Missing odd cyc (Carr 80%)'},...
    {'Green carr cyc >1 dist from last missing odd (Odd 80%)'},...
    {'Missing odd cyc (Odd 80%)'},...
    {'Green carrieronly (Carr 80%)'},...
    {'Green carrieronly (Odd 80%)'},...
    ];
%}

%------------------------------------------------------------------------------

%80/20 phasic counterb (just green analysis) 80/20 and 20/80
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}, ...
    {'blockStruct(i).allPeaksList.relPos'}, {'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [1,1,1,1,0,0]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && blockStruct(i).sentCarrierSwitch == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && blockStruct(i).sentCarrierSwitch == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && blockStruct(i).sentCarrierSwitch == 2'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && blockStruct(i).sentCarrierSwitch == 2'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1 && blockStruct(i).sentCarrierSwitch == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1 && blockStruct(i).sentCarrierSwitch == 2'}, ...
    ];
groupDescriptors = [...
    {'Green carr cyc imm. aft. blue odd (Carr 80%)'},...
    {'Green odd cyc (Carr 80%)'},...
    {'Green carr cyc imm. aft. blue odd (Odd 80%)'},...
    {'Green odd cyc (Odd 80%)'},...
    {'Green carrieronly (Carr 80%)'},...
    {'Green carrieronly (Odd 80%)'},...
    ];
%}

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen specific carr (for blue) [18/11/20]
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,1,1,1,1,1,1,1,1,1,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(3) && i < blockSplits(4) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(4) && i < blockSplits(5) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(3) && i < blockSplits(4) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(4) && i < blockSplits(5) )'},...
    ];
groupDescriptors = [...
    {'Blue carr cyc imm. aft. green odd, all quarters'},...
    {'Blue odd cyc, all quarters'},...
    {'Blue carr cyc imm. aft. green odd, 1st quarter'},...
    {'Blue carr cyc imm. aft. green odd, 2nd quarter'},...
    {'Blue carr cyc imm. aft. green odd, 3rd quarter'},...
    {'Blue carr cyc imm. aft. green odd, 4th quarter'},...
    {'Blue odd cyc, 1st quarter'},...
    {'Blue odd cyc, 2nd quarter'},...
    {'Blue odd cyc, 3rd quarter'},...
    {'Blue odd cyc, 4th quarter'},...
    ];
blockSplitNum = 4; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %I.e. blockSplitNum = 4 will split the data into quarters, which can then be used to query how the groupTargets look during the first quarter, second quarter, etc
        %The actual splitting relies on the number of blocks and so can only be done down lower (Unless this is changed to be a fixed value (E.g. "Split into first 50, second 50, third 50 and fourth 50 blocks"))

%}        

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen specific carr (for green) [02/07/21]
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,1,1,1,1,1,1,1,1,1,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(3) && i < blockSplits(4) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(4) && i < blockSplits(5) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(3) && i < blockSplits(4) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(4) && i < blockSplits(5) )'},...
    ];
groupDescriptors = [...
    {'Blue carr cyc imm. aft. green odd, all quarters'},...
    {'Green odd cyc, all quarters'},...
    {'Blue carr cyc imm. aft. green odd, 1st quarter'},...
    {'Blue carr cyc imm. aft. green odd, 2nd quarter'},...
    {'Blue carr cyc imm. aft. green odd, 3rd quarter'},...
    {'Blue carr cyc imm. aft. green odd, 4th quarter'},...
    {'Green odd cyc, 1st quarter'},...
    {'Green odd cyc, 2nd quarter'},...
    {'Green odd cyc, 3rd quarter'},...
    {'Green odd cyc, 4th quarter'},...
    ];
blockSplitNum = 4; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)         
%}

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen specific carr (for green) [02/07/21]
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(3) && i < blockSplits(4) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(4) && i < blockSplits(5) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(3) && i < blockSplits(4) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( i >= blockSplits(4) && i < blockSplits(5) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(3) && i < blockSplits(4) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(4) && i < blockSplits(5) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(3) && i < blockSplits(4) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( i >= blockSplits(4) && i < blockSplits(5) )'},...
    ];
groupDescriptors = [...
    {'Blue carr cyc imm. aft. green odd, all quarters'},...
    {'Green carr cyc imm. aft. blue odd, all quarters'},...
    {'Green odd cyc, all quarters'},...
    {'Blue odd cyc, all quarters'},...
    {'Blue carr cyc imm. aft. green odd, 1st quarter'},...
    {'Blue carr cyc imm. aft. green odd, 2nd quarter'},...
    {'Blue carr cyc imm. aft. green odd, 3rd quarter'},...
    {'Blue carr cyc imm. aft. green odd, 4th quarter'},...
    {'Green odd cyc, 1st quarter'},...
    {'Green odd cyc, 2nd quarter'},...
    {'Green odd cyc, 3rd quarter'},...
    {'Green odd cyc, 4th quarter'},...
    {'Green carr cyc imm. aft. blue odd, 1st quarter'},...
    {'Green carr cyc imm. aft. blue odd, 2nd quarter'},...
    {'Green carr cyc imm. aft. blue odd, 3rd quarter'},...
    {'Green carr cyc imm. aft. blue odd, 4th quarter'},...
    {'Blue odd cyc, 1st quarter'},...
    {'Blue odd cyc, 2nd quarter'},...
    {'Blue odd cyc, 3rd quarter'},...
    {'Blue odd cyc, 4th quarter'},...
    ];
blockSplitNum = 4; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
targsOfInterest = [1,2,3,4];
%}

%33 33 33 greenblue bluegreen specific carr (for green) [18/11/21]
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,1,1,1,...
    1,1,1,1,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    ];
groupDescriptors = [...
    {'Blue carr cyc imm. aft. green odd, sleep'},...
    {'Green carr cyc imm. aft. blue odd, sleep'},...
    {'Green odd cyc, sleep'},...
    {'Blue odd cyc, sleep'},...
    {'Blue carr cyc imm. aft. green odd, wake'},...
    {'Green carr cyc imm. aft. blue odd, wake'},...
    {'Green odd cyc, wake'},...
    {'Blue odd cyc, wake'},...
    ];
%blockSplitNum = 4; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
targsOfInterest = [2,3,6,7];
%}

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen carr immediately before odd (for both) [02/07/21]
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
        {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
            {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
        1,1,1,1,...
            1,1,1,1,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
        {'rem(i,2) == 0 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
        {'rem(i,2) == 0 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
        {'rem(i,2) == 0 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
        {'rem(i,2) == 0 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
            {'rem(i,2) ~= 0 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
            {'rem(i,2) ~= 0 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
            {'rem(i,2) ~= 0 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
            {'rem(i,2) ~= 0 && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    ];
groupDescriptors = [...
    {'1 - Blue carr cyc imm. aft. green odd, sleep'},...
    {'2 - Green carr cyc imm. aft. blue odd, sleep'},...
    {'3 - Green odd cyc, sleep'},...
    {'4 - Blue odd cyc, sleep'},...
    {'5 - Blue carr cyc imm. aft. green odd, wake'},...
    {'6 - Green carr cyc imm. aft. blue odd, wake'},...
    {'7 - Green odd cyc, wake'},...
    {'8 - Blue odd cyc, wake'},...
    {'9 - Blue carr cyc imm. b4 green odd, sleep'},...
    {'10 - Green carr cyc imm. b4 blue odd, sleep'},...
    {'11 - Blue carr cyc imm. b4 green odd, wake'},...
    {'12 - Green carr cyc imm. b4 blue odd, wake'},...
    {'13 - Blue carr cyc imm. b4 green odd, wake, 1st half'},...
    {'14 - Green carr cyc imm. b4 blue odd, wake, 1st half'},...
    {'15 - Blue carr cyc imm. b4 green odd, sleep, 1st half'},...
    {'16 - Green carr cyc imm. b4 blue odd, sleep, 1st half'},...
    {'17 - Blue carr cyc imm. b4 green odd, wake, 2nd half'},...
    {'18 - Green carr cyc imm. b4 blue odd, wake, 2nd half'},...
    {'19 - Blue carr cyc imm. b4 green odd, sleep, 2nd half'},...
    {'20 - Green carr cyc imm. b4 blue odd, sleep, 2nd half'},...
    {'21 - Green odd cyc, sleep, 1st half'},...
    {'22 - Blue odd cyc, sleep, 1st half'},...
    {'23 - Green odd cyc, sleep, 2nd half'},...
    {'24 - Blue odd cyc, sleep, 2nd half'},...
    {'25 - Green odd cyc, wake, 1st half'},...
    {'26 - Blue odd cyc, wake, 1st half'},...
    {'27 - Green odd cyc, wake, 2nd half'},...
    {'28 - Blue odd cyc, wake, 2nd half'},...
        {'29 - Even block Green odd cyc, sleep, 1st half'},...
        {'30 - Even block Blue odd cyc, sleep, 1st half'},...
        {'31 - Even block Green odd cyc, wake, 1st half'},...
        {'32 - Even block Blue odd cyc, wake, 1st half'},...
            {'33 - Odd block Green odd cyc, sleep, 1st half'},...
            {'34 - Odd block Blue odd cyc, sleep, 1st half'},...
            {'35 - Odd block Green odd cyc, wake, 1st half'},...
            {'36 - Odd block Blue odd cyc, wake, 1st half'},...
    ];
blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [9,10,15,16];
%}

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen carr immediately before odd (for both) [02/07/21]
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(1) && i < blockSplits(2) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( i >= blockSplits(2) && i < blockSplits(3) )'},...
    ];
groupDescriptors = [...
    {'1 - Blue carr cyc imm. aft. green odd, sleep'},...
    {'2 - Green carr cyc imm. aft. blue odd, sleep'},...
    {'3 - Green odd cyc, sleep'},...
    {'4 - Blue odd cyc, sleep'},...
    {'5 - Blue carr cyc imm. aft. green odd, wake'},...
    {'6 - Green carr cyc imm. aft. blue odd, wake'},...
    {'7 - Green odd cyc, wake'},...
    {'8 - Blue odd cyc, wake'},...
    {'9 - Blue carr cyc imm. b4 green odd, sleep'},...
    {'10 - Green carr cyc imm. b4 blue odd, sleep'},...
    {'11 - Blue carr cyc imm. b4 green odd, wake'},...
    {'12 - Green carr cyc imm. b4 blue odd, wake'},...
    {'13 - Blue carr cyc imm. b4 green odd, wake, 1st half'},...
    {'14 - Green carr cyc imm. b4 blue odd, wake, 1st half'},...
    {'15 - Blue carr cyc imm. b4 green odd, sleep, 1st half'},...
    {'16 - Green carr cyc imm. b4 blue odd, sleep, 1st half'},...
    {'17 - Blue carr cyc imm. b4 green odd, wake, 2nd half'},...
    {'18 - Green carr cyc imm. b4 blue odd, wake, 2nd half'},...
    {'19 - Blue carr cyc imm. b4 green odd, sleep, 2nd half'},...
    {'20 - Green carr cyc imm. b4 blue odd, sleep, 2nd half'},...
    {'21 - Green odd cyc, sleep, 1st half'},...
    {'22 - Blue odd cyc, sleep, 1st half'},...
    {'23 - Green odd cyc, sleep, 2nd half'},...
    {'24 - Blue odd cyc, sleep, 2nd half'},...
    {'25 - Green odd cyc, wake, 1st half'},...
    {'26 - Blue odd cyc, wake, 1st half'},...
    {'27 - Green odd cyc, wake, 2nd half'},...
    {'28 - Blue odd cyc, wake, 2nd half'},...
    ];
blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [9,10,15,16];
expName = 'Stitched'
useAutoList = 0
%listToUse = '33 33 33 greenblue bluegreen' %Specifies a CSV list which will indicate what datasets to load
dataset = '150721'
flyNum = 1;
blockNum = 1; 
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%Note: overnightMode=1, useOutPData=1, synchroniseMode=2, integMode=1, doPatternMatching=1 and patternMode=1 for this dataset
%}

%33 33 33 green-blank preceding-specific oddball (2022 version)
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [3,3,3,3,3,3,3,3,3,3,3,3,1,1,3]; %0 - Carrieronly, 1 - Phasic, 2 - Normal uniform, 3 - Jittering
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 11'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 12'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'},...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1'},...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) > 1'}];
groupDescriptors = [...
    {'Odd preceded by 1 carr'},...
    {'Odd preceded by 2 carrs'},...
    {'Odd preceded by 3 carrs'},...
    {'Odd preceded by 4 carrs'},...
    {'Odd preceded by 5 carrs'},...
    {'Odd preceded by 6 carrs'},...
    {'Odd preceded by 7 carrs'},...
    {'Odd preceded by 8 carrs'},...
    {'Odd preceded by 9 carrs'},...
    {'Odd preceded by 10 carrs'},...
    {'Odd preceded by 11 carrs'},...
    {'Odd preceded by 12 carrs'},...
    {'Phasic odd (preceded by 4 carrs)'},...
    {'Carr cyc >1 dist from last missing odd'},...
    {'Carr cyc >1 dist from last missing odd'}];
expName = 'Analyzed_Oddball'
useAutoList = 1
listToUse = '33 33 33 greenblank clean' %Specifies a CSV list which will indicate what datasets to load
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%}

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen precede oddball (green) specific carr for short jittering data (02/06/22)
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}]; 
groupJitters = [3,3,3,3,3,3,3,3,3,3,3,3,1,1,3]; %0 - Carrieronly, 1 - Phasic, 2 - Normal uniform, 3 - Jittering
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 11 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 12 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}];
groupDescriptors = [...
    {'G Odd pr. 1 carr'},...
    {'G Odd pr. 2 carrs'},...
    {'G Odd pr. 3 carrs'},...
    {'G Odd pr. 4 carrs'},...
    {'G Odd pr. 5 carrs'},...
    {'G Odd pr. 6 carrs'},...
    {'G Odd pr. 7 carrs'},...
    {'G Odd pr. 8 carrs'},...
    {'G Odd pr. 9 carrs'},...
    {'G Odd pr. 10 carrs'},...
    {'G Odd pr. 11 carrs'},...
    {'G Odd pr. 12 carrs'},...
    {'G Ph. odd'},...
    {'G Carr. pr. 3 carr'},...
    {'G Carr. pr. 3 carr'}];
expName = 'Analyzed_Oddball'
useAutoList = 1
listToUse = '33 33 33 greenblue bluegreen' %Specifies a CSV list which will indicate what datasets to load
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%Note: overnightMode=0, useOutPData=0, synchroniseMode=0, integMode=0 for this dataset
%}

%33 33 33 greenblue bluegreen carr immediately before odd (for both) [06/06/22, modified on 02/10/22 to add PE periodicity groups]
    %Note: This is (presumably) the primary coloured oddball analysis batch parameter set
    %   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 )  && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 )  && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 &&  behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 4 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 &&  behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 4 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 4 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 4 ) == 1'},...
                        ];
groupDescriptors = [...
    {'1 - Blue carr cyc imm. aft. green odd, sleep'},...
    {'2 - Green carr cyc imm. aft. blue odd, sleep'},...
    {'3 - Green odd cyc, sleep'},...
    {'4 - Blue odd cyc, sleep'},...
    {'5 - Blue carr cyc imm. aft. green odd, wake'},...
    {'6 - Green carr cyc imm. aft. blue odd, wake'},...
    {'7 - Green odd cyc, wake'},...
    {'8 - Blue odd cyc, wake'},...
    {'9 - Blue carr cyc imm. b4 green odd, sleep'},...
    {'10 - Green carr cyc imm. b4 blue odd, sleep'},...
    {'11 - Blue carr cyc imm. b4 green odd, wake'},...
    {'12 - Green carr cyc imm. b4 blue odd, wake'},...
    {'13 - Blue carr cyc imm. b4 green odd, wake (<6h)'},...
    {'14 - Green carr cyc imm. b4 blue odd, wake (<8h)'},...
    {'15 - Blue carr cyc imm. b4 green odd, sleep (<8h)'},...
    {'16 - Green carr cyc imm. b4 blue odd, sleep (<8h)'},...
    {'17 - Green odd cyc, sleep (<8h)'},...
    {'18 - Blue odd cyc, sleep (<8h)'},...
    {'19 - Green odd cyc, wake (<8h)'},...
    {'20 - Blue odd cyc, wake (<8h)'},...
        {'21 - Blue carr cyc imm. b4 green odd, sleep, 1st 2mins (<8h)'},...
        {'22 - Green carr cyc imm. b4 blue odd, sleep, 1st 2mins (<8h)'},...
        {'23 - Blue carr cyc imm. b4 green odd, sleep, 2nd 2mins (<8h)'},...
        {'24 - Green carr cyc imm. b4 blue odd, sleep, 2nd 2mins (<8h)'},...
        {'25 - Blue carr cyc imm. b4 green odd, sleep, last 2mins (<8h)'},...
        {'26 - Green carr cyc imm. b4 blue odd, sleep, last 2mins (<8h)'},...
            {'27 - Green odd cyc, sleep, 1st 2mins (<8h)'},...
            {'28 - Blue odd cyc, sleep, 1st 2mins (<8h)'},...
            {'29 - Green odd cyc, sleep, 2nd 2mins (<8h)'},...
            {'30 - Blue odd cyc, sleep, 2nd 2mins (<8h)'},...
            {'31 - Green odd cyc, sleep, last 2mins (<8h)'},...
            {'32 - Blue odd cyc, sleep, last 2mins (<8h)'},...
                {'33 - Blue carr cyc imm. b4 green odd (<8h)'},...
                {'34 - Green carr cyc imm. b4 blue odd (<8h)'},...
                {'35 - Blue odd cyc (<8h)'},...
                {'36 - Green odd cyc (<8h)'},...
                    {'37 - Blue carr cyc imm. b4 green odd, wake, last 2mins (<8h)'},...
                    {'38 - Green carr cyc imm. b4 blue odd, wake, last 2mins (<8h)'},...
                    {'39 - Green odd cyc, wake, last 2mins (<8h)'},...
                    {'40 - Blue odd cyc, wake, last 2mins (<8h)'},...
                        {'41 - Blue carr cyc imm. b4 green odd, sleep, all mid mins (<8h)'},...
                        {'42 - Green carr cyc imm. b4 blue odd, sleep, all mid mins (<8h)'},...
                        {'43 - Green odd cyc, sleep, all mid mins (<8h)'},...
                        {'44 - Blue odd cyc, sleep, all mid mins (<8h)'},...
    {'45 - Blue carr cyc imm. b4 green odd, sleep, PE peridocity (<8h)'},...
    {'46 - Green carr cyc imm. b4 blue odd, sleep, PE peridocity (<8h)'},...
    {'47 - Green odd cyc, sleep, PE peridocity (<8h)'},...
    {'48 - Blue odd cyc, sleep, PE peridocity (<8h)'},...
    ];
%NOTE: GROUPS 45 - 48 ARE ONLY VALID IF behaveInterp COL 3 REFERS TO PE PERIODICITY
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
targsOfInterest = [14,19,13,20];
mmnTargets = [46,47 ; 45,48];
permCompGroups = [14,19 ; 46,47 ; 13,20 ; 45,48];
tackTargsOfInterest = [];
ratioCompGroups = [14,19; 13,20]; %PTTs from these groups will be calulated as a ratio
expName = 'Stitched'
useAutoList = 1
listToUse = 'overnight 33 33 33 greenblue bluegreen' %Specifies a CSV list which will indicate what datasets to load
%dataset = '150721'
%dataset = '210721' %Just for debugging
%flyNum = 1;
%blockNum = 1; 
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%Note: overnightMode=1, useOutPData=1, synchroniseMode=2, integMode=1, doPatternMatching=1 and patternMode=2 for this dataset
%}

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen overnight carr immediately before odd (for both) w/ red on/off separation [23/06/22]
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 )  && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 )  && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 )  && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -240 )  && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 240 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 240 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                        ];
groupDescriptors = [...
    {'1 - Blue carr cyc imm. b4 green odd, wake (<8h), not red'},...
    {'2 - Green carr cyc imm. b4 blue odd, wake (<8h), not red'},...
    {'3 - Blue carr cyc imm. b4 green odd, sleep (<8h), not red'},...
    {'4 - Green carr cyc imm. b4 blue odd, sleep (<8h), not red'},...
    {'5 - Green odd cyc, sleep (<8h), not red'},...
    {'6 - Blue odd cyc, sleep (<8h), not red'},...
    {'7 - Green odd cyc, wake (<8h), not red'},...
    {'8 - Blue odd cyc, wake (<8h), not red'},...
        {'9 - Blue carr cyc imm. b4 green odd, sleep, 1st 2mins (<8h), not red'},...
        {'10 - Green carr cyc imm. b4 blue odd, sleep, 1st 2mins (<8h), not red'},...
        {'11 - Blue carr cyc imm. b4 green odd, sleep, 2nd 2mins (<8h), not red'},...
        {'12 - Green carr cyc imm. b4 blue odd, sleep, 2nd 2mins (<8h), not red'},...
        {'13 - Blue carr cyc imm. b4 green odd, sleep, last 2mins (<8h), not red'},...
        {'14 - Green carr cyc imm. b4 blue odd, sleep, last 2mins (<8h), not red'},...
            {'15 - Green odd cyc, sleep, 1st 2mins (<8h), not red'},...
            {'16 - Blue odd cyc, sleep, 1st 2mins (<8h), not red'},...
            {'17 - Green odd cyc, sleep, 2nd 2mins (<8h), not red'},...
            {'18 - Blue odd cyc, sleep, 2nd 2mins (<8h), not red'},...
            {'19 - Green odd cyc, sleep, last 2mins (<8h), not red'},...
            {'20 - Blue odd cyc, sleep, last 2mins (<8h), not red'},...
                {'21 - Blue carr cyc imm. b4 green odd (<8h), not red'},...
                {'22 - Green carr cyc imm. b4 blue odd (<8h), not red'},...
                {'23 - Blue odd cyc (<8h), not red'},...
                {'24 - Green odd cyc (<8h), not red'},...
                    {'25 - Blue carr cyc imm. b4 green odd, wake, last 2mins (<8h), not red'},...
                    {'26 - Green carr cyc imm. b4 blue odd, wake, last 2mins (<8h), not red'},...
                    {'27 - Green odd cyc, wake, last 2mins (<8h), not red'},...
                    {'28 - Blue odd cyc, wake, last 2mins (<8h), not red'},...
                        {'29 - Blue carr cyc imm. b4 green odd, sleep, all mid mins (<8h), not red'},...
                        {'30 - Green carr cyc imm. b4 blue odd, sleep, all mid mins (<8h), not red'},...
                        {'31 - Green odd cyc, sleep, all mid mins (<8h), not red'},...
                        {'32 - Blue odd cyc, sleep, all mid mins (<8h), not red'},...
    {'33 - Blue carr cyc imm. b4 green odd, wake (<8h), red'},...
    {'34 - Green carr cyc imm. b4 blue odd, wake (<8h), red'},...
    {'35 - Blue carr cyc imm. b4 green odd, sleep (<8h), red'},...
    {'36 - Green carr cyc imm. b4 blue odd, sleep (<8h), red'},...
    {'37 - Green odd cyc, sleep (<8h), red'},...
    {'38 - Blue odd cyc, sleep (<8h), red'},...
    {'39 - Green odd cyc, wake (<8h), red'},...
    {'40 - Blue odd cyc, wake (<8h), red'},...
        {'41 - Blue carr cyc imm. b4 green odd, sleep, 1st 2mins (<8h), red'},...
        {'42 - Green carr cyc imm. b4 blue odd, sleep, 1st 2mins (<8h), red'},...
        {'43 - Blue carr cyc imm. b4 green odd, sleep, 2nd 2mins (<8h), red'},...
        {'44 - Green carr cyc imm. b4 blue odd, sleep, 2nd 2mins (<8h), red'},...
        {'45 - Blue carr cyc imm. b4 green odd, sleep, last 2mins (<8h), red'},...
        {'46 - Green carr cyc imm. b4 blue odd, sleep, last 2mins (<8h), red'},...
            {'47 - Green odd cyc, sleep, 1st 2mins (<8h), red'},...
            {'48 - Blue odd cyc, sleep, 1st 2mins (<8h), red'},...
            {'49 - Green odd cyc, sleep, 2nd 2mins (<8h), red'},...
            {'50 - Blue odd cyc, sleep, 2nd 2mins (<8h), red'},...
            {'51 - Green odd cyc, sleep, last 2mins (<8h), red'},...
            {'52 - Blue odd cyc, sleep, last 2mins (<8h), red'},...
                {'53 - Blue carr cyc imm. b4 green odd (<8h), red'},...
                {'54 - Green carr cyc imm. b4 blue odd (<8h), red'},...
                {'55 - Blue odd cyc (<8h), red'},...
                {'56 - Green odd cyc (<8h), red'},...
                    {'57 - Blue carr cyc imm. b4 green odd, wake, last 2mins (<8h), red'},...
                    {'58 - Green carr cyc imm. b4 blue odd, wake, last 2mins (<8h), red'},...
                    {'59 - Green odd cyc, wake, last 2mins (<8h), red'},...
                    {'60 - Blue odd cyc, wake, last 2mins (<8h), red'},...
                        {'61 - Blue carr cyc imm. b4 green odd, sleep, all mid mins (<8h), red'},...
                        {'62 - Green carr cyc imm. b4 blue odd, sleep, all mid mins (<8h), red'},...
                        {'63 - Green odd cyc, sleep, all mid mins (<8h), red'},...
                        {'64 - Blue odd cyc, sleep, all mid mins (<8h), red'},...
    ];
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [2,34,4,36];
mmnTargets = [27,29 ; 27,31; 29,31]; %Red light comparison
permCompGroups = [...
    2,34 ; 4,36 ; 1,33; 3,35 ;...
    5,37 ; 7,39 ; 6,38 ; 8,40];
tackTargsOfInterest = [];
expName = 'Stitched'
useAutoList = 1
listToUse = 'red light pilot greenblue' %Specifies a CSV list which will indicate what datasets to load
%dataset = '210422'
%dataset = '210721' %Just for debugging
flyNum = 1;
blockNum = 1; 
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%Note: overnightMode=1, useOutPData=1, synchroniseMode=2, integMode=1, doPatternMatching=1, patternMode=2, invertPhotodiodeSignal=0 for this dataset
%---
%}
%---
%33 33 33 greenblue bluegreen for daytime recordings
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,1,1,1,...
    1,1,0,0,...
    3,3,3,3,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
            ];
    groupDescriptors = [...
    {'1 - Blue phasic carr cyc imm. b4 green odd'},...
    {'2 - Green phasic carr cyc imm. b4 blue odd'},...
    {'3 - Green phasic odd cyc'},...
    {'4 - Blue phasic odd cyc'},...
        {'5 - Blue phasic carr cyc imm. aft. green odd'},...
        {'6 - Green phasic carr cyc imm. aft. blue odd'},...
            {'7 - Blue carrieronly'},...
            {'8 - Green carrieronly'},...
                {'9 - Blue jittering odd cyc prec. 4 green carr.'},...
                {'10 - Green jittering odd cyc prec. 4 blue carr.'},...
                {'11 - Blue jittering carr cyc prec. 3 blue carr'},...
                {'12 - Green jittering carr cyc prec. 3 green carr '},...
    ];
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [3];
mmnTargets = [1,4 ; 2,3 ; 5,4 ; 6,3 ; 11,9 ; 12,10];
permCompGroups = [1,4 ; 2,3 ; 5,4 ; 6,3 ; 11,9 ; 12,10];
tackTargsOfInterest = [];
expName = 'Oddball'
useAutoList = 1
listToUse = '33 33 33 greenblue bluegreen clean' %Specifies a CSV list which will indicate what datasets to load
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '150721'
%dataset = '210721' %Just for debugging
%flyNum = 1;
%blockNum = 1; 
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%Note: overnightMode=0, useOutPData=0, synchroniseMode=2, integMode=0, doPatternMatching=0, and invertPhotodiodeSignal=1 for this dataset
    %Secondary note: SpecialEvals rest on assumption of sentConditionNum==1 being carrieronly (Also, there are actually no blue carrieronly blocks in the dataset)
%}
%---
%33 33 33 greenblank for daytime recordings
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
    ]; 
groupJitters = [...
    1,1,1,1,...
    0,0,1,1,...
    3,3,3,3,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},...
                    ];
groupDescriptors = [...
    {'1 - Blue carr cyc imm. b4 missing odd'},...
    {'2 - Green carr cyc imm. b4 missing odd'},...
        {'3 - Blue carr cyc imm. aft. green odd'},...
        {'4 - Green carr cyc imm. aft. blue odd'},...
            {'5 - Blue carrieronly'},...
            {'6 - Green carrieronly'},...
                {'7 - Missing phasic odd cyc (Blue carr)'},...
                {'8 - Missing phasic odd cyc (Green carr)'},...
                    {'9 - Missing jittering odd cyc prec. 4 blue carr'},...
                    {'10 - Missing jittering odd cyc prec. 4 green carr '},...
                    {'11 - Blue jittering carr cyc prec. 3 blue carr'},...
                    {'12 - Green jittering carr cyc prec. 3 green carr '},...
    ];
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [8];
mmnTargets = [2,8 ; 2,4 ; 2,6 ; 8,10; 10,12];
permCompGroups = [2,8 ; 2,4 ; 2,6 ; 8,10; 10,12];
tackTargsOfInterest = [10]; %Targets for the tack-on linear ERP plot
expName = 'Oddball'
useAutoList = 1
listToUse = '33 33 33 greenblank clean' %Specifies a CSV list which will indicate what datasets to load
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '060820'
%flyNum = 2;
%blockNum = 1;
%chansOfInterest = [{'polReversalChan - 3'}];
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%Note: overnightMode=0, useOutPData=0, synchroniseMode=2, integMode=0, doPatternMatching=0, and invertPhotodiodeSignal=1 for this dataset
    %Secondary note: These specialEvals rest on assumption of sentConditionNum==1 being carrieronly (Side note: There are actually no blue carrieronly blocks in the dataset)
        %Tertiary note: Third stage photosynchronisation used to interfere with hyperGroups, but it has been modified in 9.35 to be not so
%}

%------------------------------------------------------------------------------

%33 33 33 greenblue bluegreen carr immediately before odd (for both), incorporating sleep w/ 5 (and 2) min separations [21/06/22]
    %[Old] Primary overnight oddball parameter set
        %Useful for sleep segments
%   PARAGON OF TERRA
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
    ]; 
groupJitters = [...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,...
    1,1,1,1,1,1,1,...
    1,1,1,1,1,1,1,...
    1,1,1,1,1,1,1,...
    1,1,1,1,1,1,1,...
    1,1,1,1,1,1,1,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...  
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...  
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...  
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...     
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 )'}, ...  
          ];
groupDescriptors = [...
    {'1 - Blue carr cyc imm. aft. green odd, sleep'},...
    {'2 - Green carr cyc imm. aft. blue odd, sleep'},...
    {'3 - Green odd cyc, sleep'},...
    {'4 - Blue odd cyc, sleep'},...
    {'5 - Blue carr cyc imm. aft. green odd, wake'},...
    {'6 - Green carr cyc imm. aft. blue odd, wake'},...
    {'7 - Green odd cyc, wake'},...
    {'8 - Blue odd cyc, wake'},...
    {'9 - Blue carr cyc imm. b4 green odd, sleep'},...
    {'10 - Green carr cyc imm. b4 blue odd, sleep'},...
    {'11 - Blue carr cyc imm. b4 green odd, wake'},...
    {'12 - Green carr cyc imm. b4 blue odd, wake'},...
    {'13 - Blue carr cyc imm. b4 green odd, wake (<8h)'},...
    {'14 - Green carr cyc imm. b4 blue odd, wake (<8h)'},...
    {'15 - Blue carr cyc imm. b4 green odd, sleep (<8h)'},...
    {'16 - Green carr cyc imm. b4 blue odd, sleep (<8h)'},...
    {'17 - Green odd cyc, sleep (<8h)'},...
    {'18 - Blue odd cyc, sleep (<8h)'},...
    {'19 - Green odd cyc, wake (<8h)'},...
    {'20 - Blue odd cyc, wake (<8h)'},...
        {'21 - Blue carr cyc imm. b4 green odd, sleep, 1st 5mins (<8h)'},...
        {'22 - Green carr cyc imm. b4 blue odd, sleep, 1st 5mins (<8h)'},...
        {'23 - Blue carr cyc imm. b4 green odd, sleep, 2nd 5mins (<8h)'},...
        {'24 - Green carr cyc imm. b4 blue odd, sleep, 2nd 5mins (<8h)'},...
        {'25 - Blue carr cyc imm. b4 green odd, sleep, last 5mins (<8h)'},...
        {'26 - Green carr cyc imm. b4 blue odd, sleep, last 5mins (<8h)'},...
            {'27 - Green odd cyc, sleep, 1st 5mins (<8h)'},...
            {'28 - Blue odd cyc, sleep, 1st 5mins (<8h)'},...
            {'29 - Green odd cyc, sleep, 2nd 5mins (<8h)'},...
            {'30 - Blue odd cyc, sleep, 2nd 5mins (<8h)'},...
            {'31 - Green odd cyc, sleep, last 5mins (<8h)'},...
            {'32 - Blue odd cyc, sleep, last 5mins (<8h)'},...
                {'33 - Blue carr cyc imm. b4 green odd (<8h)'},...
                {'34 - Green carr cyc imm. b4 blue odd (<8h)'},...
                {'35 - Blue odd cyc (<8h)'},...
                {'36 - Green odd cyc (<8h)'},...
                    {'37 - Blue carr cyc imm. b4 green odd, wake, last 5mins (<8h)'},...
                    {'38 - Green carr cyc imm. b4 blue odd, wake, last 5mins (<8h)'},...
                    {'39 - Green odd cyc, wake, last 5mins (<8h)'},...
                    {'40 - Blue odd cyc, wake, last 5mins (<8h)'},...
                        {'41 - Blue carr cyc imm. b4 green odd, sleep, all mid mins (>5 & <5) (<8h)'},...
                        {'42 - Green carr cyc imm. b4 blue odd, sleep, all mid mins (>5 & <5) (<8h)'},...
                        {'43 - Green odd cyc, sleep, all mid mins (>5 & <5) (<8h)'},...
                        {'44 - Blue odd cyc, sleep, all mid mins (>5 & <5) (<8h)'},...
    {'45 - Blue carr cyc imm. b4 green odd, wake, literal mid 1 min (<8h)'},...
     {'46 - Blue carr cyc imm. b4 green odd, wake, last 1 min (<8h)'},...
      {'47 - Blue carr cyc imm. b4 green odd, sleep, first 1 min (<8h)'},...
       {'48 - Blue carr cyc imm. b4 green odd, sleep, second 1 min (<8h)'},...
        {'49 - Blue carr cyc imm. b4 green odd, sleep, literal mid 1 min (<8h)'},...
         {'50 - Blue carr cyc imm. b4 green odd, sleep, second-last 1 min (<8h)'},...
          {'51 - Blue carr cyc imm. b4 green odd, sleep, last 1 min (<8h)'},...
    {'52 - Green carr cyc imm. b4 blue odd, wake, literal mid 1 min (<8h)'},...
     {'53 - Green carr cyc imm. b4 blue odd, wake, last 1 min (<8h)'},...
      {'54 - Green carr cyc imm. b4 blue odd, sleep, first 1 min (<8h)'},...
       {'55 - Green carr cyc imm. b4 blue odd, sleep, second 1 min (<8h)'},...
        {'56 - Green carr cyc imm. b4 blue odd, sleep, literal mid 1 min (<8h)'},...
         {'57 - Green carr cyc imm. b4 blue odd, sleep, second-last 1 min (<8h)'},...
          {'58 - Green carr cyc imm. b4 blue odd, sleep, last 1 min (<8h)'},...    
    {'59 - Blue odd cyc, wake, literal mid 1 min (<8h)'},...
     {'60 - Blue odd cyc, wake, last 1 min (<8h)'},...
      {'61 - Blue odd cyc, sleep, first 1 min (<8h)'},...
       {'62 - Blue odd cyc, sleep, second 1 min (<8h)'},...
        {'63 - Blue odd cyc, sleep, literal mid 1 min (<8h)'},...
         {'64 - Blue odd cyc, sleep, second-last 1 min (<8h)'},...
          {'65 - Blue odd cyc, sleep, last 1 min (<8h)'},...
    {'66 - Green odd cyc, wake, literal mid 1 min (<8h)'},...
     {'67 - Green odd cyc, wake, last 1 min (<8h)'},...
      {'68 - Green odd cyc, sleep, first 1 min (<8h)'},...
       {'69 - Green odd cyc, sleep, second 1 min (<8h)'},...
        {'70 - Green odd cyc, sleep, literal mid 1 min (<8h)'},...
         {'71 - Green odd cyc, sleep, second-last 1 min (<8h)'},...
          {'72 - Green odd cyc, sleep, last 1 min (<8h)'},...       
    {'73 - Green carr cyc imm. aft blue odd, wake, literal mid 1 min (<8h)'},...
     {'74 - Green carr cyc imm. aft blue odd, wake, last 1 min (<8h)'},...
      {'75 - Green carr cyc imm. aft blue odd, sleep, first 1 min (<8h)'},...
       {'76 - Green carr cyc imm. aft blue odd, sleep, second 1 min (<8h)'},...
        {'77 - Green carr cyc imm. aft blue odd, sleep, literal mid 1 min (<8h)'},...
         {'78 - Green carr cyc imm. aft blue odd, sleep, second-last 1 min (<8h)'},...
          {'79 - Green carr cyc imm. aft blue odd, sleep, last 1 min (<8h)'},...    
          ];
    %Note: Min. bout size (Beyond standard criteria) is not enforced for specialEvals where it is relevant (e.g. "1st 5 mins of sleep") except for "Last 5 mins.." (e.g. 25,26,31,32), where it is
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [75;79];
mmnTargets = [22,2];
permCompGroups = [14,16];
tackTargsOfInterest = [];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'overnight 33 33 33 greenblue bluegreen' %Specifies a CSV list which will indicate what datasets to load
listToUse = 'overnight 33 33 33 greenblue bluegreen clean' %Specifies a CSV list which will indicate what datasets to load
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%%dataset = '150721'
%dataset = '210721' %Just for debugging
%%flyNum = 1;
%%blockNum = 1; 
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1, useOutPData=1, synchroniseMode=2, integMode=1, doPatternMatching=1; patternMode=2;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=0;
        %Note: aggressivePostSync required to vastly reduce block ditching
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment; %additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
%New params
targsOfPlotInterest = [75:79]; %Green
chanIndsOfPlotInterest = [2];
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 0; carrierOnlyStimChan = 1; searchWindow = 1;
%}

%------------------------------------------------------------------------------

%red 33 33 33 greenblue bluegreen carr immediately before odd (for both), incorporating sleep w/ 5 (and 2) min separations, as well as red vs not red [21/06/22]
    %"And the record for the most number of hyperGroups goes to..."
%   VICTRIX IMPASSIONATA
%{
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...  
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...  
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...  
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ... 
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) <= 600 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < 0 & behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) > 300 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -300 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...  
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...  
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...  
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...     
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
        ];
      
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

groupJitters = ones(1,size(groupSpecialEval,2));
      
groupDescriptors = [...
    {'1 - Blue carr cyc imm. aft. green odd, sleep, no red'},...
    {'2 - Green carr cyc imm. aft. blue odd, sleep, no red'},...
    {'3 - Green odd cyc, sleep, no red'},...
    {'4 - Blue odd cyc, sleep, no red'},...
    {'5 - Blue carr cyc imm. aft. green odd, wake, no red'},...
    {'6 - Green carr cyc imm. aft. blue odd, wake, no red'},...
    {'7 - Green odd cyc, wake, no red'},...
    {'8 - Blue odd cyc, wake, no red'},...
    {'9 - Blue carr cyc imm. b4 green odd, sleep, no red'},...
    {'10 - Green carr cyc imm. b4 blue odd, sleep, no red'},...
    {'11 - Blue carr cyc imm. b4 green odd, wake, no red'},...
    {'12 - Green carr cyc imm. b4 blue odd, wake, no red'},...
    {'13 - Blue carr cyc imm. b4 green odd, wake (<8h), no red'},...
    {'14 - Green carr cyc imm. b4 blue odd, wake (<8h), no red'},...
    {'15 - Blue carr cyc imm. b4 green odd, sleep (<8h), no red'},...
    {'16 - Green carr cyc imm. b4 blue odd, sleep (<8h), no red'},...
    {'17 - Green odd cyc, sleep (<8h), no red'},...
    {'18 - Blue odd cyc, sleep (<8h), no red'},...
    {'19 - Green odd cyc, wake (<8h), no red'},...
    {'20 - Blue odd cyc, wake (<8h), no red'},...
        {'21 - Blue carr cyc imm. b4 green odd, sleep, 1st 5mins (<8h), no red'},...
        {'22 - Green carr cyc imm. b4 blue odd, sleep, 1st 5mins (<8h), no red'},...
        {'23 - Blue carr cyc imm. b4 green odd, sleep, 2nd 5mins (<8h), no red'},...
        {'24 - Green carr cyc imm. b4 blue odd, sleep, 2nd 5mins (<8h), no red'},...
        {'25 - Blue carr cyc imm. b4 green odd, sleep, last 5mins (<8h), no red'},...
        {'26 - Green carr cyc imm. b4 blue odd, sleep, last 5mins (<8h), no red'},...
            {'27 - Green odd cyc, sleep, 1st 5mins (<8h), no red'},...
            {'28 - Blue odd cyc, sleep, 1st 5mins (<8h), no red'},...
            {'29 - Green odd cyc, sleep, 2nd 5mins (<8h), no red'},...
            {'30 - Blue odd cyc, sleep, 2nd 5mins (<8h), no red'},...
            {'31 - Green odd cyc, sleep, last 5mins (<8h), no red'},...
            {'32 - Blue odd cyc, sleep, last 5mins (<8h), no red'},...
                {'33 - Blue carr cyc imm. b4 green odd (<8h), no red'},...
                {'34 - Green carr cyc imm. b4 blue odd (<8h), no red'},...
                {'35 - Blue odd cyc (<8h), no red'},...
                {'36 - Green odd cyc (<8h), no red'},...
                    {'37 - Blue carr cyc imm. b4 green odd, wake, last 5mins (<8h), no red'},...
                    {'38 - Green carr cyc imm. b4 blue odd, wake, last 5mins (<8h), no red'},...
                    {'39 - Green odd cyc, wake, last 5mins (<8h), no red'},...
                    {'40 - Blue odd cyc, wake, last 5mins (<8h), no red'},...
                        {'41 - Blue carr cyc imm. b4 green odd, sleep, all mid mins (>5 & <5) (<8h), no red'},...
                        {'42 - Green carr cyc imm. b4 blue odd, sleep, all mid mins (>5 & <5) (<8h), no red'},...
                        {'43 - Green odd cyc, sleep, all mid mins (>5 & <5) (<8h), no red'},...
                        {'44 - Blue odd cyc, sleep, all mid mins (>5 & <5) (<8h), no red'},...
    {'45 - Blue carr cyc imm. b4 green odd, wake, literal mid 1 min (<8h), no red'},...
     {'46 - Blue carr cyc imm. b4 green odd, wake, last 1 min (<8h), no red'},...
      {'47 - Blue carr cyc imm. b4 green odd, sleep, first 1 min (<8h), no red'},...
       {'48 - Blue carr cyc imm. b4 green odd, sleep, second 1 min (<8h), no red'},...
        {'49 - Blue carr cyc imm. b4 green odd, sleep, literal mid 1 min (<8h), no red'},...
         {'50 - Blue carr cyc imm. b4 green odd, sleep, second-last 1 min (<8h), no red'},...
          {'51 - Blue carr cyc imm. b4 green odd, sleep, last 1 min (<8h), no red'},...
    {'52 - Green carr cyc imm. b4 blue odd, wake, literal mid 1 min (<8h), no red'},...
     {'53 - Green carr cyc imm. b4 blue odd, wake, last 1 min (<8h), no red'},...
      {'54 - Green carr cyc imm. b4 blue odd, sleep, first 1 min (<8h), no red'},...
       {'55 - Green carr cyc imm. b4 blue odd, sleep, second 1 min (<8h), no red'},...
        {'56 - Green carr cyc imm. b4 blue odd, sleep, literal mid 1 min (<8h), no red'},...
         {'57 - Green carr cyc imm. b4 blue odd, sleep, second-last 1 min (<8h), no red'},...
          {'58 - Green carr cyc imm. b4 blue odd, sleep, last 1 min (<8h), no red'},...    
    {'59 - Blue odd cyc, wake, literal mid 1 min (<8h), no red'},...
     {'60 - Blue odd cyc, wake, last 1 min (<8h), no red'},...
      {'61 - Blue odd cyc, sleep, first 1 min (<8h), no red'},...
       {'62 - Blue odd cyc, sleep, second 1 min (<8h), no red'},...
        {'63 - Blue odd cyc, sleep, literal mid 1 min (<8h), no red'},...
         {'64 - Blue odd cyc, sleep, second-last 1 min (<8h), no red'},...
          {'65 - Blue odd cyc, sleep, last 1 min (<8h), no red'},...
    {'66 - Green odd cyc, wake, literal mid 1 min (<8h), no red'},...
     {'67 - Green odd cyc, wake, last 1 min (<8h), no red'},...
      {'68 - Green odd cyc, sleep, first 1 min (<8h), no red'},...
       {'69 - Green odd cyc, sleep, second 1 min (<8h), no red'},...
        {'70 - Green odd cyc, sleep, literal mid 1 min (<8h), no red'},...
         {'71 - Green odd cyc, sleep, second-last 1 min (<8h), no red'},...
          {'72 - Green odd cyc, sleep, last 1 min (<8h), no red'},...
    {'73 - Blue carr cyc imm. aft. green odd, sleep, red'},...
    {'74 - Green carr cyc imm. aft. blue odd, sleep, red'},...
    {'75 - Green odd cyc, sleep, red'},...
    {'76 - Blue odd cyc, sleep, red'},...
    {'77 - Blue carr cyc imm. aft. green odd, wake, red'},...
    {'78 - Green carr cyc imm. aft. blue odd, wake, red'},...
    {'79 - Green odd cyc, wake, red'},...
    {'80 - Blue odd cyc, wake, red'},...
    {'81 - Blue carr cyc imm. b4 green odd, sleep, red'},...
    {'82 - Green carr cyc imm. b4 blue odd, sleep, red'},...
    {'83 - Blue carr cyc imm. b4 green odd, wake, red'},...
    {'84 - Green carr cyc imm. b4 blue odd, wake, red'},...
    {'85 - Blue carr cyc imm. b4 green odd, wake (<8h), red'},...
    {'86 - Green carr cyc imm. b4 blue odd, wake (<8h), red'},...
    {'87 - Blue carr cyc imm. b4 green odd, sleep (<8h), red'},...
    {'88 - Green carr cyc imm. b4 blue odd, sleep (<8h), red'},...
    {'89 - Green odd cyc, sleep (<8h), red'},...
    {'90 - Blue odd cyc, sleep (<8h), red'},...
    {'91 - Green odd cyc, wake (<8h), red'},...
    {'92 - Blue odd cyc, wake (<8h), red'},...
        {'93 - Blue carr cyc imm. b4 green odd, sleep, 1st 5mins (<8h), red'},...
        {'94 - Green carr cyc imm. b4 blue odd, sleep, 1st 5mins (<8h), red'},...
        {'95 - Blue carr cyc imm. b4 green odd, sleep, 2nd 5mins (<8h), red'},...
        {'96 - Green carr cyc imm. b4 blue odd, sleep, 2nd 5mins (<8h), red'},...
        {'97 - Blue carr cyc imm. b4 green odd, sleep, last 5mins (<8h), red'},...
        {'98 - Green carr cyc imm. b4 blue odd, sleep, last 5mins (<8h), red'},...
            {'99 - Green odd cyc, sleep, 1st 5mins (<8h), red'},...
            {'100 - Blue odd cyc, sleep, 1st 5mins (<8h), red'},...
            {'101 - Green odd cyc, sleep, 2nd 5mins (<8h), red'},...
            {'102 - Blue odd cyc, sleep, 2nd 5mins (<8h), red'},...
            {'103 - Green odd cyc, sleep, last 5mins (<8h), red'},...
            {'104 - Blue odd cyc, sleep, last 5mins (<8h), red'},...
                {'105 - Blue carr cyc imm. b4 green odd (<8h), red'},...
                {'106 - Green carr cyc imm. b4 blue odd (<8h), red'},...
                {'107 - Blue odd cyc (<8h), red'},...
                {'108 - Green odd cyc (<8h), red'},...
                    {'109 - Blue carr cyc imm. b4 green odd, wake, last 5mins (<8h), red'},...
                    {'110 - Green carr cyc imm. b4 blue odd, wake, last 5mins (<8h), red'},...
                    {'111 - Green odd cyc, wake, last 5mins (<8h), red'},...
                    {'112 - Blue odd cyc, wake, last 5mins (<8h), red'},...
                        {'113 - Blue carr cyc imm. b4 green odd, sleep, all mid mins (>5 & <5) (<8h), red'},...
                        {'114 - Green carr cyc imm. b4 blue odd, sleep, all mid mins (>5 & <5) (<8h), red'},...
                        {'115 - Green odd cyc, sleep, all mid mins (>5 & <5) (<8h), red'},...
                        {'116 - Blue odd cyc, sleep, all mid mins (>5 & <5) (<8h), red'},...
    {'117 - Blue carr cyc imm. b4 green odd, wake, literal mid 1 min (<8h), red'},...
     {'118 - Blue carr cyc imm. b4 green odd, wake, last 1 min (<8h), red'},...
      {'119 - Blue carr cyc imm. b4 green odd, sleep, first 1 min (<8h), red'},...
       {'120 - Blue carr cyc imm. b4 green odd, sleep, second 1 min (<8h), red'},...
        {'121 - Blue carr cyc imm. b4 green odd, sleep, literal mid 1 min (<8h), red'},...
         {'122 - Blue carr cyc imm. b4 green odd, sleep, second-last 1 min (<8h), red'},...
          {'123 - Blue carr cyc imm. b4 green odd, sleep, last 1 min (<8h), red'},...
    {'124 - Green carr cyc imm. b4 blue odd, wake, literal mid 1 min (<8h), red'},...
     {'125 - Green carr cyc imm. b4 blue odd, wake, last 1 min (<8h), red'},...
      {'126 - Green carr cyc imm. b4 blue odd, sleep, first 1 min (<8h), red'},...
       {'127 - Green carr cyc imm. b4 blue odd, sleep, second 1 min (<8h), red'},...
        {'128 - Green carr cyc imm. b4 blue odd, sleep, literal mid 1 min (<8h), red'},...
         {'129 - Green carr cyc imm. b4 blue odd, sleep, second-last 1 min (<8h), red'},...
          {'130 - Green carr cyc imm. b4 blue odd, sleep, last 1 min (<8h), red'},...    
    {'131 - Blue odd cyc, wake, literal mid 1 min (<8h), red'},...
     {'132 - Blue odd cyc, wake, last 1 min (<8h), red'},...
      {'133 - Blue odd cyc, sleep, first 1 min (<8h), red'},...
       {'134 - Blue odd cyc, sleep, second 1 min (<8h), red'},...
        {'135 - Blue odd cyc, sleep, literal mid 1 min (<8h), red'},...
         {'136 - Blue odd cyc, sleep, second-last 1 min (<8h), red'},...
          {'137 - Blue odd cyc, sleep, last 1 min (<8h), red'},...
    {'138 - Green odd cyc, wake, literal mid 1 min (<8h), red'},...
     {'139 - Green odd cyc, wake, last 1 min (<8h), red'},...
      {'140 - Green odd cyc, sleep, first 1 min (<8h), red'},...
       {'141 - Green odd cyc, sleep, second 1 min (<8h), red'},...
        {'142 - Green odd cyc, sleep, literal mid 1 min (<8h), red'},...
         {'143 - Green odd cyc, sleep, second-last 1 min (<8h), red'},...
          {'144 - Green odd cyc, sleep, last 1 min (<8h), red'},...
    {'145 - Blue carr cyc imm. b4 green odd (<8h), no red'},...
    {'146 - Green carr cyc imm. b4 blue odd (<8h), no red'},...
    {'147 - Blue odd cyc (<8h), no red'},...
    {'148 - Green odd cyc (<8h), no red'},...
        {'149 - Blue carr cyc imm. b4 green odd (<8h), red'},...
        {'150 - Green carr cyc imm. b4 blue odd (<8h), red'},...
        {'151 - Blue odd cyc (<8h), red'},...
        {'152 - Green odd cyc (<8h), red'},...
    {'153 - Blue carr cyc imm. aft green odd (<8h), no red'},...
    {'154 - Green carr cyc imm. aft blue odd (<8h), no red'},...
    {'155 - Blue carr cyc imm. aft green odd (<8h), red'},...
    {'156 - Green carr cyc imm. aft blue odd (<8h), red'},...
          ];
    
    %Plan for adding "<X> before/after red session":
        %bwlabel red column of behavInterp (14 I think), iteratively find coords pre/post diff of label == 1/-1, 2/-2, etc
    
    %Note: Min. bout size (Beyond standard criteria) is not enforced for specialEvals where it is relevant (e.g. "1st 5 mins of sleep") except for "Last 5 mins.." (e.g. 25,26,31,32), where it is
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [3,75,7,79];
targsOfPlotInterest = [3,75,7,79]; %Green
chanIndsOfPlotInterest = [2];
mmnTargets = [154,156 ; 146,150 ; 148,152 ...
    ];
permCompGroups = [154,156 ; 146,150 ; 148,152];
tackTargsOfInterest = [];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'red 2023 greenblue experimental cutdown testing' %Specifies a CSV list which will indicate what datasets to load (Note: Omit file extension)
listToUse = 'red 2023 greenblue experimental full'
%listToUse = 'red 2023 greenblue experimental problem child'
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '100222'
%dataset = '070922'
%flyNum = 1;
%blockNum = 1; 
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 1; carrierOnlyStimChan = 1; searchWindow = 1; %Leeway for the stim channel here is unknown, window units is s

%}
%---
%overnight 33 33 33 greenblue bluegreen trimmed mirror of red same [05 06 23]
    %Basically a cutdown version of the directly above (As this group was in 11point2_XM_simulBranch) with red specification removed
        %[New] Primary overnight greenblue parameter set
    %-- Thesis Ch. 6 grouping (Spont.) --
%   IJAX IJASTUS
%{
groupSpecialEval = [ ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 0*60*60 && blockStruct(i).startTimeRel < 0.5*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 1*60*60 && blockStruct(i).startTimeRel < 1.5*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 2*60*60 && blockStruct(i).startTimeRel < 2.5*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 3*60*60 && blockStruct(i).startTimeRel < 3.5*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 4*60*60 && blockStruct(i).startTimeRel < 4.5*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 5*60*60 && blockStruct(i).startTimeRel < 5.5*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 6*60*60 && blockStruct(i).startTimeRel < 6.5*60*60 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && ( blockStruct(i).startTimeRel >= 7*60*60 && blockStruct(i).startTimeRel < 7.5*60*60 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 0*60*60 && blockStruct(i).startTimeRel < 0.5*60*60 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 1*60*60 && blockStruct(i).startTimeRel < 1.5*60*60 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 2*60*60 && blockStruct(i).startTimeRel < 2.5*60*60 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 3*60*60 && blockStruct(i).startTimeRel < 3.5*60*60 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 4*60*60 && blockStruct(i).startTimeRel < 4.5*60*60 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 5*60*60 && blockStruct(i).startTimeRel < 5.5*60*60 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 6*60*60 && blockStruct(i).startTimeRel < 6.5*60*60 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && ( blockStruct(i).startTimeRel >= 7*60*60 && blockStruct(i).startTimeRel < 7.5*60*60 )'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...   
        ];
      
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

groupJitters = ones(1,size(groupSpecialEval,2));
      
groupDescriptors = [...
{'1 - [1 [154]] - Green carr cyc imm. aft blue odd (<6h)'},...
{'2 - [3 [146]] - Green carr cyc imm. b4 blue odd (<6h)'},...
{'3 - [5 [148]] - Green odd cyc (<6h)'},...
{'4 - [7 [3]] - Green odd cyc, sleep (<6h)'},...
{'5 - [8 [7]] - Green odd cyc, wake (<6h)'},...
    {'6 - [11] - Green odd cyc, 0h - 0h30m'},...
    {'7 - [12] - Green odd cyc, 1h - 1h30m'},...
    {'8 - [13] - Green odd cyc, 2h - 2h30m'},...
    {'9 - [14] - Green odd cyc, 3h - 3h30m'},...
    {'10 - [15] - Green odd cyc, 4h - 4h30m'},...
    {'11 - [16] - Green odd cyc, 5h - 5h30m'},...
    {'12 - [17] - Green odd cyc, 6h - 6h30m'},...
    {'13 - [18] - Green odd cyc, 7h - 7h30m'},...
        {'14 - [21] - Green carr cyc imm. aft blue odd, 0h - 0h30m'},...
        {'15 - [22 - Green carr cyc imm. aft blue odd, 1h - 1h30m'},...
        {'16 - [23] - Green carr cyc imm. aft blue odd, 2h - 2h30m'},...
        {'17 - [24] - Green carr cyc imm. aft blue odd, 3h - 3h30m'},...
        {'18 - [25] - Green carr cyc imm. aft blue odd, 4h - 4h30m'},...
        {'19 - [26] - Green carr cyc imm. aft blue odd, 5h - 5h30m'},...
        {'20 - [27] - Green carr cyc imm. aft blue odd, 6h - 6h30m'},...
        {'21 - [28] - Green carr cyc imm. aft blue odd, 7h - 7h30m'},...
            {'22 - [31] - Green carr cyc imm. aft blue odd, sleep (<6h)'},...
            {'23 - [32] - Green carr cyc imm. aft blue odd wake (<6h)'},...
                {'24 - [35] - Green carr cyc b4 blue odd, sleep (<6h)'},...
                {'25 - [36] - Green carr cyc b4 blue odd wake (<6h)'},... 
         ];
        
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [23,5,22,4];
targsOfPlotInterest = [23,5,22,4]; %Green
chanIndsOfPlotInterest = [1];
mmnTargets = [6,14 ; 7,15 ; 8,16 ; 9,17];
permCompGroups = [1,2];
tackTargsOfInterest = [];
ratioCompGroups = [23,5;22,4];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'overnight 33 33 33 greenblue bluegreen clean'
listToUse = 'overnight 33 33 33 greenblue bluegreen clean' %Modified version of cutdown to just 2 flies for testing
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '100222'
%dataset = '070922'
%flyNum = 1;
%blockNum = 1; 
customSaveComment = [] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 0; carrierOnlyStimChan = 1; searchWindow = 1; %Leeway for the stim channel here is unknown, window units is s
    %Note carrieronlyPhotSync turned off, because pretty sure PHOT was still integrated for this dataset (Could be wrong tho)
memoryEfficient = 1;
%}        
%---

%------------------------------------------------------------------------------

%overnight 33 33 33 greenblue bluegreen trimmed w/ PEs/etc [25 01 24]
    %Duplication of the above, with addition of PEs
    %   "GARRY"
%{
groupSpecialEval = [ ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...   
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...   
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...   
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...     
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 )'}, ... 
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...     
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
     {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...                    
      {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
       {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) >= 60 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) < 120 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && abs( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) - 0.5*( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),9) + abs(behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10)) ) ) <= 30 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
         {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -120 ) && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) < -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
          {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp(blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ),10) > -60 ) && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},... 
          ];
%To do: Update hardcoded frame numbers for new groups to be resample freq based      
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

groupJitters = ones(1,size(groupSpecialEval,2));
      
groupDescriptors = [...
{'1 - Green carr cyc imm. aft blue odd (<6h)'},...
{'2 - Green carr cyc imm. b4 blue odd (<6h)'},...
{'3 - Green odd cyc (<6h)'},...
{'4 - Green odd cyc, sleep (<6h)'},...
{'5 - Green odd cyc, wake (<6h)'},...
            {'6 - Green carr cyc imm. aft blue odd, sleep (<6h)'},...
            {'7 - Green carr cyc imm. aft blue odd wake (<6h)'},...
                {'8 - Green carr cyc b4 blue odd, sleep (<6h)'},...
                {'9 - Green carr cyc b4 blue odd wake (<6h)'},... 
{'10 - Green carr cyc imm. aft blue odd, alt event (<6h)'},...
{'11 - Green odd cyc, alt event (<6h)'},...
            {'12 - Green carr cyc imm. aft blue odd, sleep, alt event (<6h)'},...
            {'13 - Green carr cyc imm. aft blue odd wake, alt event (<6h)'},...
                {'14 - Green carr cyc b4 blue odd, sleep, alt event (<6h)'},...
                {'15 - Green carr cyc b4 blue odd wake, alt event (<6h)'},... 
                    {'16 - Green odd cyc, sleep, alt event (<6h)'},...
                    {'17 - Green odd cyc, wake, alt event (<6h)'},... 
{'18 - Green carr cyc imm. aft blue odd, PE orig. (<6h)'},...
{'19 - Green odd cyc, PE orig. (<6h)'},...
            {'20 - Green carr cyc imm. aft blue odd, sleep, PE orig. (<6h)'},...
            {'21 - Green carr cyc imm. aft blue odd wake, PE orig. (<6h)'},...
                {'22 - Green carr cyc b4 blue odd, sleep, PE orig. (<6h)'},...
                {'23 - Green carr cyc b4 blue odd wake, PE orig. (<6h)'},... 
                    {'24 - Green odd cyc, sleep, PE orig. (<6h)'},...
                    {'25 - Green odd cyc, wake, PE orig. (<6h)'},...  
            {'26 - Green carr cyc imm. aft blue odd, sleep, 10s b4 or aft. PE orig. (<6h)'},...
            {'27 - Green carr cyc imm. aft blue odd wake, 10s b4 or aft. PE orig. (<6h)'},...
                    {'28 - Green odd cyc, sleep, 10s b4 or aft. PE orig. (<6h)'},...
                    {'29 - Green odd cyc, wake, 10s b4 or aft. PE orig. (<6h)'},... 
    {'30 - Green odd cyc, wake, literal mid 1 min (<6h)'},...
     {'31 - Green odd cyc, wake, last 1 min (<6h)'},...
      {'32 - Green odd cyc, sleep, first 1 min (<6h)'},...
       {'33 - Green odd cyc, sleep, second 1 min (<6h)'},...
        {'34 - Green odd cyc, sleep, literal mid 1 min (<6h)'},...
         {'35 - Green odd cyc, sleep, second-last 1 min (<6h)'},...
          {'36 - Green odd cyc, sleep, last 1 min (<6h)'},...      
    {'37 - Green carr cyc imm. aft blue odd, wake, literal mid 1 min (<6h)'},...
     {'38 - Green carr cyc imm. aft blue odd, wake, last 1 min (<6h)'},...
      {'39 - Green carr cyc imm. aft blue odd, sleep, first 1 min (<6h)'},...
       {'40 - Green carr cyc imm. aft blue odd, sleep, second 1 min (<6h)'},...
        {'41 - Green carr cyc imm. aft blue odd, sleep, literal mid 1 min (<6h)'},...
         {'42 - Green carr cyc imm. aft blue odd, sleep, second-last 1 min (<6h)'},...
          {'43 - Green carr cyc imm. aft blue odd, sleep, last 1 min (<6h)'},...
    {'44 - Green odd cyc, wake, literal mid 1 min, 10s b4 or aft. PE orig. (<6h)'},...
     {'45 - Green odd cyc, wake, last 1 min, 10s b4 or aft. PE orig. (<6h)'},...
      {'46 - Green odd cyc, sleep, first 1 min, 10s b4 or aft. PE orig. (<6h)'},...
       {'47 - Green odd cyc, sleep, second 1 min, 10s b4 or aft. PE orig. (<6h)'},...
        {'48 - Green odd cyc, sleep, literal mid 1 min, 10s b4 or aft. PE orig. (<6h)'},...
         {'49 - Green odd cyc, sleep, second-last 1 min, 10s b4 or aft. PE orig. (<6h)'},...
          {'50 - Green odd cyc, sleep, last 1 min, 10s b4 or aft. PE orig. (<6h)'},...      
    {'51 - Green carr cyc imm. aft blue odd, wake, literal mid 1 min, 10s b4 or aft. PE orig. (<6h)'},...
     {'52 - Green carr cyc imm. aft blue odd, wake, last 1 min, 10s b4 or aft. PE orig. (<6h)'},...
      {'53 - Green carr cyc imm. aft blue odd, sleep, first 1 min, 10s b4 or aft. PE orig. (<6h)'},...
       {'54 - Green carr cyc imm. aft blue odd, sleep, second 1 min, 10s b4 or aft. PE orig. (<6h)'},...
        {'55 - Green carr cyc imm. aft blue odd, sleep, literal mid 1 min, 10s b4 or aft. PE orig. (<6h)'},...
         {'56 - Green carr cyc imm. aft blue odd, sleep, second-last 1 min, 10s b4 or aft. PE orig. (<6h)'},...
          {'57 - Green carr cyc imm. aft blue odd, sleep, last 1 min, 10s b4 or aft. PE orig. (<6h)'},...
         ];
     
colChecks = [{[{3},{'peBinary'}]},...
            {[{15},{'altStructEventsFull'}]},...
            {[{16},{'peBinaryFull'}]},...
            {[{17},{'peBinaryFramesFromLast'}]},...
            {[{19},{'altFramesFromLast'}]}]; %For situations of integ, will be compared against behavCorrectedLabels to ensure the correct columns are being referenced   
     
%TO ADD:
%   - Carrieronly equivalents
%   - Reaches
        
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [17,16];
targsOfPlotInterest = [17,16]; %Green
chanIndsOfPlotInterest = [1];
mmnTargets = [1,2]; %Must be non-empty for later QAs
%permCompGroups = [1,2]; %Moved below
tackTargsOfInterest = [];
ratioCompGroups = [1,10;3,11];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'overnight 33 33 33 greenblue bluegreen clean'
listToUse = 'overnight 33 33 33 greenblue bluegreen supercutdown'
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '080721'
%flyNum = 1;
%blockNum = 1; 
customSaveComment = ['_PosterFigs2'] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
permCompGroups = [1,2]; %Must be non-empty for later QAs
doSeqDep = 0;
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 0; carrierOnlyStimChan = 1; searchWindow = 1; %Leeway for the stim channel here is unknown, window units is s
    %Note carrieronlyPhotSync turned off, because pretty sure PHOT was still integrated for this dataset (Could be wrong tho)
memoryEfficient = 1;
boxPlotMode = 1;
%}        
%---

%------------------------------------------------------------------------------

%33 33 33 greenblank for daytime recordings (2023 version with full precede)
    %Primary parameter set for missing oddball results
            %(Carr-Carr precede issue fixed 26 06 23)
%   REGALIS ANNIHILATUS
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
        {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
        {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
        {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
    ,{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'}...
    ]; 
groupJitters = [...
    1,1,1,1,... %1,2,3,4
    0,0,1,1,... %5,6,7,8
    3,3,... %9,10
    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,... %11 - 32
    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,... %33 - 54
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'}, ... %1
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'}, ... %2
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'}, ... %3
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'}, ... %4
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ... %5
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ... %6
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %7
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %8
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %9
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %10
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %11
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %12
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %13
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %14
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %15
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %16
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %17
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %18
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %19
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %20
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %21
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %22
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %23
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %24
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %25
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %26
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %27
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %28
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %29
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %30
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %31
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %32
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %33
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %34
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 2 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %35
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 2 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %36
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %37
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %38
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %39
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %40
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 5 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %41
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 5 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... 42
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 6 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %43
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 6 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %44
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 7 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %45
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 7 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %46
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 8 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %47
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 8 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %48
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 9 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %49
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 9 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %50
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 10 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %51
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 10 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %52
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 11 && isempty(strfind(blockStruct(i).sentColours, "blueblank")) ~= 1'},... %53
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 11 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %54
                    ];
                
groupDescriptors = [...
    {'1 - Blue carr cyc imm. b4 missing odd'},...
    {'2 - Green carr cyc imm. b4 missing odd'},...
    {'3 - Blue carr cyc imm. aft. green odd'},...
    {'4 - Green carr cyc imm. aft. blue odd'},...
    {'5 - Blue carrieronly'},...
    {'6 - Green carrieronly'},...
    {'7 - Missing phasic odd cyc (Blue carr)'},...
    {'8 - Missing phasic odd cyc (Green carr)'},...
    {'9 - Missing jittering odd cyc (Blue carr)'},...
    {'10 - Missing jittering odd cyc (Green carr)'},...
    {'11 - Missing jittering odd cyc prec. odd (Blue carr.)'},...
    {'12 - Missing jittering odd cyc prec. odd (Green carr.)'},...
    {'13 - Missing jittering odd cyc prec. 1 blue carr.'},...
    {'14 - Missing jittering odd cyc prec. 1 green carr.'},...
    {'15 - Missing jittering odd cyc prec. 2 blue carr.'},...
    {'16 - Missing jittering odd cyc prec. 2 green carr.'},...
    {'17 - Missing jittering odd cyc prec. 3 blue carr.'},...
    {'18 - Missing jittering odd cyc prec. 3 green carr.'},...
    {'19 - Missing jittering odd cyc prec. 4 blue carr.'},...
    {'20 - Missing jittering odd cyc prec. 4 green carr.'},...
    {'21 - Missing jittering odd cyc prec. 5 blue carr.'},...
    {'22 - Missing jittering odd cyc prec. 5 green carr.'},...
    {'23 - Missing jittering odd cyc prec. 6 blue carr.'},...
    {'24 - Missing jittering odd cyc prec. 6 green carr.'},...
    {'25 - Missing jittering odd cyc prec. 7 blue carr.'},...
    {'26 - Missing jittering odd cyc prec. 7 green carr.'},...
    {'27 - Missing jittering odd cyc prec. 8 blue carr.'},...
    {'28 - Missing jittering odd cyc prec. 8 green carr.'},...
    {'29 - Missing jittering odd cyc prec. 9 blue carr.'},...
    {'30 - Missing jittering odd cyc prec. 9 green carr.'},...
    {'31 - Missing jittering odd cyc prec. 10 blue carr.'},...
    {'32 - Missing jittering odd cyc prec. 10 green carr.'},...
    {'33 - Blue jittering carr cyc prec. odd'},...
    {'34 - Green jittering carr cyc prec. odd'},...
    {'35 - Blue jittering carr cyc prec. 1 blue carr'},...
    {'36 - Green jittering carr cyc prec. 1 green carr'},...
    {'37 - Blue jittering carr cyc prec. 2 blue carr'},...
    {'38 - Green jittering carr cyc prec. 2 green carr'},...
    {'39 - Blue jittering carr cyc prec. 3 blue carr'},...
    {'40 - Green jittering carr cyc prec. 3 green carr'},...
    {'41 - Blue jittering carr cyc prec. 4 blue carr'},...
    {'42 - Green jittering carr cyc prec. 4 green carr'},...
    {'43 - Blue jittering carr cyc prec. 5 blue carr'},...
    {'44 - Green jittering carr cyc prec. 5 green carr'},...
    {'45 - Blue jittering carr cyc prec. 6 blue carr'},...
    {'46 - Green jittering carr cyc prec. 6 green carr'},...
    {'47 - Blue jittering carr cyc prec. 7 blue carr'},...
    {'48 - Green jittering carr cyc prec. 7 green carr '},...
    {'49 - Blue jittering carr cyc prec. 8 blue carr'},...
    {'50 - Green jittering carr cyc prec. 8 green carr'},...
    {'51 - Blue jittering carr cyc prec. 9 blue carr'},...
    {'52 - Green jittering carr cyc prec. 9 green carr'},...
    {'53 - Blue jittering carr cyc prec. 10 blue carr'},...
    {'54 - Green jittering carr cyc prec. 10 green carr'},...
    ];
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [14,16,18,20,22,24,26,28,30,32];
targsOfPlotInterest = [16,32]; %New; What targs to plot for the Grand Av Erp
chanIndsOfPlotInterest = [2]; %Which channel columns to use for Grand Av Erp (Note index nature, meaning e.g. "2" is "2nd chan of interest" i.e. "polReversalChan - 3", rather than being actual channel 2)
mmnTargets = [16,32]; 
permCompGroups = [16,32]; 
ratioCompGroups = []; %For comparing PTT pttratios (Note: All elements must exist within targsOfInterest)
tackTargsOfInterest = []; %Targets for the tack-on linear ERP plot
expName = 'Oddball'
useAutoList = 1
%listToUse = '33 33 33 greenblank cutdown testing'
listToUse = '33 33 33 greenblank cleanest' %Specifies a CSV list which will indicate what datasets to load
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '040820'
%flyNum = 1;
%blockNum = 1;
%chansOfInterest = [{'polReversalChan - 3'}];
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%Note: overnightMode=0, useOutPData=0, synchroniseMode=2, integMode=0, doPatternMatching=0, and invertPhotodiodeSignal=1 for this dataset
    %Secondary note: These specialEvals rest on assumption of sentConditionNum==1 being carrieronly (Side note: There are actually no blue carrieronly blocks in the dataset)
        %Tertiary note: Third stage photosynchronisation used to interfere with hyperGroups, but it has been modified in 9.35 to be not so
overnightMode=0; useOutPData=0; synchroniseMode=2; integMode=0; doPatternMatching=0; patternMode=1; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1; invertPhotodiodeSignal=1;
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
enforcePTTPostStimulus = 1; %Whether to force PTTs to be found after stimulus onset (Note: Not really compatible with sine stimuli, given fuzzy nature of onset timing)
normaliseERPs = 1; %All peak mean normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2;
%}

%33 33 33 greenblue bluegreen for daytime recordings (2023 edit)
    %Former parameter set, without full precedence
    %-- Apparent Thesis Ch. 5 grouping (Coloured) --
%   PRAECO DEICTUS
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,1,1,1,...
    1,1,0,0,...
    3,3,3,3,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
            ];
    groupDescriptors = [...
    {'1 - Blue phasic carr cyc imm. b4 green odd'},...
    {'2 - Green phasic carr cyc imm. b4 blue odd'},...
    {'3 - Green phasic odd cyc'},...
    {'4 - Blue phasic odd cyc'},...
        {'5 - Blue phasic carr cyc imm. aft. green odd'},...
        {'6 - Green phasic carr cyc imm. aft. blue odd'},...
            {'7 - Blue carrieronly'},...
            {'8 - Green carrieronly'},...
                {'9 - Blue jittering odd cyc prec. 4 green carr.'},...
                {'10 - Green jittering odd cyc prec. 4 blue carr.'},...
                {'11 - Blue jittering carr cyc prec. 3 blue carr'},...
                {'12 - Green jittering carr cyc prec. 3 green carr '},...
    ];
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [5,4,6,3]; %Green oddball analysis
%targsOfInterest = [1,4,5]; %Blue oddball analysis
targsOfPlotInterest = [5,4,6,3]; %Green
%targsOfPlotInterest = [4,5]; %Blue
chanIndsOfPlotInterest = [2];
mmnTargets = [3,6];
permCompGroups = [2,3 ; 6,3]; %Green
%permCompGroups = [1,4 ; 5,4]; %Blue
ratioCompGroups = [3,2 ; 3,8; 3,6 ; 2,8 ; 6,8 ]; %Green
%ratioCompGroups = [ 4,1 ; 4,5 ]; %Blue
tackTargsOfInterest = [];
expName = 'Oddball' %Original
%expName = 'Stitched' %Red testing
useAutoList = 1
%listToUse = '33 33 33 greenblue bluegreen clean' %Specifies a CSV list which will indicate what datasets to load
listToUse = '33 33 33 greenblue bluegreen clean' %Specifies a CSV list which will indicate what datasets to load
%listToUse = 'red light control greenblue testing' %Red testing
%listToUse = '33 33 33 greenblue bluegreen clean just4820'
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '150721'
%dataset = '210721' %Just for debugging
%flyNum = 1;
%blockNum = 1; 
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
overnightMode=0; useOutPData=0; synchroniseMode=2; integMode=0; doPatternMatching=0; %invertPhotodiodeSignal=1; %Note: invertPhotodiodeSignal is automatically derived nowadays
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=0; doPatternMatching=0; %Red testing
patternMode=1; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2; %Whether to do traditional per-fly, per-jitter normalisation (1), per-fly, across-jitter normalisation (2), or no normalisation (0)
boxPlotMode = 1; %Whether to do sriBoxplots for select figures
timeFindMode = 2; %Force system to use filename interpretation (2) or not (1) to match MATs and data (Defaults to no if not specified)
%}

%------------------------------------------------------------------------------
    
%33 33 33 greenblue bluegreen for daytime recordings w/ full precedence (Modified version of standard greenblue 2023 edit)
    %Modified again to add carr precedence [23 6 23]
    %(Carr-Carr precede issue fixed 26 06 23)
    %   
%{
%groupTargets = [...
%    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
%    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
%    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
 %   ]; 
groupJitters = [...
    1,1,1,1,...
    1,1,0,0,...
    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
    3,3,3,3,3,3,3,3,3,3,...
    3,3
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...       
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P0 - 9
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P0 - 10
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P1 - 11
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P1 - 12
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P2 - 13
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P2 - 14
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P3 - 15
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P3 - 16
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P4 - 17
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P4 - 18
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P5 - 19
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P5 - 20
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P6 - 21
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P6 - 22
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P7 - 23
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P7 - 24
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P8 - 25
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P8 - 26
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P9 - 27
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P9 - 28
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P10 - 29
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P10 - 30
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 11 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P11 - 31
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 11 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P11 - 32
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 12 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %P12- 33
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 12 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %P12 - 34
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 2 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...35
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...36
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...37
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 5 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...38
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 6 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...39
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 7 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...40
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 8 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...41
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 9 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...42
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 10 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...43
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 11 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...44
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... %45
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... %46
    ];
    %Note: distFromLastOddball needs to be +1 of itended target (e.g. "Carr preceded by 1 carr" is in fact 2 away from last oddball)
        
    groupDescriptors = [...
    {'1 - Blue phasic carr cyc imm. b4 green odd'},...
    {'2 - Green phasic carr cyc imm. b4 blue odd'},...
    {'3 - Green phasic odd cyc'},...
    {'4 - Blue phasic odd cyc'},...
        {'5 - Blue phasic carr cyc imm. aft. green odd'},...
        {'6 - Green phasic carr cyc imm. aft. blue odd'},...
            {'7 - Blue carrieronly'},...
            {'8 - Green carrieronly'},...  
{'9 - Blue jittering odd cyc prec. blue odd'},...
{'10 - Green jittering odd cyc prec. green odd'},...
{'11 - Blue jittering odd cyc prec. 1 green carr.'},...
{'12 - Green jittering odd cyc prec. 1 blue carr.'},...
{'13 - Blue jittering odd cyc prec. 2 green carr.'},...
{'14 - Green jittering odd cyc prec. 2 blue carr.'},...
{'15 - Blue jittering odd cyc prec. 3 green carr.'},...
{'16 - Green jittering odd cyc prec. 3 blue carr.'},...
{'17 - Blue jittering odd cyc prec. 4 green carr.'},...
{'18 - Green jittering odd cyc prec. 4 blue carr.'},...
{'19 - Blue jittering odd cyc prec. 5 green carr.'},...
{'20 - Green jittering odd cyc prec. 5 blue carr.'},...
{'21 - Blue jittering odd cyc prec. 6 green carr.'},...
{'22 - Green jittering odd cyc prec. 6 blue carr.'},...
{'23 - Blue jittering odd cyc prec. 7 green carr.'},...
{'24 - Green jittering odd cyc prec. 7 blue carr.'},...
{'25 - Blue jittering odd cyc prec. 8 green carr.'},...
{'26 - Green jittering odd cyc prec. 8 blue carr.'},...
{'27 - Blue jittering odd cyc prec. 9 green carr.'},...
{'28 - Green jittering odd cyc prec. 9 blue carr.'},...
{'29 - Blue jittering odd cyc prec. 10 green carr.'},...
{'30 - Green jittering odd cyc prec. 10 blue carr.'},...
{'31 - Blue jittering odd cyc prec. 11 green carr.'},...
{'32 - Green jittering odd cyc prec. 11 blue carr.'},...
{'33 - Blue jittering odd cyc prec. 12 green carr.'},...
{'34 - Green jittering odd cyc prec. 12 blue carr.'},...
    {'35 - Green jittering carr cyc prec. 1 green carr'},...
    {'36 - Green jittering carr cyc prec. 2 green carr'},...
    {'37 - Green jittering carr cyc prec. 3 green carr'},...
    {'38 - Green jittering carr cyc prec. 4 green carr'},...
    {'39 - Green jittering carr cyc prec. 5 green carr'},...
    {'40 - Green jittering carr cyc prec. 6 green carr'},...
    {'41 - Green jittering carr cyc prec. 7 green carr'},...
    {'42 - Green jittering carr cyc prec. 8 green carr'},...
    {'43 - Green jittering carr cyc prec. 9 green carr'},...
    {'44 - Green jittering carr cyc prec. 10 green carr'},...
{'45 - Blue jittering odd cyc prec. at least 1 green carr'},...
{'46 - Green jittering odd cyc prec. at least 1 blue carr'},...
    ];

groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) ); %Automated now for simplicity

%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [3,46];
targsOfPlotInterest = [3,46];
chanIndsOfPlotInterest = [2];
mmnTargets = [2,3];
permCompGroups = [2,3];
ratioCompGroups = [];
tackTargsOfInterest = [];
expName = 'Oddball'
useAutoList = 1
%listToUse = '33 33 33 greenblue bluegreen clean' %Specifies a CSV list which will indicate what datasets to load
listToUse = '33 33 33 greenblue bluegreen clean' %Specifies a CSV list which will indicate what datasets to load
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '150721'
%dataset = '210721' %Just for debugging
%flyNum = 1;
%blockNum = 1; 
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
overnightMode=0; useOutPData=0; synchroniseMode=2; integMode=0; doPatternMatching=0; %invertPhotodiodeSignal=1; %Note: invertPhotodiodeSignal is automatically derived nowadays
patternMode=1; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 1;

automatedSavePlots = 0; additionalFigParams = ['_greenOddPrecede'];
%}

%------------------------------------------------------------------------------

%33 33 33 greenblank for daytime recordings (2023 version with full precede)
    %(Extraneous blue groups removed; Phasic carrier precede added)
    %-- Apparent Thesis Ch. 5 grouping (Blank) --
%   STORMHERALD
%{
groupSpecialEval = [ ...
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'}, ... %1
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'}, ... %2
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ... %3
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %4
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %5
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %6
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %7
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 2 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %8
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %9
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %10
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 5 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %11
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 6 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %12
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 7 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %13
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 8 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %14
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 9 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %15
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 10 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %16
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %17
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %18
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 2 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %19
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %20
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %21
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 5 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %22
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 6 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %23
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 7 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %24
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 8 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %25
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 9 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %26
{'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 10 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %27
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %28
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 2 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %29
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %30
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblank")) ~= 1'},... %31
                    ];
                
groupDescriptors = [...
    {'1 - Green carr cyc imm. b4 missing odd'},...
    {'2 - Green carr cyc imm. aft. blue odd'},...
    {'3 - Green carrieronly'},...
    {'4 - Missing phasic odd cyc (Green carr)'},...
    {'5 - Missing jittering odd cyc (Green carr)'},...
    {'6 - Missing jittering odd cyc prec. odd (Green carr.)'},...
    {'7 - Missing jittering odd cyc prec. 1 green carr.'},...
    {'8 - Missing jittering odd cyc prec. 2 green carr.'},...
    {'9 - Missing jittering odd cyc prec. 3 green carr.'},...
    {'10 - Missing jittering odd cyc prec. 4 green carr.'},...
    {'11 - Missing jittering odd cyc prec. 5 green carr.'},...
    {'12 - Missing jittering odd cyc prec. 6 green carr.'},...
    {'13 - Missing jittering odd cyc prec. 7 green carr.'},...
    {'14 - Missing jittering odd cyc prec. 8 green carr.'},...
    {'15 - Missing jittering odd cyc prec. 9 green carr.'},...
    {'16 - Missing jittering odd cyc prec. 10 green carr.'},...
    {'17 - Green jittering carr cyc prec. odd'},...
    {'18 - Green jittering carr cyc prec. 1 green carr'},...
    {'19 - Green jittering carr cyc prec. 2 green carr'},...
    {'20 - Green jittering carr cyc prec. 3 green carr'},...
    {'21 - Green jittering carr cyc prec. 4 green carr'},...
    {'22 - Green jittering carr cyc prec. 5 green carr'},...
    {'23 - Green jittering carr cyc prec. 6 green carr'},...
    {'24 - Green jittering carr cyc prec. 7 green carr '},...
    {'25 - Green jittering carr cyc prec. 8 green carr'},...
    {'26 - Green jittering carr cyc prec. 9 green carr'},...
    {'27 - Green jittering carr cyc prec. 10 green carr'},...
        {'28 - Green phasic carr cyc prec. odd'},...
        {'29 - Green phasic carr cyc prec. 1 green carr'},...
        {'30 - Green phasic carr cyc prec. 2 green carr'},...
        {'31 - Green phasic carr cyc prec. 3 green carr'},...
    ];

groupJitters = [...
    1,1,... %1,2
    0,1,... %3,4
    3,... %5
    3,3,3,3,3,3,3,3,3,3,3,... %6-16
    3,3,3,3,3,3,3,3,3,3,3,... %17-27
    1,1,1,1,... %28-32
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)

groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [7:16];
targsOfPlotInterest = [7:16]; %New; What targs to plot for the Grand Av Erp
chanIndsOfPlotInterest = [2]; %Which channel columns to use for Grand Av Erp (Note index nature, meaning e.g. "2" is "2nd chan of interest" i.e. "polReversalChan - 3", rather than being actual channel 2)
mmnTargets = [7,31]; 
permCompGroups = [7,31]; 
ratioCompGroups = []; %For comparing PTT ratios (Note: All elements must exist within targsOfInterest)
tackTargsOfInterest = []; %Targets for the tack-on linear ERP plot
expName = 'Oddball'
useAutoList = 1
%listToUse = '33 33 33 greenblank cutdown testing'
listToUse = '33 33 33 greenblank cleanest' %Specifies a CSV list which will indicate what datasets to load
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '040820'
%flyNum = 1;
%blockNum = 1;
%chansOfInterest = [{'polReversalChan - 3'}];
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%Note: overnightMode=0, useOutPData=0, synchroniseMode=2, integMode=0, doPatternMatching=0, and invertPhotodiodeSignal=1 for this dataset
    %Secondary note: These specialEvals rest on assumption of sentConditionNum==1 being carrieronly (Side note: There are actually no blue carrieronly blocks in the dataset)
        %Tertiary note: Third stage photosynchronisation used to interfere with hyperGroups, but it has been modified in 9.35 to be not so
overnightMode=0; useOutPData=0; synchroniseMode=2; integMode=0; doPatternMatching=0; patternMode=1; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1; invertPhotodiodeSignal=1;
arbitraryPermSizeParity = 0;
automatedSavePlots = 1; additionalFigParams = ['_HistoryAnalysis'];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
enforcePTTPostStimulus = 1; %Whether to force PTTs to be found after stimulus onset (Note: Not really compatible with sine stimuli, given fuzzy nature of onset timing)
normaliseERPs = 1; %All peak mean normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2;
%}
    
%33 33 33 greenblue bluegreen for red testing (No integ)
%   
%{
groupTargets = [...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    {'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},{'blockStruct(i).allPeaksList.relPos'},...
    ]; 
groupJitters = [...
    1,1,1,1,...
    1,1,0,0,...
    3,3,3,3,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
            ];
    groupDescriptors = [...
    {'1 - Blue phasic carr cyc imm. b4 green odd'},...
    {'2 - Green phasic carr cyc imm. b4 blue odd'},...
    {'3 - Green phasic odd cyc'},...
    {'4 - Blue phasic odd cyc'},...
        {'5 - Blue phasic carr cyc imm. aft. green odd'},...
        {'6 - Green phasic carr cyc imm. aft. blue odd'},...
            {'7 - Blue carrieronly'},...
            {'8 - Green carrieronly'},...
                {'9 - Blue jittering odd cyc prec. 4 green carr.'},...
                {'10 - Green jittering odd cyc prec. 4 blue carr.'},...
                {'11 - Blue jittering carr cyc prec. 3 blue carr'},...
                {'12 - Green jittering carr cyc prec. 3 green carr '},...
    ];
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [2,3,6,8]; %Green oddball analysis
targsOfPlotInterest = [3,6]; %Green
chanIndsOfPlotInterest = [2];
mmnTargets = [3,6];
permCompGroups = []; %Green
ratioCompGroups = []; %Green
tackTargsOfInterest = [];
expName = 'Stitched' %Red testing
useAutoList = 1
listToUse = 'red 2023 greenblue experimental full' %Red testing
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '150721'
%dataset = '210721' %Just for debugging
%flyNum = 1;
%blockNum = 1; 
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=0; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2; %Whether to do traditional per-fly, per-jitter normalisation (1), per-fly, across-jitter normalisation (2), or no normalisation (0)
%}

%red 33 33 33 greenblue bluegreen red testing [28/05/23]
    %(Not really useful for proper analysis)
    %   
%{
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 8*60*60 ) && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
    ];
      
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

groupJitters = ones(1,size(groupSpecialEval,2));
      
groupDescriptors = [...
    {'S1 - Blue carr cyc imm. b4 green odd, wake (<8h), no red'},...
    {'S2 - Green carr cyc imm. b4 blue odd, wake (<8h), no red'},...
    {'S3 - Blue carr cyc imm. b4 green odd, sleep (<8h), no red'},...
    {'S4 - Green carr cyc imm. b4 blue odd, sleep (<8h), no red'},...
    {'S5 - Green odd cyc, sleep (<8h), no red'},...
    {'S6 - Blue odd cyc, sleep (<8h), no red'},...
    {'S7 - Green odd cyc, wake (<8h), no red'},...
    {'S8 - Blue odd cyc, wake (<8h), no red'},...
          ];
    %Note: Min. bout size (Beyond standard criteria) is not enforced for specialEvals where it is relevant (e.g. "1st 5 mins of sleep") except for "Last 5 mins.." (e.g. 25,26,31,32), where it is
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [2,7];
targsOfPlotInterest = [2,7]; %Green
chanIndsOfPlotInterest = [2];
mmnTargets = [2,7 ];
permCompGroups = [];
tackTargsOfInterest = [];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'red 2023 greenblue experimental cutdown testing' %Specifies a CSV list which will indicate what datasets to load (Note: Omit file extension)
listToUse = 'red 2023 greenblue control clean'
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '100222'
%dataset = '070922'
%flyNum = 1;
%blockNum = 1; 
customSaveComment = ['_Controls'] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 1; carrierOnlyStimChan = 1; searchWindow = 1; %Leeway for the stim channel here is unknown, window units is s

%}

%------------------------------------------------------------------------------

%red 33 33 33 greenblue bluegreen trimmed (No sleep separations) [30 05 23, updated 05 06 23])
%-- Apparent Thesis Ch. 6 grouping (Red) --
%   VICTORIX MAGNA aka RED QUEEN
%{
groupSpecialEval = [ ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 2'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 3'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 4'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 5'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 6'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 7'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 8'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 9'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 10'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 2'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 3'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 4'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 5'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 6'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 7'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 8'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 9'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 10'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...39
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...40
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...41
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...42
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...43
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...44
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...45
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...46
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...47
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},... 48
            {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...49
            {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...50
            {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...51
            {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...52
                {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...53
                {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...54
                {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...55
                {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...56      
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 2'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 3'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 4'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 5'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 6'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 7'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 8'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 9'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 10'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 2'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 3'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 4'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 5'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 6'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 7'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 8'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 9'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 10'},...
                ];
      
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

groupJitters = ones(1,size(groupSpecialEval,2));
      
groupDescriptors = [...
{'1 [154] - Green carr cyc imm. aft blue odd (<6h), no red'},...
{'2 [156] - Green carr cyc imm. aft blue odd (<6h), red'},...
{'3 [146] - Green carr cyc imm. b4 blue odd (<6h), no red'},...
{'4 [150] - Green carr cyc imm. b4 blue odd (<6h), red'},...
{'5 [148] - Green odd cyc (<6h), no red'},...
{'6 [152] - Green odd cyc (<6h), red'},...
{'7 [3] - Green odd cyc, sleep (<6h), no red'},...
{'8 [7] - Green odd cyc, wake (<6h), no red'},...
{'9 [75] - Green odd cyc, sleep (<6h), red'},...
{'10 [79] - Green odd cyc, wake (<6h), red'},...
    {'11 - Green odd cyc, no red, pre 1st red'},...
    {'12 - Green odd cyc, no red, post 1st red/pre 2nd red'},...
    {'13 - Green odd cyc, no red, post 2nd red/pre 3rd red'},...
    {'14 - Green odd cyc, no red, post 3rd red/pre 4th red'},...
    {'15 - Green odd cyc, no red, post 4th red/pre 5th red'},...
    {'16 - Green odd cyc, no red, post 5th red/pre 6th red'},...
    {'17 - Green odd cyc, no red, post 6th red/pre 7th red'},...
    {'18 - Green odd cyc, no red, post 7th red/pre 8th red'},...
    {'19 - Green odd cyc, no red, post 8th red/pre 9th red'},...
    {'20 - Green odd cyc, no red, post 9th red/pre 10th red'},...
        {'21 - Green carr cyc imm. aft blue odd, no red, pre 1st red'},...
        {'22 - Green carr cyc imm. aft blue odd, no red, post 1st red/pre 2nd red'},...
        {'23 - Green carr cyc imm. aft blue odd, no red, post 2nd red/pre 3rd red'},...
        {'24 - Green carr cyc imm. aft blue odd, no red, post 3rd red/pre 4th red'},...
        {'25 - Green carr cyc imm. aft blue odd, no red, post 4th red/pre 5th red'},...
        {'26 - Green carr cyc imm. aft blue odd, no red, post 5th red/pre 6th red'},...
        {'27 - Green carr cyc imm. aft blue odd, no red, post 6th red/pre 7th red'},...
        {'28 - Green carr cyc imm. aft blue odd, no red, post 7th red/pre 8th red'},...
        {'29 - Green carr cyc imm. aft blue odd, no red, post 8th red/pre 9th red'},...
        {'30 - Green carr cyc imm. aft blue odd, no red, post 9th red/pre 10th red'},...
            {'31 - Green carr cyc imm. aft blue odd, sleep (<6h), no red'},...
            {'32 - Green carr cyc imm. aft blue odd wake (<6h), no red'},...
            {'33 - Green carr cyc imm. aft blue odd, sleep (<6h), red'},...
            {'34 - Green carr cyc imm. aft blue odd, wake (<6h), red'},...
                {'35 - Green carr cyc b4 blue odd, sleep (<6h), no red'},...
                {'36 - Green carr cyc b4 blue odd wake (<6h), no red'},...
                {'37 - Green carr cyc b4 blue odd, sleep (<6h), red'},...
                {'38 - Green carr cyc b4 blue odd, wake (<6h), red'},...
{'39 [1 [154]] - Green carr cyc imm. aft blue odd (<Dead), no red'},...
{'40 [2 [156]] - Green carr cyc imm. aft blue odd (<Dead), red'},...
{'41 [3 [146]] - Green carr cyc imm. b4 blue odd (<Dead), no red'},...
{'42 [4 [150]] - Green carr cyc imm. b4 blue odd (<Dead), red'},...
{'43 [5 [148]] - Green odd cyc (<Dead), no red'},...
{'44 [6 [152]] - Green odd cyc (<Dead), red'},...
{'45 [7 [3]] - Green odd cyc, sleep (<Dead), no red'},...
{'46 [8 [7]] - Green odd cyc, wake (<Dead), no red'},...
{'47 [9 [75]] - Green odd cyc, sleep (<Dead), red'},...
{'48 [10 [79]] - Green odd cyc, wake (<Dead), red'},... 
            {'49 [31] - Green carr cyc imm. aft blue odd, sleep (<Dead), no red'},...
            {'50 [32] - Green carr cyc imm. aft blue odd wake (<Dead), no red'},...
            {'51 [33] - Green carr cyc imm. aft blue odd, sleep (<Dead), red'},...
            {'52 [34] - Green carr cyc imm. aft blue odd, wake (<Dead), red'},...
                {'53 [35] - Green carr cyc b4 blue odd, sleep (<Dead), no red'},...
                {'54 [36] - Green carr cyc b4 blue odd wake (<Dead), no red'},...
                {'55 [37] - Green carr cyc b4 blue odd, sleep (<Dead), red'},...
                {'56 [38] - Green carr cyc b4 blue odd, wake (<Dead), red'},...     
    {'57[11] - Green odd cyc, red, during 1st red'},...
    {'58[12] - Green odd cyc, red, during 2nd red'},...
    {'59[13] - Green odd cyc, red, during 3rd red'},...
    {'60[14] - Green odd cyc, red, during 4th red'},...
    {'61[15] - Green odd cyc, red, during 5th red'},...
    {'62[16] - Green odd cyc, red, during 6th red'},...
    {'63[17] - Green odd cyc, red, during 7th red'},...
    {'64[18] - Green odd cyc, red, during 8th red'},...
    {'65[19] - Green odd cyc, red, during 9th red'},...
    {'66[20] - Green odd cyc, red, during 10th red'},...
        {'67[21] - Green carr cyc imm. aft blue odd, red, during 1st red'},...
        {'68[22] - Green carr cyc imm. aft blue odd, red, during 2nd red'},...
        {'69[23] - Green carr cyc imm. aft blue odd, red, during 3rd red'},...
        {'70[24] - Green carr cyc imm. aft blue odd, red, during 4th red'},...
        {'71[25] - Green carr cyc imm. aft blue odd, red, during 5th red'},...
        {'72[26] - Green carr cyc imm. aft blue odd, red, during 6th red'},...
        {'73[27] - Green carr cyc imm. aft blue odd, red, during 7th red'},...
        {'74[28] - Green carr cyc imm. aft blue odd, red, during 8th red'},...
        {'75[29] - Green carr cyc imm. aft blue odd, red, during 9th red'},...
        {'76[30] - Green carr cyc imm. aft blue odd, red, during 10th red'},...
                ];

     
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [5,6,43,44];
targsOfPlotInterest = [5,6,43,44]; %Green
chanIndsOfPlotInterest = [1];
mmnTargets = [5,6 ; 7,9 ; 8,10];
%permCompGroups = [1,2 ; 5,6 ; 7,8 ; 9,10 ; 7,9 ; 8,10 ]; %Original carr/odd red vs not red
permCompGroups = [39,40 ; 43,44 ; 45,46 ; 47,48 ; 45,47 ; 46,48]; %As above, but for <dead
ratioCompGroups = [39,43 ; 40,44];
tackTargsOfInterest = [];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'red 2023 greenblue experimental cutdown testing' %A single red dataset
%listToUse = 'red 2023 greenblue experimental clean' %N=6 mostly good datasets
listToUse = 'red 2023 greenblue experimental cleaner' %N=5 removed 190423, who died ~4h in
%listToUse = 'red 2023 greenblue control clean' %Red controls
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '100222'
%dataset = '070922'
%flyNum = 1;
%blockNum = 1; 
customSaveComment = ['_examFigs'] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 1; carrierOnlyStimChan = 1; searchWindow = 1; %Leeway for the stim channel here is unknown, window units is s

isDeadList = 'red 2023 greenblue experimental cleaner'; %To ensure isDead values aren't used for wrong data
isDeadVals = ...
    [5101000,... %150323
    4600000,... %210323
    5608000,... %280323
    7491000,... %040423
    7122000]; %050423
    %These values relate to hardcoded Spliced reference frame indices after which data is qualitatively said to be 'dead' after
    %(Derived from a plot of SplicedData and behavInterp)
%}
%---
%overnight 33 33 33 greenblue bluegreen trimmed mirror of red same [05 06 23] - even more trimmed [11 06 24]
    %Intended for making figures wrt ERPs
%{
groupSpecialEval = [ ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1'}, ...
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1'}, ...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...   
        ];
      
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

%groupJitters = ones(1,size(groupSpecialEval,2));
groupJitters = [1,1,1,1,1,...
    0,0,...
    1,1,1,1];
      
groupDescriptors = [...
{'1 - [1 [1 [154]]] - Green carr cyc imm. aft blue odd (<6h)'},...
{'2 - [2 [3 [146]]] - Green carr cyc imm. b4 blue odd (<6h)'},...
{'3 - [3 [5 [148]]] - Green odd cyc (<6h)'},...
{'4 - [4 [7 [3]]] - Green odd cyc, sleep (<6h)'},...
{'5 - [5 [8 [7]]] - Green odd cyc, wake (<6h)'},...
    {'6 - Green carrieronly cyc, sleep (<6h)'},...
    {'7 - Green carrieronly cyc, wake (<6h)'},...
            {'8 - [22 - [31]] - Green carr cyc imm. aft blue odd, sleep (<6h)'},...
            {'9 - [23 - [32]] - Green carr cyc imm. aft blue odd wake (<6h)'},...
                {'10 - [24 - [35]] - Green carr cyc b4 blue odd, sleep (<6h)'},...
                {'11 - [25 - [36]] - Green carr cyc b4 blue odd wake (<6h)'},... 
         ];
        
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [1,3];
targsOfPlotInterest = [1,3]; %Green
chanIndsOfPlotInterest = [1,2,3];
mmnTargets = [8,9];
permCompGroups = [8,9];
tackTargsOfInterest = [];
ratioCompGroups = [8,9];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'overnight 33 33 33 greenblue bluegreen clean'
listToUse = 'overnight 33 33 33 greenblue bluegreen supercutdown2' %Modified version of cutdown to just 2 flies for testing
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '100222'
%dataset = '070922'
%flyNum = 1;
%blockNum = 1; 
customSaveComment = [] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 0; carrierOnlyStimChan = 1; searchWindow = 1; %Leeway for the stim channel here is unknown, window units is s
    %Note carrieronlyPhotSync turned off, because pretty sure PHOT was still integrated for this dataset (Could be wrong tho)
boxPlotMode = 1; grandAvERPSubplotMode = 1; 
%}        
%---
%overnight 33 33 33 greenblue bluegreen trimmed mirror of red same [05 06 23] - even more trimmed [11 06 24] - modified for Maxime
    %Note: All groups from data <6h unless otherwise specified
    % "Hakram"

groupSpecialEval = [ ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0'}, ... 1
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'}, ... 2
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ... 3
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ... 4
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ... 5
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ... 6
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... 7
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},... 8
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},... 9
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1'}, ... 10
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1'}, ... 11
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ... 12
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ... 13
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},... 14
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},... 15
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},... 16
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},... 17
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1'}, ... 18
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ... 19
        ];
      
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

%groupJitters = ones(1,size(groupSpecialEval,2));
groupJitters = [...
1,1,...    
    1,1,...
1,1,1,1,1,...
    0,0,0,0,...
        1,1,...
            1,1,...
0,0];
      
groupDescriptors = [...
{'1 - all carrier (not inc. carrieronly)'},...
{'2 - all oddball'},...
    {'3 - all green carriers'},...
    {'4 - all blue carriers'},...
{'5 - Green carr cyc imm. aft blue odd'},...
{'6 - Green carr cyc imm. b4 blue odd'},...
{'7 - Green odd cyc'},...
{'8 - Green odd cyc, sleep'},...
{'9 - Green odd cyc, wake'},...
    {'10 - Green carrieronly cyc, sleep'},...
    {'11 - Green carrieronly cyc, wake'},...
    {'12 - Blue carrieronly cyc, sleep'},...
    {'13 - Blue carrieronly cyc, wake'},...
            {'14 - Green carr cyc imm. aft blue odd, sleep'},...
            {'15 - Green carr cyc imm. aft blue odd wake'},...
                {'16 - Green carr cyc b4 blue odd, sleep'},...
                {'17 - Green carr cyc b4 blue odd wake'},... 
{'18 - Green carrieronly cyc'},...
{'19 - Blue carrieronly cyc'},...
         ];
        
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [7];
targsOfPlotInterest = [7]; %Green
chanIndsOfPlotInterest = [1,2,3];
mmnTargets = [8,9];
permCompGroups = [8,9];
tackTargsOfInterest = [];
ratioCompGroups = [8,9];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'overnight 33 33 33 greenblue bluegreen clean'
listToUse = 'overnight 33 33 33 greenblue bluegreen supercutdown2' %Modified version of cutdown to just 2 flies for testing
%listToUse = 'overnight 33 33 33 greenblue bluegreen maxime'
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '100222'
%dataset = '070922'
%flyNum = 1;
%blockNum = 1; 
customSaveComment = ['11point65'] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 1; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 0; %No norm.
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 0; carrierOnlyStimChan = 1; searchWindow = 1; %Leeway for the stim channel here is unknown, window units is s
    %Note carrieronlyPhotSync turned off, because pretty sure PHOT was still integrated for this dataset (Could be wrong tho)
boxPlotMode = 1; grandAvERPSubplotMode = 1; 
memoryEfficient = 1;
%}        
%---
%overnight 33 33 33 greenblue bluegreen trimmed mirror of red same [05 06 23] - even more trimmed [11 06 24] - modified for Maxime
    %Note: All groups from data <6h unless otherwise specified
    %   "FREE QUEEN"
%{
groupSpecialEval = [ ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0'}, ... 1
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1'}, ... 2
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ... 3
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ... 4
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ... 5
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ... 6
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},... 7
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},... 8
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},... 9
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1'}, ... 10
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1'}, ... 11
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ... 12
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ... 13
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},... 14
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},... 15
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},... 16
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},... 17
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1'}, ... 18
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1'}, ... 19
        ];
      
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

%groupJitters = ones(1,size(groupSpecialEval,2));
groupJitters = [...
1,1,...    
    1,1,...
1,1,1,1,1,...
    0,0,0,0,...
        1,1,...
            1,1,...
0,0];
      
groupDescriptors = [...
{'1 - all carrier (not inc. carrieronly)'},...
{'2 - all oddball'},...
    {'3 - all green carriers'},...
    {'4 - all blue carriers'},...
{'5 - Green carr cyc imm. aft blue odd'},...
{'6 - Green carr cyc imm. b4 blue odd'},...
{'7 - Green odd cyc'},...
{'8 - Green odd cyc, sleep'},...
{'9 - Green odd cyc, wake'},...
    {'10 - Green carrieronly cyc, sleep'},...
    {'11 - Green carrieronly cyc, wake'},...
    {'12 - Blue carrieronly cyc, sleep'},...
    {'13 - Blue carrieronly cyc, wake'},...
            {'14 - Green carr cyc imm. aft blue odd, sleep'},...
            {'15 - Green carr cyc imm. aft blue odd wake'},...
                {'16 - Green carr cyc b4 blue odd, sleep'},...
                {'17 - Green carr cyc b4 blue odd wake'},... 
{'18 - Green carrieronly cyc'},...
{'19 - Blue carrieronly cyc'},...
         ];
        
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [7];
targsOfPlotInterest = [7]; %Green
chanIndsOfPlotInterest = [1,2,3];
mmnTargets = [8,9];
permCompGroups = [8,9];
tackTargsOfInterest = [];
ratioCompGroups = [8,9];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'overnight 33 33 33 greenblue bluegreen clean'
listToUse = 'overnight 33 33 33 greenblue bluegreen supercutdown' %Modified version of cutdown to just 2 flies for testing
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '100222'
%dataset = '070922'
%flyNum = 1;
%blockNum = 1; 
customSaveComment = [] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 0; %No norm.
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 0; carrierOnlyStimChan = 1; searchWindow = 1; %Leeway for the stim channel here is unknown, window units is s
    %Note carrieronlyPhotSync turned off, because pretty sure PHOT was still integrated for this dataset (Could be wrong tho)
boxPlotMode = 1; grandAvERPSubplotMode = 1; 
memoryEfficient = 1; %Whether to attempt to save memory by discarding some large variables
%}     
%---

%33 33 33 greenblue bluegreen for daytime recordings (2024 edit)
    %Based on (apparent) ch.5 grouping coloured (PRAECO DEICTUS)
%   PRIMUS SECUTAR
%{
groupJitters = [...
    1,1,1,1,...
    1,1,0,0,...
    3,3,3,3,3,3,...
    3,3,3,3,...
    1,1,1,3,3,...
        1,1,1,1,...
        1,1,1,1,...
        1,1,1,1,...
        3,...
    ]; %Whether oddballs in the block are jittering (3) or not (1) or the block is carrieronly (0) or 100Hz sparsening (4)
groupSpecialEval = [ ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "blue")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "green")) ~= 1 && blockStruct(i).sentConditionNum == 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 5 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 5 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},... 
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
        {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0'},...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0'},...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 2 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
            {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 2 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
                {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 2'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3'}, ...
                    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4'}, ...
    {'groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc-1) == 4'},...
                ];
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );
groupDescriptors = [...
    {'1 - Blue phasic carr cyc imm. b4 green odd'},...
    {'2 - Green phasic carr cyc imm. b4 blue odd'},...
    {'3 - Green phasic odd cyc'},...
    {'4 - Blue phasic odd cyc'},...
        {'5 - Blue phasic carr cyc imm. aft. green odd'},...
        {'6 - Green phasic carr cyc imm. aft. blue odd'},...
            {'7 - Blue carrieronly'},...
            {'8 - Green carrieronly'},...
                {'9 - Blue jittering odd cyc prec. 4 green carr.'},...
                {'10 - Green jittering odd cyc prec. 4 blue carr.'},...
                {'11 - Blue jittering carr cyc prec. 3 blue carr'},...
                {'12 - Green jittering carr cyc prec. 3 green carr '},...
                {'13 - Blue jittering carr cyc prec. 4 blue carr'},...
                {'14 - Green jittering carr cyc prec. 4 green carr '},...  
        {'15 - Blue jittering odd cyc (All precede)'},...
        {'16 - Green jittering odd cyc (All precede)'},...     
        {'17 - Blue jittering carr cyc (All precede)'},...
        {'18 - Green jittering carr cyc (All precede)'},...
    {'19 - All phasic carr cyc imm. b4 green odd'},...
    {'20 - All phasic odd cyc'},...
    {'21 - All phasic carr cyc imm. aft. green odd'},...
    {'22 - All jittering carr cyc (All precede)'},...
    {'23 - All jittering odd cyc (All precede)'},...
            {'24 - Green phasic C1'},...
            {'25 - Green phasic C2'},...
            {'26 - Green phasic C3'},...
            {'27 - Green phasic C4'},...
                {'28 - Blue phasic C1'},...
                {'29 - Blue phasic C2'},...
                {'30 - Blue phasic C3'},...
                {'31 - Blue phasic C4'},...
                    {'32 - All phasic C1'},...
                    {'33 - All phasic C2'},...
                    {'34 - All phasic C3'},...
                    {'35 - All phasic C4'},...
    {'36 - All jittering odd cyc prec. 4 carr.'},...
    ];
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [36,20]; %Green oddball analysis
%targsOfInterest = [1,4,5]; %Blue oddball analysis
targsOfPlotInterest = [36,20]; %Green
%targsOfPlotInterest = [4,5]; %Blue
chanIndsOfPlotInterest = [2];
mmnTargets = [3,6];
permCompGroups = [2,3 ; 6,3]; %Green
%permCompGroups = [1,4 ; 5,4]; %Blue
ratioCompGroups = [3,2 ; 3,8; 3,6 ; 2,8 ; 6,8 ]; %Green
%ratioCompGroups = [ 4,1 ; 4,5 ]; %Blue
tackTargsOfInterest = [];
expName = 'Oddball' %Original
%expName = 'Stitched' %Red testing
useAutoList = 1
%listToUse = '33 33 33 greenblue bluegreen clean' %Specifies a CSV list which will indicate what datasets to load
listToUse = '33 33 33 greenblue bluegreen clean' %Specifies a CSV list which will indicate what datasets to load
%listToUse = 'red light control greenblue testing' %Red testing
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '150721'
%dataset = '210721' %Just for debugging
%flyNum = 1;
%blockNum = 1; 
customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
overnightMode=0; useOutPData=0; synchroniseMode=2; integMode=0; doPatternMatching=0; %invertPhotodiodeSignal=1; %Note: invertPhotodiodeSignal is automatically derived nowadays
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=0; doPatternMatching=0; %Red testing
patternMode=1; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2; %Whether to do traditional per-fly, per-jitter normalisation (1), per-fly, across-jitter normalisation (2), or no normalisation (0)
boxPlotMode = 1; %Whether to do sriBoxplots for select figures
%}
%---
%overnight 33 33 33 greenblue bluegreen even more trimmed, with colour irrespective groups added [18 07 24], untrimmed [22 11 24]
    %Based on trimming of IJAX IJASTUS
%   INDOMITUS REX
%{
groupSpecialEval = [ ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...   
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 2 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 2 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 2'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 3'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4'}, ...
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'}, ...
    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'},...
        {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
        {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
                        {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
                        {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...      
            ];
      
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

groupJitters = ones(1,size(groupSpecialEval,2));
      
groupDescriptors = [...
{'1 - Green carr cyc imm. aft blue odd (<6h)'},...
{'2 - Green carr cyc imm. b4 blue odd (<6h)'},...
{'3 - Green odd cyc (<6h)'},...
{'4 - Green odd cyc, sleep (<6h)'},...
{'5 - Green odd cyc, wake (<6h)'},...
            {'6 - Green carr cyc imm. aft blue odd, sleep (<6h)'},...
            {'7 - Green carr cyc imm. aft blue odd wake (<6h)'},...
                {'8 - Green carr cyc b4 blue odd, sleep (<6h)'},...
                {'9 - Green carr cyc b4 blue odd wake (<6h)'},...              
{'10 - All carr cyc imm. aft odd (<6h)'},...
{'11 - All carr cyc imm. b4 odd (<6h)'},...
{'12 - All odd cyc (<6h)'},...
{'13 - All carr cyc imm. aft odd, sleep (<6h)'},...
{'14 - All carr cyc imm. b4 odd, sleep (<6h)'},...
{'15 - All odd cyc, sleep (<6h)'},...
{'16 - All carr cyc imm. aft odd, wake (<6h)'},...
{'17 - All carr cyc imm. b4 odd, wake (<6h)'},...
{'18 - All odd cyc, wake (<6h)'},...
{'19 - Green C1 (<6h)'},...
{'20 - Green C2 (<6h)'},...
{'21 - Green C3 (<6h)'},...
{'22 - Green C4 (<6h)'},...
{'19 - Blue C1 (<6h)'},...
{'20 - Blue C2 (<6h)'},...
{'21 - Blue C3 (<6h)'},...
{'22 - Blue C4 (<6h)'},...
{'23 - All C1 (<6h)'},...
{'24 - All C2 (<6h)'},...
{'25 - All C3 (<6h)'},...
{'26 - All C4 (<6h)'},...
    {'27 - Blue carr cyc imm. aft green odd (<6h)'},...
    {'28 - Blue carr cyc imm. b4 green odd (<6h)'},...
    {'29 - Blue odd cyc (<6h)'},...
        {'30 - Blue odd cyc, sleep (<6h)'},...
        {'31 - Blue odd cyc, wake (<6h)'},...
                {'32 - Blue carr cyc imm. aft green odd, sleep (<6h)'},...
                {'33 - Blue carr cyc imm. aft green odd wake (<6h)'},...
                    {'34 - Blue carr cyc b4 green odd, sleep (<6h)'},...
                    {'35 - Blue carr cyc b4 green odd wake (<6h)'},... 
         ];
        
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [10,12];
targsOfPlotInterest = [10,12]; %Green
chanIndsOfPlotInterest = [1];
mmnTargets = [10,12; 13,15; 16,18];
permCompGroups = [1,2];
tackTargsOfInterest = [];
ratioCompGroups = [10,12; 13,15; 16,18];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'overnight 33 33 33 greenblue bluegreen supercutdown2'
listToUse = 'overnight 33 33 33 greenblue bluegreen clean' %Modified version of cutdown to just 2 flies for testing
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '100222'
%dataset = '070922'
%flyNum = 1;
%blockNum = 1; 
customSaveComment = [] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 0; carrierOnlyStimChan = 1; searchWindow = 1; %Leeway for the stim channel here is unknown, window units is s
    %Note carrieronlyPhotSync turned off, because pretty sure PHOT was still integrated for this dataset (Could be wrong tho)
boxPlotMode = 1;
memoryEfficient = 1;
%}        
%---
%{
isDeadList = 'red 2023 greenblue experimental cutdown testing'; %To ensure isDead values aren't used for wrong data
isDeadVals = [...
    4600000]; %210323
%}
%{
isDeadList = 'red 2023 greenblue control clean'; %To ensure isDead values aren't used for wrong data
isDeadVals = [...
    6213000,... %270423
    6905000]; %260423
%}
%}


%----------------------------------------

%------------------------------------------------------------------------------

%red 33 33 33 greenblue bluegreen trimmed...even further [10 10 24]
%       "Ace of Hearts" (derived from Victorix Magna/Red Queen)
%           (Removed pre/post red groups for speed)
%{
groupSpecialEval = [ ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...39
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...40
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'}, ...41
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'}, ...42
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...43
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...44
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...45
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...46
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...47
{'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},... 48
            {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...49
            {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...50
            {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...51
            {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...52
                {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...53
                {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 0'},...54
                {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...55
                {'( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) < isDeadVals(IIDN) ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && SplicedRedLightBin( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) ) == 1'},...56      
                   ];
      
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

groupJitters = ones(1,size(groupSpecialEval,2));
      
groupDescriptors = [...
{'1 [1 [154]] - Green carr cyc imm. aft blue odd (<6h), no red'},...
{'2 [2 [156]] - Green carr cyc imm. aft blue odd (<6h), red'},...
{'3 [3 [146]] - Green carr cyc imm. b4 blue odd (<6h), no red'},...
{'4 [4 [150]] - Green carr cyc imm. b4 blue odd (<6h), red'},...
{'5 [5 [148]] - Green odd cyc (<6h), no red'},...
{'6 [6 [152]] - Green odd cyc (<6h), red'},...
{'7 [7 [3]] - Green odd cyc, sleep (<6h), no red'},...
{'8 [8 [7]] - Green odd cyc, wake (<6h), no red'},...
{'9 [9 [75]] - Green odd cyc, sleep (<6h), red'},...
{'10 [10 [79]] - Green odd cyc, wake (<6h), red'},...
            {'11 [31] - Green carr cyc imm. aft blue odd, sleep (<6h), no red'},...
            {'12 [32] - Green carr cyc imm. aft blue odd wake (<6h), no red'},...
            {'13 [33] - Green carr cyc imm. aft blue odd, sleep (<6h), red'},...
            {'14 [34] - Green carr cyc imm. aft blue odd, wake (<6h), red'},...
                {'15 [35] - Green carr cyc b4 blue odd, sleep (<6h), no red'},...
                {'16 [36] - Green carr cyc b4 blue odd wake (<6h), no red'},...
                {'17 [37] - Green carr cyc b4 blue odd, sleep (<6h), red'},...
                {'18 [38] - Green carr cyc b4 blue odd, wake (<6h), red'},...
{'19 [39 [1 [154]]] - Green carr cyc imm. aft blue odd (<Dead), no red'},...
{'20 [40 [2 [156]]] - Green carr cyc imm. aft blue odd (<Dead), red'},...
{'21 [41 [3 [146]]] - Green carr cyc imm. b4 blue odd (<Dead), no red'},...
{'22 [42 [4 [150]]] - Green carr cyc imm. b4 blue odd (<Dead), red'},...
{'23 [43 [5 [148]]] - Green odd cyc (<Dead), no red'},...
{'24 [44 [6 [152]]] - Green odd cyc (<Dead), red'},...
{'25 [45 [7 [3]]] - Green odd cyc, sleep (<Dead), no red'},...
{'26 [46 [8 [7]]] - Green odd cyc, wake (<Dead), no red'},...
{'27 [47 [9 [75]]] - Green odd cyc, sleep (<Dead), red'},...
{'28 [48 [10 [79]]] - Green odd cyc, wake (<Dead), red'},... 
            {'29 [49 [31]] - Green carr cyc imm. aft blue odd, sleep (<Dead), no red'},...
            {'30 [50 [32]] - Green carr cyc imm. aft blue odd wake (<Dead), no red'},...
            {'31 [51 [33]] - Green carr cyc imm. aft blue odd, sleep (<Dead), red'},...
            {'32 [52 [34]] - Green carr cyc imm. aft blue odd, wake (<Dead), red'},...
                {'33 [53 [35]] - Green carr cyc b4 blue odd, sleep (<Dead), no red'},...
                {'34 [54 [36]] - Green carr cyc b4 blue odd wake (<Dead), no red'},...
                {'35 [55 [37]] - Green carr cyc b4 blue odd, sleep (<Dead), red'},...
                {'36 [56 [38]] - Green carr cyc b4 blue odd, wake (<Dead), red'},...     
                ];

colChecks = [{[{3},{'peBinary'}]},...
{[{14},{'peBinaryFull'}]},...
{[{15},{'peBinaryFramesFromLast'}]},...
{[{18},{'redLightBinary'}]}]; %New
%{[{17},{'redLightBinary'}]}]; %Old position, before probMetric implemented 
            
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [19,20,23,24];
targsOfPlotInterest = [19,20,23,24]; %Green
chanIndsOfPlotInterest = [1];
mmnTargets = [25,27 ; 26,28; 29,31; 30,32];
%permCompGroups = [1,2 ; 5,6 ; 7,8 ; 9,10 ; 7,9 ; 8,10 ]; %Original carr/odd red vs not red
permCompGroups = []; %As above, but for <dead
ratioCompGroups = [25,27 ; 26,28; 29,31; 30,32];
tackTargsOfInterest = [];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'red 2023 greenblue experimental cutdown testing' %A single red dataset
%listToUse = 'red 2023 greenblue experimental clean' %N=6 mostly good datasets
%listToUse = 'red 2023 greenblue experimental cleaner' %N=5 removed 190423, who died ~4h in
listToUse = 'red 2023 greenblue control clean' %Red controls
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '100222'
%dataset = '070922'
%flyNum = 1;
%blockNum = 1; 
customSaveComment = ['postMock'] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 1; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
doSeqDep = 0;
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 1; carrierOnlyStimChan = 1; searchWindow = 1; %Leeway for the stim channel here is unknown, window units is s
boxPlotMode = 1;
%{
isDeadList = 'red 2023 greenblue experimental cleaner'; %To ensure isDead values aren't used for wrong data
isDeadVals = ...
    [5101000,... %150323
    4600000,... %210323
    5608000,... %280323
    7491000,... %040423
    7122000]; %050423
    %These values relate to hardcoded Spliced reference frame indices after which data is qualitatively said to be 'dead' after
    %(Derived from a plot of SplicedData and behavInterp)
%}

isDeadList = 'red 2023 greenblue control clean'; %To ensure isDead values aren't used for wrong data
isDeadVals = [...
    6213000,... %270423
    6905000]; %260423
memoryEfficient = 1;
%}

%------------------------------------------------------------------------------

%overnight 33 33 33 greenblue bluegreen trimmed w/ PEs/etc, and alt events (w/ identity) [14 11 24]
    %   "GMOD" (derived from Garry)
%{
groupSpecialEval = [ ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1'}, ...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0'},...   
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...   
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
                {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 4 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...   
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 16 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && ( behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 17 ) < 100 || behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 18 ) < 100 )'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 1'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 1'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 1'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 1'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 2'},...
{'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 2'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 2'},...
            {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 0 && blockStruct(i).allPeaksList.distFromLastOddball(groupCyc) == 1 && isempty(strfind(blockStruct(i).sentColours, "greenblue")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 2'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 2'},...
                    {'( blockStruct(i).startTimeRel >= 0 && blockStruct(i).startTimeRel < 6*60*60 ) && groupCyc > 2 && blockStruct(i).allPeaksList.typeNum(groupCyc) == 1 && blockStruct(i).allPeaksList.typeNum(groupCyc-1) == 0 && isempty(strfind(blockStruct(i).sentColours, "bluegreen")) ~= 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 1 ) == 0 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 15 ) == 1 && behavInterp( blockStruct(i).range( blockStruct(i).allPeaksList.relPos(groupCyc) ) , 22 ) == 2'},...              
                    ];
%To do: Update hardcoded frame numbers for new groups to be resample freq based      
groupTargets = repmat( {'blockStruct(i).allPeaksList.relPos'} , 1 , size(groupSpecialEval,2) );

groupJitters = ones(1,size(groupSpecialEval,2));
      
groupDescriptors = [...
{'1 - Green carr cyc imm. aft blue odd (<6h)'},...
{'2 - Green carr cyc imm. b4 blue odd (<6h)'},...
{'3 - Green odd cyc (<6h)'},...
{'4 - Green odd cyc, sleep (<6h)'},...
{'5 - Green odd cyc, wake (<6h)'},...
            {'6 - Green carr cyc imm. aft blue odd, sleep (<6h)'},...
            {'7 - Green carr cyc imm. aft blue odd wake (<6h)'},...
                {'8 - Green carr cyc b4 blue odd, sleep (<6h)'},...
                {'9 - Green carr cyc b4 blue odd wake (<6h)'},... 
{'10 - Green carr cyc imm. aft blue odd, alt event (<6h)'},...
{'11 - Green odd cyc, alt event (<6h)'},...
            {'12 - Green carr cyc imm. aft blue odd, sleep, alt event (<6h)'},...
            {'13 - Green carr cyc imm. aft blue odd wake, alt event (<6h)'},...
                {'14 - Green carr cyc b4 blue odd, sleep, alt event (<6h)'},...
                {'15 - Green carr cyc b4 blue odd wake, alt event (<6h)'},... 
                    {'16 - Green odd cyc, sleep, alt event (<6h)'},...
                    {'17 - Green odd cyc, wake, alt event (<6h)'},... 
{'18 - Green carr cyc imm. aft blue odd, PE orig. (<6h)'},...
{'19 - Green odd cyc, PE orig. (<6h)'},...
            {'20 - Green carr cyc imm. aft blue odd, sleep, PE orig. (<6h)'},...
            {'21 - Green carr cyc imm. aft blue odd wake, PE orig. (<6h)'},...
                {'22 - Green carr cyc b4 blue odd, sleep, PE orig. (<6h)'},...
                {'23 - Green carr cyc b4 blue odd wake, PE orig. (<6h)'},... 
                    {'24 - Green odd cyc, sleep, PE orig. (<6h)'},...
                    {'25 - Green odd cyc, wake, PE orig. (<6h)'},...  
            {'26 - Green carr cyc imm. aft blue odd, sleep, 10s b4 or aft. PE orig. (<6h)'},...
            {'27 - Green carr cyc imm. aft blue odd wake, 10s b4 or aft. PE orig. (<6h)'},...
                    {'28 - Green odd cyc, sleep, 10s b4 or aft. PE orig. (<6h)'},...
                    {'29 - Green odd cyc, wake, 10s b4 or aft. PE orig. (<6h)'},... 
{'30 - Green carr cyc imm. aft blue odd, alt event arb. group 1 (<6h)'},...
{'31 - Green odd cyc, alt event arb. group 1 (<6h)'},...
            {'32 - Green carr cyc imm. aft blue odd, sleep, alt event arb. group 1 (<6h)'},...
            {'33 - Green carr cyc imm. aft blue odd wake, alt event arb. group 1 (<6h)'},...
                    {'34 - Green odd cyc, sleep, alt event arb. group 1 (<6h)'},...
                    {'35 - Green odd cyc, wake, alt event arb. group 1 (<6h)'},... 
{'36 - Green carr cyc imm. aft blue odd, alt event arb. group 2 (<6h)'},...
{'37 - Green odd cyc, alt event arb. group 2 (<6h)'},...
            {'38 - Green carr cyc imm. aft blue odd, sleep, alt event arb. group 2 (<6h)'},...
            {'39 - Green carr cyc imm. aft blue odd wake, alt event arb. group 2 (<6h)'},...
                    {'40 - Green odd cyc, sleep, alt event arb. group 2 (<6h)'},...
                    {'41 - Green odd cyc, wake, alt event arb. group 2 (<6h)'},... 
];
     
colChecks = [{[{3},{'peBinary'}]},...
            {[{15},{'altStructEventsFull'}]},...
            {[{16},{'peBinaryFull'}]},...
            {[{17},{'peBinaryFramesFromLast'}]},...
            {[{19},{'altFramesFromLast'}]},...
            {[{22},{'altIdentityFull'}]},...
            ]; %For situations of integ, will be compared against behavCorrectedLabels to ensure the correct columns are being referenced   
     
%TO ADD:
%   - Carrieronly equivalents
%   - Reaches
        
%blockSplitNum = 2; %Originally intended for Overnight data; How many segments to split blockStruct into (Note: +1 will be applied, since linspace with an n of 4 technically gives thirds for example)
    %This will be used to find equally placed points in blockStruct (e.g. blockSplitNum of 2 (Halves) will return [0, 124 and 248] for data with 248 blocks) 
targsOfInterest = [17,16];
targsOfPlotInterest = [17,16]; %Green
chanIndsOfPlotInterest = [1];
mmnTargets = [1,2]; %Must be non-empty for later QAs
%permCompGroups = [1,2]; %Moved below
tackTargsOfInterest = [];
ratioCompGroups = [1,10;3,11];
expName = 'Stitched'
useAutoList = 1
%listToUse = 'overnight 33 33 33 greenblue bluegreen clean'
listToUse = 'overnight 33 33 33 greenblue bluegreen supercutdown2'
chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}];
%dataset = '080721'
%flyNum = 1;
%blockNum = 1; 
customSaveComment = ['_PosterFigs2'] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
%overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=0; allowNullPhot=1;
overnightMode=1; useOutPData=1; synchroniseMode=2; integMode=1; doPatternMatching=1; %Red testing
patternMode=2; thirdStagePhotoSynchronise=0; applyAggressivePostSync=1; allowNullPhot=1; 
arbitraryPermSizeParity = 0;
automatedSavePlots = 0; additionalFigParams = customSaveComment;%additionalFigParams = [''];
enforcePTTPrecedence = 0; %Whether to enforce PTT max/min to precede the inverse, based on pttPrecedencePerChan
if enforcePTTPrecedence == 1
    pttPrecedencePerChan = [1,1,2]; %Whether the max (1) or min (2) should be first
end
enforcePTTPostStimulus = 1;
normaliseERPs = 3; %Colour normalisation
doPerm = 0;
permCompGroups = [1,2]; %Must be non-empty for later QAs
doSeqDep = 0;
jittPSDNormMode = 2;
doCarrieronlyPhotSynchronisation = 0; carrierOnlyStimChan = 1; searchWindow = 1; %Leeway for the stim channel here is unknown, window units is s
    %Note carrieronlyPhotSync turned off, because pretty sure PHOT was still integrated for this dataset (Could be wrong tho)
memoryEfficient = 1;
boxPlotMode = 1;
%}        
%---

%----------------------------------------

rerefMode = 2; %Whether to do ICA (1), polarity reversal channel rereferencing (2), none at all (3) or an average of the pre-flip polarity reversal channel and the post-flip channel (4)
rerefIndex = [{'ICAd'} , {'PolReversReRefd'} , {'None'} , {'PolFlipAvReRefd'}];

doLoadCalib = 1; %Whether to load calib files (currently literally just to know the polarity reversal location)

useSaveStruct = 1; %Whether to attempt to use saveStruct data
if useSaveStruct == 1
    disp(['-- Using saveStruct data (if existing) --'])
else
    disp(['#- NOT using saveStruct data -#'])
end
MATNeeds = [{'Gating'},{'Channel'},{'Amplitude'},{'Stimulus'},{'TTL'},{'sentStimuli'}]; %List of needed fields from either the saveStruct or separate files

doRemoveLineNoise = 1; %Whether to remove line noise (and harmonics) or not

doButterworth = 0; %Whether to enable Butterworth filtering
%ADD AN INDEX AND ASSOCIATED DISPLAY CODE
if doButterworth == 1
    input('-# BUTTERWORTH FILTER ACTIVE (ENTER TO ACK) #-')
end

saveFigs = 0; %Whether to save figures
%if saveFigs == 1
    %figPath = 'D:\group_swinderen\Matthew\TDTs\Figures\AUTO'
    %figPath = 'D:\group_vanswinderen\Matt\Figures'
    %figPath = 'C:\Users\flylab\Desktop\Matt\Figures'
    figPath = '..\Figures'
    %Check if exist and make if doesn't
    if isempty(dir(figPath))  == 1
        mkdir(figPath)    
    end
%end
%automatedSavePlots = 1; %Whether to double up and do automated saving as well
    %If autoList, plots will be saved in corresponding folder in list directory, otherwise in explicit folder
    %Also note: Due to aishittei, only runs if useAutoList is true
    %As of 10.25XM is now defined by the parameter group
if automatedSavePlots == 1
    automatedSaveVectors = 1; %Whether to try save vector versions of figs before saving as PNGs
    %vectorFigPath = [figPath, filesep, 'Vec'];
    clearOldFigures = 1; %Whether to clear old auto-generated figures
    closeFiguresAfterSaving = 1; %Whether to iteratively close figures during the save process to save memory
    %additionalFigParams = ['_2023_noPermParity']; %Any relevant modifiers will be appended to this
        %As of 10.25, defined with automatedSavePlots in parameter group above
    addpath(genpath([toolPath filesep 'altmany-export_fig-9676767']));
    warning('off','MATLAB:ui:javaframe:PropertyToBeRemoved');
    warning('off','MATLAB:print:FigureTooLargeForPage');
end

saveIntegrationVariables = 0; %Whether to save a number of variables necessary for integration with behavioural scripts to file
%DEPRECATED ON ACCOUNT OF USING SASIFRAS FOR INTEGRATION
if saveIntegrationVariables == 1
    integVariablesList =  [{'overVar'},{'flagParamSaveStruct'},{'overSplice'}];
    %integPath = 'D:\group_swinderen\Matthew\TDTs\Integs';
    integPath = '..\TDTs\Integs';
end

doMat = 0; %Whether to assemble a matrix of the data for external analysis
if doMat == 1 
    saveMat = 0;
    if saveMat == 1
        matSavePath = 'D:\group_swinderen\Matthew\TDTs\Matrices';
    end
end

deleteTerminalCrashSentBlocks = 1; %Delete terminal blocks from sentStimuli if a crash occurred there, to preserve synchronicity
    %Note: Will only be actioned if there is a mismatch between detected and sent block numbers, to protect instances where there was a crash but it occurred during the block itself
        %(Rather than the target case, which is where the block was 'sent' but TDT crashed before the data was recorded for that block)

%###################

%useAutoList = 1; %Whether to use a list of flies
    %(Now specified lower, per specialEval)

saveOverVar = 0; %Whether to save the overVar variable (and an ancillary) at the end of the fly loopif

useAlreadyAnalysed = 0; %Whether to save time for repeated analysis by loading previously processed data (if the flagParamSaveStruct matches)
if useAlreadyAnalysed == 1
    excludeList = [{'ans'},{'currentDateTime'},{'saveOverVar'},{'overVarPath'},{'overVar'}, {'excludeList'}, ...
        {'i'}, {'saveFigs'},{'figPath'},{'doMat'},{'haltOnDifference'},{'normaliseERPs'},{'showCorrected'}, {'targsOfInterest'}, ...
        {'chansOfInterestActive'}, {'chanColours'}, {'normaliseERPs'}, {'normalisePerms'}, {'useAlreadyAnalysed'}, {'rerefIndex'}, ...
        {'numBoots'}]; %Every variable except the ones listed here will be checked for perfect synchronicity
    haltOnDifference = 1; %Whether to halt on detecting a difference between the saved and new flagParams, to facilitate adjustment of params to suit saved data
end

overnightMode = overnightMode; %Whether this is part of an overnight recording (mainly applies to sentStimuli etc)
    %(Specification shifted to specialEvals)
if overnightMode == 1
    useStitched = 1; %Whether to use stitched data (mainly an overnight thing)
else
    useStitched = 0; %Not a param
end

%###################
ancFielExcludeList = ['-thisFlyUniqueNumber-uniqueSentColours-polReversalChan-']; %Fields in this list will not be checked for consistency between files when generalStruct is assembled

overrideErrors = 1; %Whether to force an override of errors that would normally cause a crash
    %Note: Inadvisable to leave enabled for long periods of time
if overrideErrors == 1
    ['-#-# Non-critical errors set to be overriden #-#-']
end

baselineCorrectionMethod = 0; %0 - Normalised to 3s preceding start of respective block, 1 - Corrected to short window preceding each individual cycle
baselineCorrectionDescIndex = [{'Block-normalised'},{'Cycle-corrected'}];

halfWidthTTLCorrection = 0.4; %For square wave paradigms dictates the positive correction (in terms of f1 sample width) to apply to detected peak coords when pulling TTL values
    %This is necessary because small asynchronies between the underlying and artificial stimulus signals may cause 'perfect' accuracy TTL pulls to incorrectly use the previous TTL identity
        %It is not required for this value to indicate the perfect centre of the stimulus, just a spot a decent amount from the TTL 'edge'

windowGeometries = [{[-0.25,0.75]},{[-0.5,0.5]}]; %Capture window geometries (in fractions of captureWindowSize) for square and sine respectively       
    %For square this nominally captures 25% pre-stim onset then 75% post-onset
    %For sine it is 50/50 either side of stimulus peak
%captureWindowGeometry = [-0.1, 0.9]; %"Be first value (in %) pre centroid and second value post"

showCorrected = 1; %Whether to use corrected or uncorrected data for plots

normaliseERPs = normaliseERPs; %Whether to normalise ERPs between flies by dividing by the mean of stimulus onset amplitudes across all peaks (1) or the self-max per plot (2) or by colour (3) or not at all (0)
normaliseIndex = [{'(All-peaks-amplitude normalised)'},{'(Self-max normalised)'},{'(Colour normalised)'}];
    %Note: Colour normalisation (3) may be unstable for blank groups, due to the small values inherent in such ERPs
    %Secondary note: This can *theoretically* be changed after runtime, but it's not exactly encouraged (Only eyeballed valid for grand average ERP plot and grand av PTT plots)
if normaliseERPs ~= 0
    fixedPhotodiodeScale = 1; %Maximum value for photodiode signal to be shown as on average ERP plots
        %Note: For simplicity, to prevent this from stretching out null (e.g. missing oddball) photodiode signals, this only comes into effect if the photodiode signal would have breached this value
else
    fixedPhotodiodeScale = 100; 
end

specMethod = 3; %Whether to use mtspectrumsc (1), pwelch (2) or just an FFT (3) for spectrum analysis
specIndex = [{'MTSpectrumC'},{'PWelch'},{'Simple FFT'}];

doPerm = doPerm; %Whether to do permutation statistics (1) or not (0)
if doPerm == 1
    permRandomisations = 1000; %How many randomisations to use for perm statistics (1000 randomisations translates to roughly 20s of processing time)
    %normalisePerms = 2; %Whether to not normalise the values used in the (grand average) perm calcs (0) or normalise according to which group in each comparison is largest (2) (Redundant now with usage of normaliseERPs flag)
    postHocCorrectPerms = 2; %Whether to force all traces to start at 0, regardless of prior correction/normalisation, based on either the first point in the capture window (1) or the stimulus onset position (2)
    %arbitraryPermSizeParity = 1; %Whether to enforce arbitrary parity between the different hyperGroup Ns
        %This works by subselecting larger N'd groups when calculating permutation statistics (hyperGroup construction is unaffected)
        %Possible interactions with groupGyperArk not tested
        %Similar in effect to doSubSampling, except that doSubSampling acts at the hyperGroup level and is applied to all hyperGroups equally
    reportPerm = 0; %Whether to report the perm groups at start of run
    grandSubjectType = 2; %Whether for the grand average perm calculations to use blocks as subjects (1) or flies as subjects (2)
        %E.g. A data list with 8 flies and 72 blocks per fly will with mode 1 give an N for comparison of up to 576 (assuming the hyperGroup in question is present in every block), versus a mode 2 N of 8
            %It is currently unclear which is more valid
        %Note: Currently the individual perm comps technically use method 1
    plotPermPhots = 1; %Whether to plot phots on the hyperGroup plot
    permAlpha = 0.05; %What alpha level to use for permutation analysis (Previously 0.025)
end

doIndividualColours = 1; %Whether to make scatter colours (for certain plots) relate to individual identity (1) or group (2)
if doIndividualColours == 1
    doAncillaryText = 1; %Whether to emphasise this further by writing fly numbers inside scatter points
end

overrideGroupColours = 0; %Whether to override group colours to be based on the size of plotted groups for some plots
    %This is useful for large numbers of hyperGroups, where colours are effectively indistinguishable on the grand average erp etc

doIndivLines = 0; %Whether to do indiidual lines for certain plots (Av. ERP, Av. Filtered ERP)

hidePTTLocsSubplots = 0; %Whether to hide the peak/trough location barplots (1) or not (0)

doBootStrapping = 0; %Whether to bootstrap the PTT plot
if doBootStrapping == 1
    bootTarget = 12; %What target group to use for the number of bootstraps
    numBoots = 2500; %How many bootstrap samples to take
    %bootRounds = 1; %How many rounds of bootstrapping to do (Mostly redundant now with proper bootstrapping implementation)
end

dontSaveProcessed = 1; %Disables the mostly Rhiannon-centric saving of structures to the Processed directory

doFilteredPlots = 0; %Whether to calculate filtering for the entire dataset and recapitulate the hyperGroups with each set of filtered whole-fly data
if doFilteredPlots == 1
    filterRanges = [ 1,10 ; 11,20 ; 21,30 ; 31,40 ]; %Will be used to filter the ERP ranges
end

doPatternMatching = doPatternMatching;
    %(Specification shifted to specialEvals)
if doPatternMatching ~= 0
    patternMode = patternMode; %Whether to use Colour (1) or OutP (2) to derive detected blocks identity
        %(Specification shifted to specialEvals)
        %Colour matching will attempt to derive the carrieronly/oddball status of blocks from the deviation in photodiode signal
        %OutP matching will use the new, meaningful data in OutP to dervice the identity of blocks from the carrieronly (Ch. 1) or carrier/oddball (Ch. 2/3) rows of the TTL 

    ditchSentStructIfNecessary = 1; %Whether to ditch a row of sentStruct if that is necessary to achieve perfect synchronicity
end

doTrapz = 0; %Whether to perform AUC calculations
    %With normal (e.g. <48 ) numbers of hyperGroups the time to calculate will not be large, but with very large (e.g. 152 ) numbers the time will stack up  

synchroniseMode = synchroniseMode; %What method to use to synchronise the real and artificial stimulus signals (1 - findpeaks, 2 - whole signal difference minimisation)
    %(Specification shifted to specialEvals)
    
thirdStagePhotoSynchronise = thirdStagePhotoSynchronise; %Whether to post-hoc synchronise hyperGroup data
    %(Specification shifted to specialEvals)
    %This attempts to synchronise all collected cycles in a hyperGroup according to the photodiode signal
    %Note: It will produce critically incorrect outputs for groups that contain differing photodiode phases
        %E.g. "Both coloured and missing oddballs"
    %Secondary note: This synchronisation autodisables itself for groups where the stimulus was 'blank' (But does not stop any others from being synchronised)
if thirdStagePhotoSynchronise == 1
    flatnessThreshold = 100; %Arbitrary value used to determine what is flat portion of photodiode signal (In cases of square wave data)
    synchroniseAll = 1; %Whether to synchronise all cycles across hyperGroups (1) or just within hyperGroups (0)
end

useOutPData = useOutPData; %Whether to use OutP data if it is existing
    %(Specification shifted to specialEvals)
if useOutPData == 1
    synchroniseOutP = 0; %Whether to synchronise OutP (if existing)
        %Testing shows that synchronising may actually impair OutP usage for peak comparison
            %And it may even be unnecessary given that OutP should natively be synchronised with virtual data...
    postSyncOutP = 0; %Whether to apply an additional half-width shift to OutP data to ensure it is aligned over the rise of the art signal, rather than being 'perfectly' synchronised
    %Note: These preceding two methods are technically inferior to post-synchronisation, although they rely on an assumption of OutP onset at the start of each block
    
    ditchNonMatchingBlocks = 1; %Whether to physically jettison blocks that fail to match detected vs OutP
    allowPartialMatches = 1; %Whether to allow the preservation of blocks where most (or some) of the cycles match
    if allowPartialMatches == 1
        partialMatchThreshold = 0.9; %Number of matches must exceed at least this fraction of the (apparently) sent 
            %It is theoretically possible to set this to 0, but do we really want blocks where only 3 cycles match what was apparently sent? Are these blocks likely to be normal?
        checkTranslocation = 1; %Whether to allow the OutP data to be translocated left/right to see if there lack of matching is a phase issue
        if checkTranslocation == 1
            transLimit = 10; %How many positions left/right to test
        end
    end
    checkCycleIdent = 1; %Whether to check cycle identities against cycleIdent from sentStimuli
    suppressDitchOutput = 1; %Whether to suppress (most) of the text output from the ditching
end

%invertPhotodiodeSignal = 1; %Whether to invert channel 4 of <the photodiode data> for ease of reading
    %Automated for the moment based on modernData (but may add in capacity for override)

doSpectralPlots = 0; %Whether to do special spectral plots
if doSpectralPlots == 1
    spectralGroups = [22,28]; %What groups to look at
    winSize = 0.05; %Number of seconds (Will be multiplied by resampleFreq to convert into frames)
    winOverlap = 0.025; %Size of window overlap in seconds
    probF = 0.05:0.1:40; %Frequency resolution
    
    brunoExpansionFactor = 10;
    plotMode = 2; %1 for spectrograms, 2 for FFT
    leakSize = 0.1; %How many Hz either side of f1/2 to look for when calculating amplitudes of aforementioned
end

applyAggressivePostSync = applyAggressivePostSync;
    %(Specification shifted to specialEvals)
    %Note: aggressivePostSync works on stim data, so it is unaffected by colour groups, but it will be affected by stim recording architectures between modern and legacy data
if applyAggressivePostSync == 1 & ( ( useOutPData == 1 & synchroniseOutP == 1 ) | ( useOutPData == 1 & postSyncOutP == 1 ) )
    ['-# Caution: Generalised aggressive post-sync and OutP-specific sync methods are simultaneously active #-']
        %This isn't dangerous or anything; The OutP synchronisation will just be overridden by the later aggressive post-sync
end

doSeqDep = doSeqDep;
if doSeqDep == 1 
    seqMeld = 1; %Whether to meld patterns that share a start (And if so, how far to meld)
        %E.g. A meld of 1 checks the first element and merges patterns that share that
        %A merge of 2 checks the first, merges those, then checks the second, and so on
    seqOrder = [1,9,5,13,3,11,7,15,2,10,6,14,4,12,8,16]; %Reorder seq dep patterns from binary
end

doOnionPlot = 1;
if doOnionPlot == 1
    onionFraction = 0.1; %What fraction of all elements within a target hyperGroup to show (e.g. "0.1" means "Show 10% of elements")
end

normaliseRedFFT = 1; %Will be applied if red FFT can be calculated
    %modernData required 

%#################
%Special cases (not intended for everyday use)
doSubSampling = 0; %Whether to subsample the data (randomly) to match the n of a particular hyperGroup
if doSubSampling == 1
    subSampleTarget = 34; %Which group to use as a reference for n
    input(['#- Caution: Subsampling enabled (Enter to ack)#-'])
end
doPostHocSubSampling = 0; %A cut-down version of the subsampling that does not require a fresh run to be enacted
    %Note: This works by filtering what data reaches cerain plots that I have bothered to give conditions for this
if doPostHocSubSampling == 1
    postHocSubSampleTarget = 10;
end

%QA/etc
if doSubSampling == 1 | doPostHocSubSampling == 1
    if saveOverVar == 1
        saveOverVar = 0; %Force override
        disp(['#- overVar saving overriden -#'])
    end
end
if doSubSampling == 1 && doPostHocSubSampling == 1
    ['## Alert: More than one subsampling system activated ##']
    crash = yes
    %This is not actually an intrinsically bad thing, but outside of specific cases, it is likely that attempting to apply doSubSampling (true subsampling) and doPostHocSubSampling (post-hoc subsampling) simultaneously will cause issues
end
%['Reenable spectral plots']
%#################

jittPSDNormIndex = [{'(Not normalised)'},{'(Per-fly, per-jitter max normalised)'},{'(Per-fly, across-jitter max normalised)'}];

%Clean up chan index
chansOfInterestStr = [];
for chanInd = 1:size(chansOfInterest,2)
    chansOfInterestStr{chanInd} = strrep(chansOfInterest{chanInd},'-','minus');
    chansOfInterestStr{chanInd} = strrep(chansOfInterestStr{chanInd},'+','plus');
end

%----------------------------------------

%Old location of experiment/dataset specification
    %As of Mk 9 these parameters are now specified in the specialEvals
%{
expName = 'Stitched' %This describes the general paradigm, not specific sub-experiments, like OddballVarying or OddCarrier etc
%expName = 'Overnight'

if useAutoList ~= 1
    %########
    dataset = '210422'
    %dataset = '150721'
    %flies = dir([rawPath filesep '020621*']); %10 06 20 B2 Phasic
    flies = dir([procPath filesep dataset '*' ]); %10 06 20 B2 Phasic
    flyNum = 1;
    blockNum = 1; 
    customSaveComment = []
    %########
    flies(1).blockNum = blockNum;
    flies(1).flyNum = flyNum;
else
    %########
    listToUse = '33 33 33 greenblue bluegreen' %Specifies a CSV list which will indicate what datasets to load
    customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
    %########
end
%}
integMode = integMode; %Whether to import behavioural data and integrate it with the LFP data
    %(Specification shifted to specialEvals)
if integMode == 1
    %behavIntegFolder = 'D:\group_swinderen\Matthew\TDTs\SleepData\IntegOut'
    %dataset = '150721'
    if networkMode == 1
        behavIntegFolder = 'I:\PHDMVDP002-Q1471\LFP\SleepData\IntegOut'
    else
        %behavIntegFolder = 'D:\group_vanswinderen\Matt\SleepData\IntegOut'
        %behavIntegFolder = 'C:\Users\flylab\Desktop\Matt\LFP\SleepData\IntegOut'
        behavIntegFolder = '..\SleepData\IntegOut'
    end
end

%----------------------------------------


%############
%chansOfInterest = [1]; %What channels to look at specifically (Can be changed post-hoc) (Old)
%chansOfInterest = [{'polReversalChan - 8'},{'polReversalChan - 3'},{'polReversalChan + 3'}]; %New string based system; Chans can be string (e.g. '1') or expression (e.g. 'polReversalChan-2')
%targsOfInterest = [1,3,5,7]; %Which targets to plot (33 33 33 bluegreen greenblue)
%targsOfInterest = [1,2,3,14,15]; %Which targets to plot (33 33 33 bluegreen greenblue)
%%targsOfInterest = [1,2]; %Which targets to plot 
%targsOfInterest = [1,2]; %(33Hz sparsening)
%tackTargsOfInterest = [8]; %Targets for the tack-on linear ERP plot
tackLite = 1; %Whether to suppress the text in the tackTarg plot (1) or not (0) [Only has an effect if tackTargs not empty]
%############
%mmnTargets = [1,3 ; 5,7]; %"Subtract the first of each row from the second of each row (33 33 33 bluegreen greenblue)
%mmnTargets = [1,3 ; 2,4]; %Arranged in pairs, separated by rows (33 33 33 precede)
%mmnTargets = [1,2]; %(33Hz sparsening)
%mmnTargets = [2,6; 3,7]; %(Overnight simple)
%mmnTargets = [27,29 ; 27,31; 29,31]; %Overnight sleep splits
%{
mmnTargets = [9,11; 10,12; 3,7; 4,8; ...
    21,16; 22,15; 25,14; 26,13;...
    ];
%}
%############
%permCompGroups = [1,3; 5,7];  %Similar to mmnGroups; Defines what hyperGroups to compare with permutation analysis (33 33 33 bluegreen greenblue)
%permCompGroups = [2,12 ; 4,12 ; 10,12 ; 4,13 ];%; 3,16 ; 4,17]; %; 5,6 ; 7,8 ; 5,7 ; 6,8]; (33 33 33 precede)
%permCompGroups = [1,2]; %(33Hz sparsening)
%permCompGroups = [2,6;3,7];
%permCompGroups = [2,6; 3,7; 1,9; 2,10; 5,11; 6,12];
%permCompGroups = [2,6; 3,7; 1,9; 2,10; 5,11; 6,12];
%{
permCompGroups = [9,11; 10,12; 3,7; 4,8; ...
    20,16; 22,15; 25,14; 26,13;...
    ];
    %Row 1 - Easing in (Blue and green carriers and oddballs for sleep vs wake, across whole time)
    %Row 2 - Oddballs vs Carriers (Blue and green, across 1st half)
 %}
%{
permCompGroups = [...
    1,2 ; 1,4 ; 1,8; 1,13 ; ...
    2,2 ; 2,4 ; 2,8 ; 2,13 ; ...
    4,4 ; 4,4 ; 4,8 ; 4,13 ; ...
    8,8 ; 8,8 ; 8,8 ; 8,13];
%}
%{
permCompGroups = [22,24; 22,26; 24,26; ...
    27,29 ; 27,31; 29,31; ...
    22,27; 24,29; 26,31 ; ...
    27,43; 29,43; 31,43];
%}
%Modified Portugal
%{
permCompGroups = [...
    13,15 ; 14,16 ; 20,18 ; 19,17 ; ...
    13,20; 15,18 ; 14,19 ; 16,17 ; ...
    38,22; 38,24 ; 38,26 ; 38,42 ; ...
    39,27; 39,29 ; 39,31 ; 39,43 ...
    ];
%}
%############
%QA
if size(unique([ size(groupTargets,2) , size(groupJitters,2) , size(groupSpecialEval,2) , size(groupDescriptors,2) ]),2) ~= 1 ||...
        nanmax([ targsOfInterest , tackTargsOfInterest ]) > size(groupSpecialEval,2) || ...
        nanmax(nanmax([ mmnTargets ; permCompGroups ])) > size(groupSpecialEval,2) %Note different indexing for third line
    ['## Alert: Error in correct group targeting ##']
    crash = yes
end
%QA for integMode
for i = 1:size( groupSpecialEval ,2 )
    if isempty( strfind( groupSpecialEval{i} , 'behavInterp' ) ) ~= 1 && integMode ~= 1
        ['## Alert: Eval requesting behavInterp information specified but integMode not active ##']
        %crash = yes
    end
end
%Report on perm groups (if applicable)
if doPerm == 1 && reportPerm == 1
    disp(['----------------------------------'])
    disp(['Permutation groupings:'])
    for permInd = 1:size( permCompGroups,1 )
        for permSubInd = 1:size(permCompGroups,2)
            disp([groupDescriptors{ permCompGroups(permInd,permSubInd) }])
            if permSubInd ~= size(permCompGroups,2)
                disp(['vs'])
            end
        end
        disp(['------'])
    end
    disp(['----------------------------------'])
end

targsOfInterestOriginal = targsOfInterest; %Will be used for QA on certain plots where targsOfInterest cannot be modified after runtime

%QA for carrieronly synchronisation
if exist('doCarrieronlyPhotSynchronisation') ~= 1
    ['-# Caution: doCarrieronlyPhotSynchronisation not specified; Defaulting to disabled #-']
    doCarrieronlyPhotSynchronisation = 0;
end

%QA for newer specifiers 
if ~exist('boxPlotMode')
    boxPlotMode = 0;
    disp(['(boxPlotMode not specified; Defaulting to 0)'])
end
if ~exist('grandAvERPSubplotMode')
    grandAvERPSubplotMode = 0;
    disp(['(grandAvERPSubplotMode not specified; Defaulting to 0)'])
end

%Default behaviour for memory efficiency
if ~exist('memoryEfficient')
    memoryEfficient = 1; %Default to no
end

%QA to check hyperGroup identifier numbers
for groupID = 1:size(groupDescriptors,2)
    thisHyperGroupID = str2num( groupDescriptors{groupID}(1:2) );
    if ~isempty( thisHyperGroupID ) && thisHyperGroupID ~= groupID
        disp(['## Alert: hyperGroup #',num2str(groupID),' ID may not match description ##'])
        disp(groupDescriptors{groupID})
        crash = yes
    end
end

%----------------------------------------

%expName = 'Stitched' %This describes the general paradigm, not specific sub-experiments, like OddballVarying or OddCarrier etc
%expName = 'Overnight'
    %Note: As of Mk 9 these are specified in the special evals

if useAutoList ~= 1
    %########
    %dataset = '210422'
    flies = dir([procPath filesep dataset '*' ]); %10 06 20 B2 Phasic
    %flyNum = 1;
    %blockNum = 1; 
    customSaveComment = []
    %########
    flies(1).blockNum = blockNum;
    flies(1).flyNum = flyNum;
%{
else
    %########
    listToUse = '33 33 33 greenblue bluegreen' %Specifies a CSV list which will indicate what datasets to load
    customSaveComment = [''] %String to append to save filename to allow instances of the same data being processed with different specialEvals etc
    %########
%}
end

if automatedSavePlots == 1 && useAutoList == 1
    %autoFigPath = [listPath,filesep,listToUse,'_Figs'];
    autoFigPath = [listPath,filesep,listToUse,additionalFigParams,'_Figs'] %Add in figParams
    if isempty(dir(autoFigPath))  == 1
        mkdir(autoFigPath)
        disp(['-- Figure folder generated --'])
    end
    vectorAutoFigPath = [autoFigPath, filesep, 'Vec'];
    if isempty(dir(vectorAutoFigPath))  == 1
        mkdir(vectorAutoFigPath)
        disp(['-- Vector figure folder generated --'])
    end
elseif automatedSavePlots == 1 && useAutoList ~= 1
    %autoFigPath = 'D:\group_swinderen\Matthew\TDTs\Figures\AUTO';
    %autoFigPath = 'D:\group_vanswinderen\Matt\Figures\AUTO'
    %autoFigPath = 'C:\Users\flylab\Desktop\Matt\LFP\Figures\AUTO'
    autoFigPath = '..\Figures\AUTO'
end

%----------------------------------------

%(Mostly) Static params
chanCodecIndex = [ 10 , 11 , 0 ]; %:Blue, Green, Blank
chanCodecContents = [{'blue'},{'green'},{'blank'}];
    %"A Certain Channel Index"
jittDescriptors = [{'Carrieronly'},{'Phasic'},{'Random uniform'},{'Jittering'},{'Sparsening'}]; %Used to match block jittering states with the name identity of said states
groupColours = jet(size(groupTargets,2));
%groupColours = winter(size(groupTargets,2));
chanColours = jet(size(chansOfInterest,2));
correctedIndex = [{'Uncorrected'},{'Corrected'}];
currentDateTime = datetime('now'); %Mostly useful when looking at flagParamSaveStruct post-hoc
alphaValue = 0.05; %Used in stats calculations
%----------------------------------------

overVar = struct; %Will hold fly-by-fly data
if memoryEfficient ~= 1
    overSplice = struct; %Similar, but for SplicedData and SplicedStim (Will be very big if multiple flies analysed)
end

%Find flies, if auto
if useAutoList == 1
    %findList = dir([rawPath,filesep,listToUse,'.csv']); %Look for list, not caring about rerefMode yet
    findList = dir([listPath,filesep,listToUse,'.csv']); %Look for list, not caring about rerefMode yet
    %QA for overfind
    if size(findList,1) > 1 | size(findList,1) ==0
        ['## Alert: Critical error in finding data list to use ##']
        crash = yes
    end
    dataList = load([findList(1).folder,filesep,findList(1).name]) %Loads the aforementioned list
    dataListStruct = struct;
    dataListStruct.flyName = num2str(dataList(:,1));
    dataListStruct.flyNum = dataList(:,2);
    dataListStruct.blockNum = dataList(:,3);
    %QA in case of proximal 0 removal from CSV
    if size(dataListStruct.flyName,2) == 5 %Sub-case for situation where all datasets are lacking 0
        %Note: This effectively locks the data into alwas being DDMMYY
        dataListStruct.flyName(:,1:6) = [repmat('0',size(dataListStruct.flyName,1),1),dataListStruct.flyName(:,1:5)];
        disp(['#- All datasets have common name length of 5 (presumably due to CSV proximal 0 omission) -#'])
    end
    proximalZeroesFixed = 0;
    for i = 1:size(dataListStruct.flyName,1)
        if isempty(strfind(dataListStruct.flyName(i,:),' ')) ~= 1 
            dataListStruct.flyName(i,:) = strrep( dataListStruct.flyName(i,:) , ' ', '0' );
            proximalZeroesFixed = proximalZeroesFixed + 1;
        end
    end
    if proximalZeroesFixed > 0
        disp(['#- ',num2str(proximalZeroesFixed),' proximal zeroes had to be added to fly names -#'])
    end
    %Assemble flies
    flyList = []; %Will be cell array eventually
    flies = struct;
    for i = 1:size(dataListStruct.flyName,1)
        %thisFlyName = [];
        %thisFlyName = [thisFlyName,num2str(dataList(i,1))]; %Note: Critical assumption of fly folder naming structure only ever containing numbers
        %flies(i).name = thisFlyName;
        flies(i).name = dataListStruct.flyName(i,:);
        flies(i).blockNum = dataList(i,3); %May be incompatible with native structure of flies struct
        flies(i).flyNum = dataList(i,2); %Will be detected and used later on if not 1
        flyList{i,1} = [dataListStruct.flyName(i,:),'-',num2str(dataListStruct.flyNum(i,:))];
    end
    uniqueFlies = unique(flyList) %Finds occurences of a date and fly number
    
    %Calculate each fly unique name
    for i = 1:size(flies,2)
        thisFliesName = strcat( [ flies(i).name , '-' , num2str(flies(i).flyNum) ] );
        hits = 0;
        for un = 1:size(uniqueFlies,1)
            if isempty(strfind(uniqueFlies{un},thisFliesName)) ~= 1
                thisFlyUniqueNumber = un;
                hits = hits + 1;
            end
        end
        if hits == 1
            overVar(i).flyUniqueNumber = thisFlyUniqueNumber;
            flies(i).flyUniqueNumber = thisFlyUniqueNumber;
        else
            ['## Warning: Critical uniqueFlies under or overfind ##']
            crash = yes
        end
    end
    %And order, if multiple datasets from one fly
    flyBlockOrders = repmat( {[NaN,NaN]} , size(uniqueFlies,1) , 1 );
    flyBlockOrderList = []; %Ditto, but a continuous list
    for i = 1:size(flies,2)
        flyBlockOrders{flies(i).flyUniqueNumber} = [flyBlockOrders{flies(i).flyUniqueNumber} ; flies(i).blockNum , i]; %Col 1 - Original block numbers
        flyBlockOrders{flies(i).flyUniqueNumber}( isnan(flyBlockOrders{flies(i).flyUniqueNumber}) == 1 ) = []; %Col 2 - Dataset number
    end
    for i = 1:size(flyBlockOrders,1)
        [~,flyBlockOrders{i}(:,3)] = sort(flyBlockOrders{i}(:,1)); %Col 3 - Block order within unique fly
        for subFly = 1:size(flyBlockOrders{i},1)
            flies( flyBlockOrders{i}(subFly,2) ).withinFlyBlockOrder = flyBlockOrders{i}(subFly,3); %Append block order information to flies
        end
        flyBlockOrderList = [ flyBlockOrderList ; flyBlockOrders{i} ];
    end
        %Note: This system not tested against misordered autoLists or other weird cases
            %Or non-paired data for that matter...
end

%QA
if length(flies) == 0 || isempty([flies.name]) == 1
    ['## No flies detected! ##']
    return
end
if useAutoList == 1 && normaliseERPs == 3 && ( isempty(strfind(listToUse,'green')) == 1 && isempty(strfind(listToUse,'blue')) == 1)
    ['## Alert: Colour normalisation selected but data list does not appear to related to coloured data ##']
    crash = yes %May be overkill if wishing to use colour normalisation on greenblank data
end
if exist('isDeadList') == 1
    if useAutoList == 1 && isequal(isDeadList,listToUse) ~= 1
        ['## Alert: isDeadList (',isDeadList,') and autoList (',listToUse,') do not match ##']
        crash = yes
    end
    if useAutoList == 1 && size(isDeadVals,2) ~= length(flies)
        ['## Alert: isDeadVals size (',num2str(size(isDeadVals,2)),') and autoList size (',num2str(length(flies)),') do not match ##']
        crash = yes
    end
end
if size( strfind( cell2mat(groupSpecialEval) , 'isDeadVals' ) , 2) > 0 && exist('isDeadVals') ~= 1
    ['## Alert: isDeadVals requested in special evals, but not specified ##']
    crash = yes
end

%Save useful flags/params to struct
flagParamSaveList = who;
flagParamSaveStruct = struct;
for i = 1:size(flagParamSaveList,1)
    eval(['flagParamSaveStruct.',flagParamSaveList{i},' = ', flagParamSaveList{i},';'])
end
flagParamSaveList = [flagParamSaveList; 'flagParamSaveStruct'; 'flagParamSaveList'; 'IIDN' ; 'shortcutSuccess'];

%##########
shortcutSuccess = 0; %Set outside of loop to help with saveOverVar unambiguity
if useAlreadyAnalysed == 1 %Attempt to shortcut processing by loading overVar, with checks to ensure validity of data
    disp('-- Attempting to load saved data and comparing with current settings --')
    if useAutoList == 1
        %loadName = [overVarPath, filesep, listToUse, '.mat'] %Old, without reref
        %loadName = [overVarPath, filesep, listToUse, '_', rerefIndex{rerefMode}, '.mat'] %New, with reref
        loadName = [overVarPath, filesep, listToUse, '_', rerefIndex{rerefMode}, customSaveComment, '.mat'] %Newer, with custom comment
    else
        %loadName = [overVarPath, filesep, validAndApplicableMATs{1}, '.mat'] %NEED TO CHECK; Old
        %loadName = [overVarPath, filesep, validAndApplicableMATs{1}, '_', rerefIndex{rerefMode}, '.mat'] %NEED TO CHECK; New
        loadName = [overVarPath, filesep, validAndApplicableMATs{1}, '_', rerefIndex{rerefMode}, customSaveComment, '.mat'] %NEED TO CHECK; Newer
    end 
    try
       %shortLoad = load(loadName); %Load overVar and flagParamSaveStruct
       %shortLoad = load(loadName,'flagParamSaveStruct'); %Load flagParamSaveStruct
       %------------------
       %Generalised armoured loader
       proceed = 0;
       while proceed ~= 1 && proceed > -10 
           try
               shortLoad = load(loadName,'flagParamSaveStruct'); %Load flagParamSaveStruct
               proceed = 1;
           catch ME
               switch ME.identifier
                   case 'MATLAB:load:cantReadFile'
                       ['-# Caution: Failure to load file; Will retry (Att. ',num2str(abs(proceed)),') #-']
                       proceed = proceed - 1;
                       pause(10)
                   otherwise
                       rethrow(ME)
                       ['## Alert: Irrecoverable flagParamSaveStruct data load failure ##']
                       crash = yes
               end
           end
       end
       %QA for success
       if proceed == 0
           ['## Failure to load flagParamSaveStruct data ##']
           crash = yes
       end
       %------------------
       %Remove excluded fields from loaded copy of flagParamSaveStruct
       for i = 1:size(excludeList,2)
           try
               shortLoad.flagParamSaveStruct = rmfield(shortLoad.flagParamSaveStruct,excludeList{i});
           catch
               disp(['# Could not remove field ',excludeList{i},' from shortLoad.flagParamSaveStruct #'])            
           end
       end
       %Copy flagParamSaveStruct and remove certain fields
       flagParamSaveStructCopy = flagParamSaveStruct;
       for i = 1:size(excludeList,2)
           try
               if isfield(flagParamSaveStructCopy,excludeList{i}) == 1
                   flagParamSaveStructCopy = rmfield(flagParamSaveStructCopy,excludeList{i});
               end
           catch
               ['# Could not remove field ',excludeList{i},' from flagParamSaveStructCopy #']            
           end
       end
       %Compare shortLoad and copy
       comparison = isequal(flagParamSaveStructCopy,shortLoad.flagParamSaveStruct);
       if comparison == 1
           disp('-- Saved flagParamSaveStruct and current flagParamSaveStruct are identical; Proceeding with saved data --')
           shortcutSuccess = 1;
       else
           ['# Disparity between saved flagParamSaveStruct and current flagParamSaveStruct; Not using saved data #']
           shortcutSuccess = 0;
           disp(['- Halting as requested, to allow for comparison -'])
           currentFields = fieldnames(flagParamSaveStructCopy);
           for i = 1:size(currentFields,1)
               if isfield(shortLoad.flagParamSaveStruct, currentFields(i)) ~= 1
                   disp(['# Field ',currentFields{i},' does not exist in saved data #'])
               elseif isfield(shortLoad.flagParamSaveStruct, currentFields(i)) == 1 && isequal( shortLoad.flagParamSaveStruct.(currentFields{i}), flagParamSaveStructCopy.(currentFields{i})) ~= 1
                   try
                       disp(['# Field ',currentFields{i},' is different between saved data and current data (',num2str(shortLoad.flagParamSaveStruct.(currentFields{i})),' vs ',num2str(flagParamSaveStructCopy.(currentFields{i})),') #'])
                   catch
                       disp(['# Field ',currentFields{i},' is different between saved data and current data #'])
                   end
               end
           end
           if haltOnDifference == 1
               return
           end
       end
       
    catch
       ['## Warning: Failure to shortLoad ##']
       shortcutSuccess == 0;
       crash = yes
    end
    %Override flies variable if shortcut to be used
    if shortcutSuccess == 1
        %preLoad = load(loadName,'overVar');
        %------------------
        %Generalised armoured loader
        proceed = 0;
        while proceed ~= 1 && proceed > -10 
           try
               preLoad = load(loadName,'overVar');
               proceed = 1;
           catch ME
               switch ME.identifier
                   case 'MATLAB:load:cantReadFile'
                       ['-# Caution: Failure to load file; Will retry (Att. ',num2str(abs(proceed)),') #-']
                       proceed = proceed - 1;
                       pause(10)
                   otherwise
                       rethrow(ME)
                       ['## Alert: Irrecoverable overVar data load failure ##']
                       crash = yes
               end
           end
        end
        %QA for success
        if proceed == 0
           ['## Failure to load overVar data ##']
           crash = yes
        end
        %------------------
        overVar = preLoad.overVar;
        clear('shortLoad','preLoad') %Save memory
        %flies = []; %This was originally in place to make it easy for the following loop not to execute, but it is lazy
    end
end
%##########

if useAutoList == 1
    %%flyColours = parula(size(uniqueFlies,1));
    flyColours = parula(size(flies,2));
end

%Begin analysis
if shortcutSuccess ~= 1
    for IIDN = 1:size(flies,2) %If shortcutSuccess procced, this will be size 0 and thus skipped
        disp(['--------------------------------------------------------------------------------------------------------------------------'])
        if size(flies,2) > 1
            disp(['-- Analysing dataset ',num2str(IIDN),' of ',num2str(size(flies,2)),' --'])
            disp([flies(IIDN).name,' - F',num2str(flies(IIDN).flyNum),' - B',num2str(flies(IIDN).blockNum)])
        end

        %clear FolderName
        clearvars('-except', flagParamSaveList{:})
        FolderName = [procPath filesep flies(IIDN).name];
        %{
        if useStitched ~= 1
            %detMATFolders = dir([rawPath,filesep,flies(IIDN).name]);
            detMATFolders = dir([procPath,filesep,flies(IIDN).name]);
            searchStr = flies(IIDN).name;
        else
            detMATFolders = dir([FolderName,filesep,'LFP']);
            searchStr = 'Stitched';
        end
        %}
        detMATFolders = dir([FolderName,filesep,'LFP']);
        %QA
        if size(detMATFolders,1) == 0
            ['## Caution: No valid data folders detected ##']
            crash = yes
        end
        searchStr = expName;
        %blockStr = ['Block-',num2str(blockNum)];
        blockStr = ['Block-',num2str( flies(IIDN).blockNum )];

        validMATFolders = [];
        a = 1;
        for i = 1:size(detMATFolders,1)
            %Mat files
            if isempty(strfind(detMATFolders(i).name, 'Calib')) == 1 &&...
                    isempty(strfind(detMATFolders(i).name, searchStr)) ~= 1 
                validMATFolders{a} = detMATFolders(i).name;
                a = a + 1;
            end
        end
        
        disp(['-- ', num2str(a-1), ' potential dataset/s detected for ',flies(IIDN).name, ' --'])

        %Remove hits from datasets that lack the requisite experiment
        validAndApplicableMATs = [];
        customStr = []; %Will be used for any special finding conditions (like fly number)
        if flies(IIDN).flyNum ~= 1
            customStr = ['Fly',num2str(flies(IIDN).flyNum)];
        end
        a = 1;
        for i = size(validMATFolders,2):-1:1 %Note reverse iteration
            if size(customStr,2) > 0 
                if isempty( strfind(validMATFolders{i}, expName) ) ~= 1 && isempty( strfind(validMATFolders{i}, customStr) ) ~= 1 %E.g. "130720_OddballFly2"
                    validAndApplicableMATs{a} = validMATFolders{i};
                    a = a + 1;
                end
            else
                if isempty( strfind(validMATFolders{i}, expName) ) ~= 1 && ( isempty( strfind(validMATFolders{i}, blockStr) ) ~= 1 && strfind(validMATFolders{i}, blockStr) == (size( validMATFolders{i} , 2 ) - size(blockStr,2) + 1) ) %&& strfind(validMATFolders{i}, expName) == (size(validMATFolders{i},2) - size(expName,2) + 1) %E.g. "130720_Oddball"
                        %Note: The commented out second half of this checks to see if the experiment is terminal in the name, which will fail if the naming format changes to specify fly number unambiguously for every file
                        %Secondary note: With the addition of Block number checking this will start to fail for stitched data if the blockNum is not accounted for
                    validAndApplicableMATs{a} = validMATFolders{i};
                    a = a + 1;
                end
            end
                %A little ugly, but this is to allow for empty customStr
        end
        %Reverse iterate through list and remove hits that have 'Fly' in name that do not correspond to the requested fly number
        for a = size(validAndApplicableMATs,2):-1:1
            if isempty(strfind(validAndApplicableMATs{a},'Fly')) ~= 1 & str2num(validAndApplicableMATs{a}( strfind(validAndApplicableMATs{a},'Fly') + 3 )) ~= flies(IIDN).flyNum %Might crash if postceding character cannot be parsed to number
                disp(['#- Dataset ',validAndApplicableMATs{a},' determined to be applying to different fly and thus excluded -#'])
                validAndApplicableMATs(a) = [];
            end
        end
        %Reverse iterate through list and remove hits that have 'Block' in name that do not correspond to the requested block number
        for a = size(validAndApplicableMATs,2):-1:1
            if isempty(strfind(validAndApplicableMATs{a},'Block')) ~= 1 & str2num(validAndApplicableMATs{a}( strfind(validAndApplicableMATs{a},'Block') + 6 )) ~= flies(IIDN).blockNum %Might crash if postceding character cannot be parsed to number
                disp(['#- Dataset ',validAndApplicableMATs{a},' determined to be applying to different block and thus excluded -#'])
                validAndApplicableMATs(a) = [];
            end
        end
        %QA/reporting
        if size(validAndApplicableMATs,2) > 1
            ['# More than one applicable stimulus dataset detected #']
            crash = yes
        elseif size(validAndApplicableMATs,2) == 0
            ['## Alert: No applicable stimulus data detected ##']
            disp(['(Are you sure that data of type "',searchStr,'" exists in folder?)'])
            crash = yes
        end
        
        disp(['-- Using dataset ',validAndApplicableMATs{1},' (Block ',num2str(flies(IIDN).blockNum),') --'])
            %Note: This is just an overfolder; blockNum will determine which block of this dataset will be analysed

        %#######################
        %Find MAT files
                
        %New
        if useStitched ~= 1
            basePath = [FolderName,filesep,'LFP' filesep 'MAT' ];  
        else
            basePath = [FolderName,filesep,'LFP' filesep validAndApplicableMATs{1} ];    
        end
               
        %foundMATFiles = dir(fullfile(basePath, ['**\*B',num2str(flies(IIDN).blockNum),'.mat'])); %Recursively iterate under data location to find stimulus MATs
            %Based on https://www.mathworks.com/matlabcentral/answers/429891-how-to-recursively-go-through-all-directories-and-sub-directories-and-process-files
        foundMATFiles = dir(fullfile(basePath, ['**\*B*.mat']));
        %%['## Caution: FoundMATFiles in overgeneralisation state ##']
        %%foundMATFiles = dir(fullfile(basePath, ['**\*B',num2str(matBlockNum),'.mat']));
        %QA
        if size(foundMATFiles,1) == 0 %%|| size(foundMATFiles,1) > 1 
            ['## Critical failure in stimulus MAT file finding ##'] 
            %crash = yes
        end
        if size(foundMATFiles,1) > 1
            disp(['-# Caution: More than one (',num2str(size(foundMATFiles,1)),') potential MAT files found #-'])
            proceed = 0;
            if overnightMode == 0 %Direct assumptions of MAT data block number from LFP block number only really valid with non stitched data
                if isempty( dir(fullfile(basePath, ['**\*B*',num2str(flies(IIDN).blockNum),'.mat'])) ) ~= 1
                    %foundMATFiles = dir(fullfile(basePath, ['**\*B',num2str(flies(IIDN).blockNum),'.mat'])); %Old
                    foundMATFiles = dir(fullfile(basePath, ['**\*B*',num2str(flies(IIDN).blockNum),'.mat'])); %New
                        %The old system relied on single-digit block numbers for MAT struct files
                        %The new one instead relies on the block number being terminal
                    %QA
                    if size(foundMATFiles,1) > 1
                        disp(['-# More than one (',num2str(size(foundMATFiles,1)),') MAT file matching blockNum (#',num2str(flies(IIDN).blockNum),') found #-'])
                        proceed = 0;
                    else
                        disp(['-- Using ',foundMATFiles(1).name,' --'])
                        proceed = 1;
                    end
                end
            end
            if proceed == 0
                %Retrieve data date modified
                %temp = dir([FolderName,filesep,'LFP',filesep,validAndApplicableMATs{1}]);
                temp = dir([ FolderName,filesep,'LFP',filesep,validAndApplicableMATs{1},filesep,'*chunk*.mat' ]);
                temp( [temp.isdir] == 1 ) = []; %Eliminate folders (Now in a single line!)
                if size( temp,1 ) > 1
                    ['-# More than one data MAT file found in folder; Cannot QA for saveStruct #-']
                    crash = yes
                end
                %d = posixtime( datetime([temp(1).datenum],'ConvertFrom','datenum') );
                    %This does not work, as it will find the time that the LFP data was preprocesed, not the original data time

                disp(['Loading ', temp.name,' for epoch comparison'])
                %temp = load( [temp.folder,filesep,temp.name] );
                %------------------
                %Generalised armoured loader
                proceed = 0;
                while proceed ~= 1 && proceed > -10 
                   try
                       temp = load( [temp.folder,filesep,temp.name] );
                       proceed = 1;
                   catch ME
                       switch ME.identifier
                           case 'MATLAB:load:cantReadFile'
                               ['-# Caution: Failure to load file; Will retry (Att. ',num2str(abs(proceed)),') #-']
                               proceed = proceed - 1;
                               pause(10)
                           otherwise
                               rethrow(ME)
                               ['## Alert: Irrecoverable LFP data load failure ##']
                               crash = yes
                       end
                   end
                end
                %QA for success
                if proceed == 0
                   ['## Failure to load LFP data ##']
                   crash = yes
                end
                %------------------
                if overnightMode == 1 && useStitched == 1
                    s = temp.stitchEEG.Stitch.setnames;
                    s = s{1}(end); %Derive block number of first element in stitch
                    foundMATFiles = dir(fullfile(basePath, ['**\*B',num2str(s),'*.mat'])); %Overwrite with better information
                    %QA
                    if size(foundMATFiles,1) == 0 || size(foundMATFiles,1) > 1
                        ['## Continued errors in MAT file finding ##']
                        crash = yes
                    end
                else
                    d = temp.EEG.epoch_end;
                    %Identify most likely MAT file
                        %This works on the assumption that the valid saveStruct will be the next one after the data file's date modified, which may not always be true
                    %temp2 = [];
                    %for vd = 1:size( foundMATFiles,1 )
                    %    temp2(vd) = posixtime( datetime(foundMATFiles(vd).datenum,'ConvertFrom','datenum') );
                    %end
                    if ~exist('timeFindMode')
                        timeFindMode = 1; %Not a param
                    end
                    proceed = 0;
                    while proceed == 0
                        if timeFindMode == 1
                            disp('(DateModified mode)')
                            temp2 = posixtime( datetime([foundMATFiles.datenum],'ConvertFrom','datenum') );
                        else
                            disp('(FilenameInterpretation mode)')
                            %temp2 = posixtime( datetime([foundMATFiles.datenum],'ConvertFrom','datenum') );
                            nameList = [];
                            idList = [];
                            for subFin = 1:size(foundMATFiles,1)
                                if ~isempty( strfind(foundMATFiles(subFin).name, '_saveStruct') )
                                    thisName = foundMATFiles(subFin).name( 1:strfind(foundMATFiles(subFin).name, '_saveStruct')-1 );
                                    thisName = strrep( thisName, 'T', '' );
                                    nameList = [nameList; thisName ]; %Will crash if differing numbers of characters
                                    idList = [idList;subFin]; %This is in case files are skipped cos missing "_saveStruct"
                                end
                            end
                            temp2 = posixtime( datetime([nameList],'Format','yyyyMMddHHmmss') );
                        end
                        temp2 = datetime(temp2 , 'ConvertFrom', 'posixtime');
                        temp2.TimeZone = '+10:00';
                        temp2 = posixtime(temp2);
                        [matDist,bestMAT] = nanmin( abs( temp2 - d ) );
                        if timeFindMode == 1
                            bestMATActual = bestMAT;
                        else
                            bestMATActual = idList(bestMAT);
                        end
                        if matDist > 300
                            ['## No MAT within 5 min ##'] %Might be too stringent but currently unsure
                            %crash = yes
                            if timeFindMode == 1
                                disp(['(Attempting alternate system)'])
                                timeFindMode = timeFindMode + 1;
                            else
                                ['All current modes have failed']
                                crash = yes
                            end
                        else
                            proceed = 1;
                        end
                    end
                    disp(['Best time match ',num2str(matDist),'s from MAT ',foundMATFiles(bestMATActual).name])
                    foundMATFiles = foundMATFiles(bestMATActual);
                end
                clear temp  
            end
        end
        
        matFolderName = foundMATFiles(1).folder;
                
        %#######################
        
        matStruct = struct;
        matStruct.carrierOrderBlock = [];
        useSaveStructActive = useSaveStruct; %An editable copy of useSaveStruct
        proceed = 0;
        MATHas = zeros(1,size(MATNeeds,2)); %List of the needed fields that saveStruct actually has

        while proceed == 0
            proceed = 1; %Will only be overwritten if error occurs
            if useSaveStructActive == 1

                %Search specifically for saveStruct
                %saveStructFiles = dir([matFolderName filesep '*saveStruct*' '_*' expName '*_' '*.mat']); %Catches only saveStruct files that match expName
                %saveStructFiles = dir([matFolderName filesep '*saveStruct*.mat']); %Catches any saveStruct files (Used until 15/7/21)
                %saveStructFiles = dir([matFolderName filesep '*saveStruct*B',num2str(blockNum),'.mat']); %Catches saveStruct files matching the block number (Note the no wildcard preceding the .MAT, so as to cut down on ambiguities)
                %saveStructFiles = dir([matFolderName filesep '*saveStruct*B',num2str( flies(IIDN).blockNum ),'.mat']); %Catches saveStruct files matching the block number (Note the no wildcard preceding the .MAT, so as to cut down on ambiguities)
                saveStructFiles = foundMATFiles(1); %Switch to using curated foundMATFiles now that Mk 9 has checks for overfind
                    %Note: Functionality to support multiple blocks' worth of saveStruct may have been lost, but that functionality is potentially deprecated
                if isempty(saveStructFiles) == 1
                    ['# No saveStruct files detected #']
                    crash = yes
                else
                    overSaveStruct = struct;
                    for saveFileNum = 1:size(saveStructFiles,1)
                        %Load and assign
                        %load( [matFolderName filesep saveStructFiles(saveFileNum).name] );
                        %------------------
                        %Generalised armoured loader
                        proceed = 0;
                        while proceed ~= 1 && proceed > -10 
                            try
                                load( [matFolderName filesep saveStructFiles(saveFileNum).name] );
                                proceed = 1;
                            catch ME
                                switch ME.identifier
                                    case 'MATLAB:load:cantReadFile'
                                        ['-# Caution: Failure to load file; Will retry (Att. ',num2str(abs(proceed)),') #-']
                                        proceed = proceed - 1;
                                        pause(10)
                                    otherwise
                                        rethrow(ME)
                                        ['## Alert: Irrecoverable MAT data load failure ##']
                                        crash = yes
                                end
                            end
                        end
                        %QA for success
                        if proceed == 0
                            ['## Failure to load MAT data ##']
                            crash = yes
                        end
                        %------------------
                        %overSaveStruct.saveStruct(saveFileNum) = saveStruct;
                        %Determine CarrierFirst through a number of redundant methods
                        if isfield(saveStruct,'CarrierFirst') == 1
                            %overSaveStruct.saveStruct(saveFileNum).carrOdd = saveStruct.CarrierFirst;
                            saveStruct.carrOdd = saveStruct.CarrierFirst;
                        elseif isempty(strfind(saveStructFiles(saveFileNum).name, 'carrOdd')) ~= 1
                            carrOddStrPos = strfind(saveStructFiles(saveFileNum).name, 'carrOdd') + size('carrOdd',2);
                            %overSaveStruct.saveStruct(saveFileNum).carrOdd = str2num(saveStructFiles(saveFileNum).name(carrOddStrPos)); %Will fail if hardcoded indexing format is wrong
                            saveStruct.carrOdd = str2num(saveStructFiles(saveFileNum).name(carrOddStrPos)); %Will fail if hardcoded indexing format is wrong
                        else
                            ['# Warning: Could not identify CarrierFirst/carrOdd from contents or filename #']
                            %overSaveStruct.saveStruct(saveFileNum).carrOdd = NaN;
                            saveStruct.carrOdd = NaN;
                        end
                        overSaveStruct.saveStruct(saveFileNum) = saveStruct;
                        clear saveStruct;
                    end
                end

                %Assemble matStruct
                %matStruct = struct;
                for i = 1:size(overSaveStruct.saveStruct,2) %Note: Correct dimensionality untested
                    presentVars = fieldnames(overSaveStruct.saveStruct(i));
                    for x = 1:size(presentVars,1)
                        thisMATVarName = presentVars{x};
                        if isempty(strfind(thisMATVarName,'CarrierOrder')) == 1 | ( isempty(strfind(thisMATVarName,'CarrierOrder')) ~= 1 & isfield(matStruct, 'CarrierOrder') ~= 1 )
                            if isfield(matStruct, thisMATVarName) ~= 1
                                %preLoad = load( [backupMatFolderName filesep foundMATFiles(i).name] , thisMATVarName);
                                matStruct.(thisMATVarName) = overSaveStruct.saveStruct(i).(thisMATVarName); %Specifically load only the variable in question
                            else
                                matStruct.(thisMATVarName)(:, size(matStruct.(thisMATVarName),2)+1 : size(matStruct.(thisMATVarName),2) + size(overSaveStruct.saveStruct(i).(thisMATVarName),2) ) = overSaveStruct.saveStruct(i).(thisMATVarName);
                                    %A somewhat clunky system to horizontally concatenate new data
                                        %Note: Critical reliance on source MAT data being horizontal, not vertical
                            end
                        end
                        %Note down that this field is had
                        for y = 1:size(MATNeeds,2)
                            if isempty(strfind(MATNeeds{y},thisMATVarName)) ~= 1 && strfind(MATNeeds{y},thisMATVarName) == 1
                                MATHas(y) = 1;
                            end
                        end
                    end
                    %carrierOrderBlock
                    coords = [ size(matStruct.carrierOrderBlock,2)+1 : size(matStruct.sentStimuli,2) ];
                    matStruct.carrierOrderBlock(coords) = repmat( matStruct.carrOdd(i), 1, size(coords,2) );
                                        
                    %QA from CarrierSwitch
                    if isnan(matStruct.carrOdd(i)) ~= 1 & matStruct.carrOdd(i) ~= matStruct.CarrierOrder(i)
                        ['## Alert: Files appear to have been loaded out of order ##']
                        crash = yes %Looping suppressed due to decision
                        %{
                        proceed = 0;
                        useSaveStructActive = 0; %On next loop, attempt to use non saveStruct
                        ['# Looping due to failure in MAT loading #']
                        matStruct = struct; %Clear these
                        matStruct.carrierOrderBlock = []; %Clear these
                        %}
                    end
                end
                
                %See if any fields were missing and attempt to load separate data if so
                if nansum(MATHas) ~= size(MATHas,2)
                    ['#- One or more fields not present in saveStruct data; Attempting to load manual files -#']
                    for y = 1:size(MATHas,2)
                        if MATHas(y) ~= 1
                            disp(['# Looking for files corresponding to ',MATNeeds{y},' #'])
                            %manFiles = dir([matFolderName filesep MATNeeds{y} '_' expName '_*' '.mat']); %Recapitulation
                            didFindFile = 0;
                            for w  = 1:size(foundMATFiles,1)
                                for z = matStruct.carrOdd
                                    if isempty(strfind(foundMATFiles(w).name, [MATNeeds{y}])) ~= 1 && isempty(strfind(foundMATFiles(w).name, [ 'carrOdd',num2str(z) ])) ~= 1 %Look for files matching name and carrOdd
                                            %Note: This relies on naming format including carrOdd, which may not be case in very old data
                                        disp(['# Found files #'])
                                        %preLoad = load( [foundMATFiles(w).folder, filesep, foundMATFiles(w).name], MATNeeds{y} );
                                        %------------------
                                        %Generalised armoured loader
                                        proceed = 0;
                                        while proceed ~= 1 && proceed > -10 
                                            try
                                                preLoad = load( [foundMATFiles(w).folder, filesep, foundMATFiles(w).name], MATNeeds{y} );
                                                proceed = 1;
                                            catch ME
                                                switch ME.identifier
                                                    case 'MATLAB:load:cantReadFile'
                                                        ['-# Caution: Failure to load file; Will retry (Att. ',num2str(abs(proceed)),') #-']
                                                        proceed = proceed - 1;
                                                        pause(10)
                                                    otherwise
                                                        rethrow(ME)
                                                        ['## Alert: Irrecoverable MAT data load failure ##']
                                                        crash = yes
                                                end
                                            end
                                        end
                                        %QA for success
                                        if proceed == 0
                                            ['## Failure to load MAT data ##']
                                            crash = yes
                                        end
                                        %------------------
                                        coords = [matStruct.carrierOrderBlock == z];
                                        for t = 1:size(preLoad.(MATNeeds{y}),1)
                                            matStruct.(MATNeeds{y})(t,coords) = preLoad.(MATNeeds{y})(t,:); 
                                        end
                                        didFindFile = 1;
                                    end
                                end
                            end
                            %QA
                            if didFindFile == 0
                                ['## Alert: Could not find files for ',MATNeeds{y},' ##']
                                crash = yes
                            end
                        end
                    end
                end

                %QA from blockNum
                if isfield(matStruct,'blockNum') == 1
                    if matStruct.blockNum ~= flies(IIDN).blockNum
                        flies(IIDN).blockNum
                        if str2num([num2str(flies(IIDN).flyNum),num2str(flies(IIDN).blockNum)]) == matStruct.blockNum
                            disp(['#- Disparity between requested and stimulus MATLAB self-reported block number explainable by fly identity -#'])
                        else
                            ['## Alert: Inexplicable disparity between requested block number and MATLAB output self-reported block number ##']
                        end
                    end
                end

            else %Don't (or can't) use saveStruct
                
                %Newer, generalised system
                %Identify unique identifiers
                nameTemp = repmat('#',size(foundMATFiles,1),128); %Hardcoded maximum filename size of 128 (Could make dynamic but effort probably not worth it)
                nameTempBool = zeros(size(foundMATFiles,1),128);
                for i = 1:size(foundMATFiles,1)
                    nameTemp(i,1:size(foundMATFiles(i).name,2)) = foundMATFiles(i).name; %Calculates difference of all names relative to first detected data file
                    nameTempBool(i,:) = ( nameTemp(i,:) ~= nameTemp(1,:) );
                end
                sumNameTempBool = nansum(nameTempBool,1); %Sums to find places of discontinuity
                identPosStart = find(sumNameTempBool ~= 0,1); %Assumes that first location of discontinuity is unique identifier
                    %Note: Assumption of this never shifting

                %Identify CarrierOrder
                carrierOrder = [];
                for i = 1:size(foundMATFiles,1)
                    %preLoad = load( [backupMatFolderName filesep foundMATFiles(i).name] );
                    %------------------
                    %Generalised armoured loader
                    proceed = 0;
                    while proceed ~= 1 && proceed > -10 
                        try
                           preLoad = load( [backupMatFolderName filesep foundMATFiles(i).name] );
                            proceed = 1;
                        catch ME
                            switch ME.identifier
                                case 'MATLAB:load:cantReadFile'
                                    ['-# Caution: Failure to load file; Will retry (Att. ',num2str(abs(proceed)),') #-']
                                    proceed = proceed - 1;
                                    pause(10)
                                otherwise
                                    rethrow(ME)
                                    ['## Alert: Irrecoverable MAT data load failure ##']
                                    crash = yes
                            end
                        end
                    end
                    %QA for success
                    if proceed == 0
                        ['## Failure to load MAT data ##']
                        crash = yes
                    end
                    %------------------
                    if isfield(preLoad, 'CarrierOrder') == 1
                        carrierOrder = preLoad.CarrierOrder;
                        break
                    end
                end

                %Load
                rotation = 0;
                %lastRotation = -1;
                loadedList = []; %Concatenated string of names
                    %Note: This system will fail if fields share name fragments (i.e. "Gating" and "GatingOrder" or similar)
                for i = 1:size(foundMATFiles,1)
                    if isempty(strfind(foundMATFiles(i).name, 'saveStruct')) == 1 %Exclude saveStruct files even if they are existing
                        thisIdentPosEndIdx = strfind( foundMATFiles(i).name(identPosStart:end), '_' ); %Identify end of unique variable name in filename
                            %Note: This means there can be no underscores in variable names ever
                        thisIdentPosEnd = thisIdentPosEndIdx(1) + identPosStart; %Use first value of find, with correction of identPosStart applied due to preceding line indexing
                        %thisMATVarName = foundMATFiles(i).name(identPosStart:thisIdentPosEnd-2); %Minus 2 because reasons

                        if isempty(strfind(foundMATFiles(i).name, 'carrOdd')) ~= 1 %Run if carrOdd information included in filename
                            carrOddStrPos = strfind(foundMATFiles(i).name, 'carrOdd') + size('carrOdd',2);
                            thisCarrSwitch = str2num(foundMATFiles(i).name(carrOddStrPos));
                        end

                        %Check if existing and load
                        %preLoad = load( [backupMatFolderName filesep foundMATFiles(i).name] );
                        %------------------
                        %Generalised armoured loader
                        proceed = 0;
                        while proceed ~= 1 && proceed > -10 
                            try
                               preLoad = load( [backupMatFolderName filesep foundMATFiles(i).name] );
                               proceed = 1;
                            catch ME
                                switch ME.identifier
                                    case 'MATLAB:load:cantReadFile'
                                        ['-# Caution: Failure to load file; Will retry (Att. ',num2str(abs(proceed)),') #-']
                                        proceed = proceed - 1;
                                        pause(10)
                                    otherwise
                                        rethrow(ME)
                                        ['## Alert: Irrecoverable MAT data load failure ##']
                                        crash = yes
                                end
                            end
                        end
                        %QA for success
                        if proceed == 0
                            ['## Failure to load MAT data ##']
                            crash = yes
                        end
                        %------------------
                        if isempty(strfind(foundMATFiles(i).name,'saveStruct')) == 1 %Since we don't want to use saveStruct files
                            preLoadVarsPresent = fieldnames(preLoad);
                            for x = 1:size(preLoadVarsPresent,1)
                                thisMATVarName = preLoadVarsPresent{x};
                                if isempty(strfind(thisMATVarName,'CarrierOrder')) == 1 | ( isempty(strfind(thisMATVarName,'CarrierOrder')) ~= 1 &  isfield(matStruct, 'CarrierOrder') ~= 1 )
                                    if isfield(matStruct, thisMATVarName) ~= 1
                                        %preLoad = load( [backupMatFolderName filesep foundMATFiles(i).name] , thisMATVarName);
                                        matStruct.(thisMATVarName) = preLoad.(thisMATVarName); %Specifically load only the variable in question
                                        %rotation = 1; %Number of times through the MAT files
                                    else
                                        matStruct.(thisMATVarName)(:, size(matStruct.(thisMATVarName),2)+1 : size(matStruct.(thisMATVarName),2) + size(preLoad.(thisMATVarName),2) ) = preLoad.(thisMATVarName);
                                            %A somewhat clunky system to horizontally concatenate new data
                                                %Note: Critical reliance on source MAT data being horizontal, not vertical
                                        %rotation = size(matStruct.(thisMATVarName),2) / size(preLoad.(thisMATVarName),2); %This takes the total height and divides it to calculate the rotation, but this requires perfectly even portions
                                    end
                                    loadedList = [loadedList, thisMATVarName];
                                    rotation = size(strfind(loadedList,thisMATVarName),2);
                                    %Append CarrierOrder
                                    if strfind(thisMATVarName,'Gating') == 1 %Hardcoded dependency on existence of Gating file (Easier than a generalised rotation detection tbh)
                                        coords = [ size(matStruct.carrierOrderBlock,2)+1 : size(matStruct.(thisMATVarName),2) ];
                                        matStruct.carrierOrderBlock(coords) = repmat( preLoad.CarrierOrder(rotation), 1, size(coords,2) ) ;
                                        %disp(['Coords: ',num2str(coords)])
                                    end
                                    %lastRotation = rotation;
                                end
                            end
                        end
                       

                        %QA based on CarrierOrder
                        if isempty(strfind(foundMATFiles(i).name, 'carrOdd')) ~= 1 & thisCarrSwitch ~= carrierOrder(rotation) %Uses last rotation calculated, rather than running within the x loop
                            ['## Alert: Data potentially loaded out of order ##']
                            crash = yes
                        end
                    end

                    preLoad = []; %Clear (just in case)
                end

                %Prepare some variables for saving later, if requested
                    %Moved down later (See above)
                    %{
                if saveFigs == 1
                    saveName = strcat(figPath,'\',foundMATFiles(1).name(1:end-4));
                    saveName = strrep(saveName, '_Amplitude_', '_'); %NOTE: HIGHLY POSSIBLE THIS IS NOT ALWAYS TRUE
                end
                if doMat == 1 && saveMat == 1
                    matSaveName = strcat(matSavePath,'\',foundMATFiles(1).name(1:end-4));
                    matSaveName = strrep(matSaveName, '_Amplitude_', '_'); %NOTE: HIGHLY POSSIBLE THIS IS NOT ALWAYS TRUE
                end
                    %}

            %useSaveStruct end
            end

            %Quick QA for all data
            if isfield(matStruct, 'Gating') ~= 1 || isfield(matStruct, 'Channel') ~= 1 || isfield(matStruct, 'Amplitude') ~= 1 || ...
                    isfield(matStruct, 'Stimulus') ~= 1 || isfield(matStruct, 'TTL') ~= 1 || isfield(matStruct, 'sentStimuli') ~= 1
                ['## Alert: One or more critical fields missing from imported MAT files ##']
                if useSaveStructActive == 0
                    crash = yes
                else
                    crash = yes; %Looping suppressed
                    %{
                    proceed = 0;
                    useSaveStructActive = 0;
                    ['# Looping due to failure in MAT loading #']
                    %}
                end
            end
        %proceed end
        end

        %{
        % The ICA files will be index automatically by dir. To prevent them
        % being loaded...
        FolderName = [procPath filesep flies(FolderSearch).name]
        if ~isempty(strfind(FolderName,'_ICA'))
            continue
        end
        %}

        %####
        if doLoadCalib == 1
            detCalibFolders = dir([procPath,filesep,flies(IIDN).name, filesep, 'LFP', filesep, '*Calib*']);
            validCalibFolders = [];
            b = 1;
            for i = 1:size(detCalibFolders,1)
                %Calib files
                if isempty(strfind(detCalibFolders(i).name, 'Calib')) ~= 1 %&&...
                %        isempty(strfind(detCalibFolders(i).name, flies(IIDN).name)) ~= 1 %Second half of statement removed in line with procPath differences
                    validCalibFolders{b} = detCalibFolders(i).name;
                    b = b + 1;
                end
            end
            disp(['-- ', num2str(b-1), ' potential calibration dataset/s detected for ',flies(IIDN).name, ' --'])

            %Remove calib hits that are not applicable
            validAndApplicableCalib = [];
            customStr = []; %Will be used for any special finding conditions (like fly number)
            if flies(IIDN).flyNum ~= 1
                customStr = ['Fly',num2str(flies(IIDN).flyNum)];
            end
            b = 1;
            for i = size(validCalibFolders,2):-1:1
                if size(customStr,2) > 0 
                    if isempty( strfind(validCalibFolders{i}, 'Calib') ) ~= 1 && isempty( strfind(validCalibFolders{i}, customStr) ) ~= 1 %E.g. "130720_OddballFly2"
                        validAndApplicableCalib{b} = validCalibFolders{i};
                        b = b + 1;
                    end
                else
                    %if isempty( strfind(validCalibFolders{i}, 'Calib') ) ~= 1 && strfind(validCalibFolders{i}, 'Calib') == strfind(validCalibFolders{i}, '_') %E.g. "130720_Oddball"
                    if isempty( strfind(validCalibFolders{i}, 'Calib') ) ~= 1 && ismember( strfind(validCalibFolders{i}, 'Calib')+size('Calib',2) , strfind(validCalibFolders{i}, '_') ) %E.g. "130720_Oddball"
                            %Note: The second half of this checks to see if the word 'Calib' is immediately followed by an underscore
                        validAndApplicableCalib{b} = validCalibFolders{i};
                        b = b + 1;
                    end
                end
            end
            %QA/reporting
            if size(validAndApplicableCalib,2) > 1
                ['# More than one applicable calib detected #']
                crash = yes
            elseif size(validAndApplicableCalib,2) == 0
                ['## Alert: No applicable calib detected ##']
                crash = yes
            end
            disp(['-- Using calib ',validAndApplicableCalib{1},' --'])
            calibPath = [procPath,filesep,flies(IIDN).name, filesep, 'LFP', filesep, validAndApplicableCalib{1}];
            detectedCalibFiles = dir([calibPath, filesep, '*.mat']); %Used to have a hardcoded reference to Block 1, which is sometimes not the calibration case
            %QA
            if size(detectedCalibFiles,1) > 1
                ['## Alert: Multiple calib files detected in directory ##']
                crash = yes
            end
            calibFile = detectedCalibFiles(1).name;

            %Load calib to determine polarity reversal
            preLoad = [];
            %preLoad = load([calibPath,filesep,calibFile]);
            %------------------
            %Generalised armoured loader
            proceed = 0;
            while proceed ~= 1 && proceed > -10 
                try
                   preLoad = load([calibPath,filesep,calibFile]);
                   proceed = 1;
                catch %ME
                    %switch ME.identifier
                    %    case 'MATLAB:load:cantReadFile'
                            ['-# Caution: Failure to load file; Will retry (Att. ',num2str(abs(proceed)),') #-']
                            proceed = proceed - 1;
                            %pause(10)
                            pause(abs(proceed)*10) %Pause for longer and longer each time, in case is (relatively) brief network failure
                    %    otherwise
                    %        rethrow(ME)
                    %        ['## Alert: Irrecoverable calib data load failure ##']
                    %        crash = yes
                    %end
                end
                %pause(10)
            end
            %QA for success
            if proceed ~= 1
                ['## Failure to load calib data ##']
                crash = yes
            end
            %------------------
            %QA for correct date
            if useSaveStruct == 1 %QA only possible with saveStruct information
                firstSentTimePosix = posixtime(datetime(strcat(matStruct.sentStimuli(1).trialSendDatestr),'Format', 'yyyy dd/MM HH:mm:ss:SSS', 'TimeZone', '+10:00')); %This is a duplication of a later line
                %calibSentTimePosix = preLoad.EEG.info.headerstarttime; %NOTE: REPORTED UTC STOP TIME IS INDEED RELATIVE TO UTC
                calibSentTimePosix = posixtime(datetime(strcat([preLoad.EEG.info.date,' ',preLoad.EEG.info.utcStartTime]),'Format', 'yyyy-MMM-dd HH:mm:ss', 'TimeZone', '+10:00')); %Changed from "MMMM"
                disp(['-- Time between calibration and first trial sending: ',num2str((firstSentTimePosix - calibSentTimePosix)/60),' min/s --'])
                    %Note: If not analysing block 1, expect this value to be anywhere from 1hr to 3hrs
                if firstSentTimePosix < calibSentTimePosix
                    ['## Alert: First trial sending precedes apparent calibration sending time ##']
                    crash = yes
                end
                if abs(firstSentTimePosix - calibSentTimePosix) > 60*60*12 %"First trial occurred more than 12 hours after (or before) calib"
                    ['## Alert: Significant time mismatch between loaded calib files and data files ##']
                    crash = yes
                end
            end

            %Pull polarity reversal location information (if existing)
            if isfield(preLoad.EEG,'detectedPolReversalChan') == 1
                polReversalChan = preLoad.EEG.detectedPolReversalChan;
            else
                ['#- Warning: Could not pull polarity reversal channel location from calib files -#']
                polReversalChan = [];
            end

        end
        %####

        fprintf('Adding data to the workspace.\n');

        save_folder = procPath;
        %cd('D:\group_swinderen\Matthew\TDTs\Processed\240320\LFP\Analyzed_LFP_Block-1')

        %%cd(save_folder)


        %DataDir = [filesep 'SpliceData' filesep 'AllSplicedDataFlyBlock_1.mat'];
        %StimDir = [filesep 'SpliceData' filesep 'AllSplicedStimulusDataBlock_1'];

        %Load actual data
        %blockDataList = dir([FolderName,filesep,'LFP']); %Catches all
        blockDataList = dir([FolderName,filesep,'LFP', filesep, '*', expName, '*']); %Catches only those bearing expName
        validAndApplicableBlockDatas = [];
        a = 1;
        for i = 1:size(blockDataList,1)
            if isempty(strfind(blockDataList(i).name,['Block-',num2str(flies(IIDN).blockNum)])) ~= 1 && isempty(strfind(blockDataList(i).name,['Calib'])) == 1
                validAndApplicableBlockDatas{a} = blockDataList(i).name;
                a = a + 1;
            end
        end
        %Reverse iterate through list and remove hits that are not applicable
        for a = size(validAndApplicableBlockDatas,2):-1:1
            wipeThis = 0;
            %{
            if ( isempty(strfind(validAndApplicableBlockDatas{a},'Fly')) ~= 1 & str2num(validAndApplicableBlockDatas{a}( strfind(validAndApplicableBlockDatas{a},'Fly') + 3 )) ~= flies(IIDN).flyNum ) %&& ( size(blorg,2) > 0 && contains( validAndApplicableBlockDatas{a} , customStr ) )
                    %Might crash if postceding character cannot be parsed to number
                disp(['#- Dataset ',validAndApplicableBlockDatas{a},' determined to be applying to different fly and thus excluded -#'])
                validAndApplicableBlockDatas(a) = [];
            end
            %}
            if size( customStr,2 ) > 0 && contains( validAndApplicableBlockDatas{a} , customStr ) == 0
                disp(['#- Dataset ',validAndApplicableBlockDatas{a},' lacks custom string ("',customStr,'") and thus excluded -#'])
                wipeThis = 1;
            end
            if contains( validAndApplicableBlockDatas{a} , 'Fly' ) == 1 && str2num(validAndApplicableBlockDatas{a}( strfind(validAndApplicableBlockDatas{a},'Fly') + 3 )) ~= flies(IIDN).flyNum
                %disp(['#- Dataset ',validAndApplicableBlockDatas{a},' appears to apply to different fly (',validAndApplicableBlockDatas{a}( strfind(validAndApplicableBlockDatas{a},'Fly') + 3 ),', when ',num2str(flies(IIDN).flyNum),' is needed) and thus was excluded -#'])
                disp(['#- Dataset ',validAndApplicableBlockDatas{a},' appears to apply to different fly (',validAndApplicableBlockDatas{a}( strfind(validAndApplicableBlockDatas{a},'Fly') + 3 ),', when ',num2str(flies(IIDN).flyNum),' is needed) and thus was excluded -#'])
                wipeThis = 1;
            end
            if strfind( validAndApplicableBlockDatas{a} , ['Block-',num2str(flies(IIDN).blockNum)] ) - 1 + size( ['Block-',num2str(flies(IIDN).blockNum)] , 2 ) ~= size(validAndApplicableBlockDatas{a},2)
                    %Note: This is a bootleg way of checking if the blockNum is terminal in the folder name
                %disp(['#- Dataset ',validAndApplicableBlockDatas{a},' appears to apply to different block (',validAndApplicableBlockDatas{a}( strfind(validAndApplicableBlockDatas{a},'Fly') + 3 ),', when ',num2str(flies(IIDN).flyNum),' is needed) and thus was excluded -#'])
                if overnightMode ~= 1
                    disp(['#- Dataset ',validAndApplicableBlockDatas{a},' appears to apply to different block (',validAndApplicableBlockDatas{a}( strfind(validAndApplicableBlockDatas{a},'Block') : end ),', when ',num2str(flies(IIDN).blockNum),' is needed) and thus was excluded -#'])
                end
                wipeThis = 1;
            end
            if wipeThis ~= 1 && overnightMode == 1 && useStitched == 1 && contains( validAndApplicableBlockDatas{a} , 'Stitched' ) ~= 1
                disp(['#- Dataset ',validAndApplicableBlockDatas{a},' lacks "Stitched" and thus was excluded -#'])
                wipeThis = 1;
            end
            
            if wipeThis == 1
                validAndApplicableBlockDatas(a) = [];
            end
        end
        %QA
        if size(validAndApplicableBlockDatas,2) > 1
            ['## Alert: Mutiple matching datasets detected ##']
            error = yes
        end
        %Load data
        load_check = 0;
        while load_check == 0

                %chunk_filename = erase(flies(FolderSearch).name,'Analyzed_');
                %new_data_name = [chunk_filename '_chunk_01.mat'];
                %new_data_name = [FolderName filesep 'LFP' filesep 'Analyzed_LFP_Block-1' ...
                %    filesep flies(FolderSearch).name '_chunk_01.mat'];
                %new_data_name = [FolderName filesep 'LFP' filesep 'Analyzed_' expName '_Block-1' ...
                %    filesep flies(FolderSearch).name '_chunk_01.mat'];
                %new_data_name = [FolderName filesep 'LFP' filesep 'Analyzed_' expName customStr '_Block-' num2str(flies(IIDN).blockNum) ...
                %    filesep flies(IIDN).name '_chunk_0' num2str(flies(IIDN).blockNum) '.mat']; %Note: Does not support a higher block number than 9
                %    %Also note the addition of customStr
                blockID = num2str(flies(IIDN).blockNum);
                if size(blockID,2) < 2
                    blockID = ['0',blockID];
                end
                new_data_name = [FolderName filesep 'LFP' filesep validAndApplicableBlockDatas{1} ...
                    filesep flies(IIDN).name '_chunk_' blockID '.mat'];
                if isempty(dir(new_data_name)) ~= 1
                    %{
                    try
                        load(new_data_name)
                        load_check =1;
                    catch
                        warning('Error loading files. Trying again in 30 seconds.')
                        pause(30)
                        load_check = 0;
                    end
                    %}
                    %------------------
                    %Generalised armoured loader
                    proceed = 0;
                    while proceed ~= 1 && proceed > -10 
                        try
                            load(new_data_name)
                            load_check =1;
                            proceed = 1;
                        catch ME
                            switch ME.identifier
                                case 'MATLAB:load:cantReadFile'
                                    ['-# Caution: Failure to load file; Will retry (Att. ',num2str(abs(proceed)),') #-']
                                    proceed = proceed - 1;
                                    pause(10)
                                otherwise
                                    rethrow(ME)
                                    ['## Alert: Irrecoverable LFP data load failure ##']
                                    crash = yes
                            end
                        end
                        pause(10)
                    end
                    %QA for success
                    if proceed == 0
                        ['## Failure to load LFP data ##']
                        crash = yes
                    end
                    %------------------

                else
                    ['## Processed data is not existing ##']
                    disp(new_data_name)
                    crash = yes
                end
        end
        
        newPreProc = 0; %Indicates whether data was preprocessed with Mk 5 or later (General dynamicisation)
        if overnightMode == 1 && useStitched == 1
            EEG = stitchEEG;
            clear stitchEEG
            disp(['-- Sitched EEG loaded --'])
        else
            EEG = EEG; %Unnecessary step just to show that otherwise EEG existence is brought about natively by the loading of the data
        end
        
        dataChannelData = [];
        stimChannelData = [];
        %Decide if data was preprocessed with new or not
        if isfield( EEG , 'ancillary' ) == 1 && isfield( EEG.ancillary , 'preprocessIdent' ) == 1 %Checks to see if the data has the ancillary field and the preprocesssIdent subfield
            %A truly smart way to do this would be to have actual numbers for the version and check to see if the version >5 but I am lazy and honestly the field presence indicates enough
            dataChannelData = EEG.( EEG.dataChannelID ); %Replaces the old system of using EEG.data
            if isempty( EEG.stimChannelID ) ~= 1 && nansum( isnan( EEG.stimChannelID ) ) ~= size( EEG.stimChannelID , 2 )
                stimChannelData = EEG.( EEG.stimChannelID );
            else
                stimChannelData = nan(1,size(dataChannelData));
            end
        else
            %dataChannelData = EEG.data;
            %stimChannelData = EEG.stims;
            dataChannelData.data = EEG.data;
            stimChannelData.data = EEG.stims;
        end

        %New
        if nansum(isnan(dataChannelData.data(1,:)) == 1) > 0
            dataChannelData.data(isnan(dataChannelData.data) == 1) = 0;
            stimChannelData.data(isnan(stimChannelData.data) == 1) = 0;
            disp(['-# Data contained NaNs; These have been zeroed #-'])
        end
        %Old
        %{
        if nansum(isnan(EEG.data(1,:)) == 1) > 0
            EEG.data(isnan(EEG.data) == 1) = 0;
            EEG.stims(isnan(EEG.stims) == 1) = 0;
            disp(['-# Stitched data contained NaNs; These have been zeroed #-'])
        end
        %}

        if dontSaveProcessed ~= 1
            % Renaming FolderName...
            %FolderName = [FolderName '_ICA'];
            %FolderName = [FolderName '_' expName '_ICA']; %Added expName to allow simultaneous analysis of different experiments without processed data saving issues
            FolderName = [FolderName '_' expName customStr rerefIndex{rerefMode} filesep 'Block-' num2str(flies(IIDN).blockNum)]; %Added expName to allow simultaneous analysis of different experiments without processed data saving issues
            if isdir(FolderName) ~= 1
                mkdir(FolderName);
            end
        end

        %Autodetect resampling frequency
        if isfield(EEG,'srate') == 1
            resampleFreq = EEG.srate;
            disp(['-- Detected resampling frequency: ',num2str(resampleFreq), 'Hz --'])
        else
            resampleFreq = 1000; %Assumed default value
        end

        %Check size of virtual and real channels
        %virtRealSizeDisparity = size(EEG.stims,2) - size(EEG.data,2);
        virtRealSizeDisparity = size(stimChannelData.data,2) - size(dataChannelData.data,2);
        if virtRealSizeDisparity ~= 0
            ['## Warning: Size disparity of ',num2str(virtRealSizeDisparity),' samples (',num2str(virtRealSizeDisparity/resampleFreq),'s) exists between virtual and real channels ##']
            %crash = yes %If this proves to be common, maybe allow some leeway here
        end
        
        %Pull name for figures
        if saveFigs == 1
            %saveName = strcat(figPath,'\',saveStructFiles(1).name(1:end-4));
            saveName = strcat(figPath,'\',EEG.filename);
            saveName = strrep(saveName, '_saveStruct_', '_');
        end
        if doMat == 1 && saveMat == 1
            matSaveName = strcat(matSavePath,'\',saveStructFiles(1).name(1:end-4));
            matSaveName = strrep(matSaveName, '_saveStruct_', '_');
        end
        
        %EEG.filename
        if ~exist('dataset','var') || ( exist('dataset','var') && isempty(dataset) == 1 )
            disp(['-# Dataset name not detected; Automatically deriving #-'])
            dataset = EEG.filename;
        end

        %
        %try
        
        %-------------------------
        
        %Integrate data if applicable
        if integMode == 1
            %Search for behav files that match the name of this fly
            %foundBehavs = dir([behavIntegFolder, filesep, '*', dataset, '*']);
            foundBehavs = dir([behavIntegFolder, filesep, '*', flies(IIDN).name, '*'])
        
            if isempty(foundBehavs)
                disp(['-# Behav data could not be found; Attempting refind with alt names #-'])
                try
                    datasetDate = datetime(dataset, 'InputFormat', 'ddMMyy'); %Try to convert to date
                    datasetAlt = datestr(datasetDate, 'dd mm yy'); %Convert back to string, but with spaces
                    if isempty(foundBehavs)
                        foundBehavs = dir([behavIntegFolder, filesep, '*', datasetAlt, '*'])
                    end
                catch
                    ['## Failure to find data ##']
                    crash = yes
                end
            end
            %QA
            if isempty(foundBehavs)
                ['## Warning: No behav data could be found ##']
                crash = yes
            end
            if size(foundBehavs,1) > 1
                ['## Warning: Critical behav data overfind ##']
                crash = yes
            end

        
            %Load
            tic
            %lfpLoad = load([foundLFPs.folder,filesep,foundLFPs.name]);
            %behavLoad = load([foundBehavs.folder,filesep,foundBehavs.name]);
            %------------------
            %Generalised armoured loader
            proceed = 0;
            while proceed ~= 1 && proceed > -10 
                try
                    behavLoad = load([foundBehavs.folder,filesep,foundBehavs.name]);
                    proceed = 1;
                catch ME
                    switch ME.identifier
                        case 'MATLAB:load:cantReadFile'
                            ['-# Caution: Failure to load file; Will retry (Att. ',num2str(abs(proceed)),') #-']
                            proceed = proceed - 1;
                            pause(10)
                        otherwise
                            rethrow(ME)
                            ['## Alert: Irrecoverable behav data load failure ##']
                            crash = yes
                    end
                end
            end
            %QA for success
            if proceed == 0
                ['## Failure to load behav data ##']
                crash = yes
            end
            %------------------
            disp(['-- Behav file loaded in ',num2str(toc),'s --'])
        
        end

        %-------------------------

        %% Stimulus Detection

        %SplicedStim = EEG.stims; %Old
        SplicedStim = stimChannelData.data; %New
        %{
        if invertPhotodiodeSignal == 1
            SplicedStim(4,:) = -SplicedStim(4,:);
        end
        %}
        
        %Auto-detection of photodiode data
            %Note: modernData as defined below corresponds to data recorded after February 2022 
        modernData = 0;
        if ( isfield(EEG,'PDec') == 1 && size(EEG.PDec.data,1) == 8 ) | ...
                ( isfield( matStruct , 'ancillary' ) && isfield( matStruct.ancillary , 'flagParamSaveStruct' ) && isfield( matStruct.ancillary.flagParamSaveStruct , 'progVer' ) && matStruct.ancillary.flagParamSaveStruct.progVer  >= 9.75 ) %This relies on assumption that old data had 16 channels of PDec
            disp(['-- Modern photodiode storage detected; Using PDec for photodiode data --'])
            SplicedPhot = EEG.PDec.data;
            modernData = 1;
            %invertPhotodiodeSignal = 0;
            photodiodeSignalSign = 1; %1 - Upright, -1 - Inverted
        else
            SplicedPhot = SplicedStim(4,:); %Row trimming necessary because modern SplicedPhot only specified for row 1
            %invertPhotodiodeSignal = 1;
            photodiodeSignalSign = -1;
        end
        overVar(IIDN).ancillary.photodiodeSignalSign = photodiodeSignalSign;
        if photodiodeSignalSign == -1
        %if invertPhotodiodeSignal == 1
            %SplicedStim(4,:) = -SplicedStim(4,:);
            for row = 1:size( SplicedPhot , 1 )
                SplicedPhot(row,:) = -SplicedPhot(row,:);
            end
        end
        %QA for actual data in SplicedPhot
        if nansum( nansum( SplicedPhot ) ) == 0
            if exist('allowNullPhot') ~= 1 || ( exist('allowNullPhot') == 1 && allowNullPhot == 0 )
                ['## Alert: No valid data detected in SplicedPhot ##']
                crash = yes
            elseif exist('allowNullPhot') == 1 && allowNullPhot == 1 
                disp(['## Alert: No valid data detected in SplicedPhot (But this is allowed) ##'])
            end
        end

        %splicedEpoch = EEG.epoch_times; %Old
        if isfield( dataChannelData , 'epoch_times' ) == 1
            splicedEpoch = dataChannelData.epoch_times; %New
                %Note: This is not a true accurate timestamp array
                %(Posix values are simply interpolated in the preprocessing script between the start and end (of each chunk, where data is chunked))
        else
            splicedEpoch = EEG.epoch_times; %Old
        end
    
        %SplicedData = EEG.data;
        SplicedData = dataChannelData.data;
        
        %Clear now-unnecessary variables
        clear dataChannelData stimChannelData
        
        if doPatternMatching ~= 0
            patternModeActive = patternMode; %Use active so that flag not reset
        end
        %Load OutP, if existing
        if useOutPData == 1
            outPExisting = 0;
            if isfield( EEG , 'OutP' ) == 1
                SplicedOutP = EEG.OutP.data;
                    %Note: No guarantee of meaningfulness
                outPExisting = 1;
            end
            %Check for patternmode issues
            if doPatternMatching == 1 && outPExisting == 0 & patternMode == 2
                ['-# Caution: OutP pattern matching requested, but OutP not available; Value overridden #-']
                patternModeActive = 1;
            end
        end
        
        %Testatory early plot
        figure
        plot(SplicedData(1,:))
        set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - All Data Ch. 1']);


        %% Line noise removal
        %"WWDD - What Would Dror Do"
        if doRemoveLineNoise == 1
            lineNoiseList = [50,100,150]; %Noise, 1st harmonic, 2nd harmonic

            fs=resampleFreq; %sampling rate of 1000Hz
            
            for lineInd = 1:size(lineNoiseList,2)
                try
                    freqToRemove = lineNoiseList(lineInd);
                    wo = freqToRemove/(fs/2);  bw = wo/35;

                    [b,a] = iirnotch(wo,bw); %remove line noise of 50Hz

                    SplicedData = filter(b,a,SplicedData);
                catch
                    ['## Could not remove line noise at ',num2str(lineNoiseList(lineInd)),'Hz ##']
                end
            end
        end
        
        
        %% Filter Data (butterworth)
       
        if doButterworth == 1
            fprintf('Filtering data.\n');       
            % apply 0.5 high pass and 200 hz low pass filter
            filterOrder  = 4;
            cutOffFreq = [20, 0.5];
            sampleRate = resampleFreq;

            for ftype = 1:2
                for ChanNum = 1:size(SplicedData,1)
                    SplicedData(ChanNum,:) = ButterworthFilt( SplicedData(ChanNum,:), ftype, filterOrder, cutOffFreq(1, ftype), sampleRate);
                end
            end
        else
            disp(['# Filtering disabled #'])
        end

        %% Drift Removal (2s median filter)
        switch 1
            case 1
                disp('Removing drift from data')
                %SplicedData = DriftRemoval( SplicedData, [], FolderName );
                SplicedData = DriftRemovalMatt( SplicedData, [], FolderName , resampleFreq, 2 , 0 );
                    %Matt modifications add unambiguous specification of resampleFreq, the window size and whether to save
        end

        %% Artefact correction (either ICA or polarity reversal channel rereferencing)
        
        %Pre-reref plot
        %{
        figure
        for chanInd = 1:size(SplicedData,1)
            %plot( SplicedData(chanInd, 7.9e4:8e4) - chanInd*100 )
            plot( ( SplicedData(chanInd, 7.9e4:8e4) - SplicedData(11, 7.9e4:8e4) ) - chanInd*100 )
            hold on
        end
        %}
        
        if rerefMode == 1
            %%ICA Analysis (replacing bipolar re-referencing)
            fprintf('IIIIIIIIII - Doing ICA correction. - IIIIIIIIII\n');

            SplicedData = ica_analysis(SplicedData, size(SplicedData,1));
            
            %{
            if ~isdir([  FolderName filesep 'SplicedData_ICA'])
                mkdir([  FolderName filesep 'SplicedData_ICA']);
            end

            save_check = 0;
            while save_check ==0
                try
                    save([  FolderName filesep 'SplicedData_ICA' filesep 'SplicedData.mat'], 'SplicedData');
                    save_check =1;
                catch
                    warning('Error saving files. Trying again in 30 seconds.')
                    pause(30)
                    save_check = 0;
                end
            end
            %}
        elseif rerefMode == 2
            %Polarity reversal channel rereferencing
            disp(['////////// Rereferencing with polarity reversal channel \\\\\\\\\\'])
            if isempty(polReversalChan) ~= 1
                polReversData = repmat( SplicedData(polReversalChan,:) , size(SplicedData,1) ,1 );
            else
                ['## Alert: Cannot reference without polarity reversal channel information ##']
                crash = yes
            end

            %Subtract polarity reversal channel data from other channels (and self, technically)
            SplicedData = SplicedData - polReversData;
            SplicedData(polReversalChan,:) = NaN;

        elseif rerefMode == 3
            disp(['~~~~~~~~~~ Performing no rereferencing ~~~~~~~~~~'])
        elseif rerefMode == 4
            disp(['/\/\/\/\/\ Rereferencing with average of polarity flip channels \/\/\/\/\/'])
            if isempty(polReversalChan) ~= 1
                if polReversalChan ~= size(SplicedData,1) %Check not trying to use last channel and next channel (which would be nonexistent)
                    flipChannelsData = [SplicedData(polReversalChan,:) ; SplicedData(polReversalChan+1,:)]; %"Take the polarity flip channel and the next one"
                    flipChannelsDataMean = nanmean(flipChannelsData,1);
                    polReversData = repmat( flipChannelsDataMean , size(SplicedData,1) ,1 );
                    %Subtract polarity reversal channels data from other channels (and self, technically)
                    SplicedData = SplicedData - polReversData;
                    %%SplicedData(polReversalChan:polReversalChan+1,:) = NaN; 
                        %Note: It may be possible to not remove these channels, since we are dealing with an average, not the raw perfect data from one channel
                else
                    ['## Warning: Polarity reversal occurred in last channel, thus averaging cannot occur ##']
                        %#Note: It's probably not possible for the calibration script to give this situation but whatever
                    flipChannelsData = SplicedData(polReversalChan,:); %"Take the polarity flip channel"
                    flipChannelsDataMean = nanmean(flipChannelsData,1); %Should just be the same
                    polReversData = repmat( flipChannelsDataMean , size(SplicedData,1) ,1 );
                    %Subtract polarity reversal channel data from other channels (and self, technically)
                    SplicedData = SplicedData - polReversData;
                    SplicedData(polReversalChan,:) = NaN; %In this case it is probably still needed
                end

            else
                ['## Alert: Cannot reference without polarity reversal channel information ##']
                crash = yes
            end
            clear polReversData

        end
        
        if dontSaveProcessed ~= 1
            if ~isdir([ FolderName, filesep, 'SplicedData_', rerefIndex{rerefMode} ])
                mkdir([ FolderName, filesep, 'SplicedData_', rerefIndex{rerefMode} ]);
            end

            save_check = 0;
            while save_check ==0
                try
                    save([  FolderName filesep 'SplicedData_' rerefIndex{rerefMode} filesep 'SplicedData.mat'], 'SplicedData');
                    save_check =1;
                catch
                    warning('Error saving files. Trying again in 30 seconds.')
                    pause(30)
                    save_check = 0;
                end
            end
        end
 
        %Correct splicedEpoch
        %splicedEpochCorrected = splicedEpoch';
        splicedEpochCorrected = splicedEpoch; %Not transposed

        %Check for NaN in either LFP or behav timescales
        if nansum( isnan(splicedEpochCorrected) ) ~= 0
            disp(['-# Warning: ',num2str(nansum( isnan(splicedEpochCorrected) ) ),' NaNs detected in LFP timescale; Correcting with ZOH #-'])
            nanList = find( isnan(splicedEpochCorrected ) );
            for i = 1:size(nanList,1)
                splicedEpochCorrected( nanList(i) ) = splicedEpochCorrected( find( isnan( splicedEpochCorrected(1:nanList(i)) ) ~= 1 , 1, 'last') ); %Find last non-nan value and use that
            end
        end
        %Check for zero-time intervals
        if nansum( diff( splicedEpochCorrected ) == 0 ) > 0
            disp(['-# Warning: ',num2str(nansum( diff( splicedEpochCorrected ) == 0 )),' zero-sum time differences detected in LFP timescale; Correcting in a bootleg manner #-'])
            zeroList = find( diff( splicedEpochCorrected ) == 0 );
            for i = 1:size( zeroList , 1 )
                nextNonZero = find( diff(splicedEpochCorrected( zeroList(i) : end )) ~= 0 , 1, 'first' )  + zeroList(i) - 1; %Leaning heavily on self-calculated inter-frame interval to find next instance of non-zero interval
                splicedEpochCorrected( zeroList(i) ) =  splicedEpochCorrected( zeroList(i) ) - ( 0.5 * ( splicedEpochCorrected( nextNonZero + 1 ) - splicedEpochCorrected( nextNonZero ) ) ); %Subtract half an interval
                    %Note: This is a bootleg system that is theoretically weak to massive inter-frame variability, but it's simpler than other methods
            end    
        end
        
        %--------------
        
        %Calculate (dynamic) chans of interest
        chansOfInterestActive = [];
        for chan = 1:size( chansOfInterest,2 )
            eval([ 'chansOfInterestActive(',num2str(chan),') = ', chansOfInterest{chan},';' ]);
            %QA
            if chansOfInterestActive(chan) > size(SplicedData,1)
                ['-# Caution: Channel request "',chansOfInterest{chan},'" exceeds data channels by ',num2str(chansOfInterestActive(chan) - size(SplicedData,1)),'; Forcing size correctness #-']
                chansOfInterestActive(chan) = size(SplicedData,1);
            elseif chansOfInterestActive(chan) < 1
                ['-# Caution: Channel request "',chansOfInterest{chan},'" is sub 1st channel by ',num2str( chansOfInterestActive(chan) ),'; Forcing to 1 #-']
                chansOfInterestActive(chan) = 1;
            end
        end
        
        %--------------
        
        if modernData == 1
            disp(['-- Acquiring red light information --'])
            SplicedRedLight = SplicedStim(4,:);
            temp = nanstd( SplicedRedLight(1: EEG.PDec.sourceFramerates.Wave ) ); %Calculate prospective flat noise level from first second of data
            if nanstd( SplicedRedLight ) > 4*temp %"STD of whole thing is more than 4x STD of 1s of data"
                SplicedRedLightBin = nan(1,size(SplicedRedLight,2));
                temp = nanmean(SplicedRedLight);
                SplicedRedLightBin( SplicedRedLight >= temp ) = 1;
                SplicedRedLightBin( SplicedRedLight < temp ) = 0;
            else
                ['#- No detectable differences between red light data and baseline noise level -#']
            end
            
            %Cleaning
            %figure
            %hold on
            %plot(SplicedRedLightBin)
            try
                redLightRegime = [matStruct.ancillary.flagParamSaveStruct.redDur ; matStruct.ancillary.flagParamSaveStruct.redStatus]; %Collect the presented red light regime
                %temp = bwlabel(SplicedRedLightBin);
                redLightMinBreakSize = nanmin( redLightRegime(1,redLightRegime(2,:) == 0 ) ); %Finds the minimum off time in the regime
                redLightMinBlockSize = nanmin( redLightRegime(1,redLightRegime(2,:) == 1 ) ); %Finds the minimum off time in the regime
                %Remove sub-size breaks and blocks in a looping manner
                    %Note: This will probably be an impediment for dealing with TDT crashes, which may cause 'legitimate' blocks of very short or long duration
                subSizeBreaksFound = -1;
                subSizeBlocksFound = -1;
                repIter = 1; %Used to prevent infiniloop
                while subSizeBreaksFound ~= 0 | subSizeBlocksFound ~= 0
                    temp = bwlabel(SplicedRedLightBin); %Finds contiguous stimulus blocks
                    invTemp = bwlabel(~SplicedRedLightBin);
                    %Check for sub-size breaks
                    subSizeBreaksFound = 0;
                    for i = 1:nanmax(unique(invTemp))
                        if nansum(invTemp == i) < redLightMinBreakSize*0.95
                            SplicedRedLightBin( invTemp == i ) = 1;
                            subSizeBreaksFound = subSizeBreaksFound + 1;
                        end
                    end

                    %Recalculate bwlabels
                    temp = bwlabel(SplicedRedLightBin); %Finds contiguous stimulus blocks
                    invTemp = bwlabel(~SplicedRedLightBin);

                    %Check for sub-size blocks
                    subSizeBlocksFound = 0;
                    for i = 1:nanmax(unique(temp))
                        %if nansum(allSignalStimBlocksRaw == i) < breakArtefactToleranceSize
                        if nansum(temp == i) < redLightMinBlockSize*0.95
                            SplicedRedLightBin( temp == i ) = 0;
                            subSizeBlocksFound = subSizeBlocksFound + 1;
                        end
                    end

                    %Report
                    disp(['# Loop ',num2str(repIter),' - Sub-size breaks: ',num2str(subSizeBreaksFound),' - Sub-size blocks: ',num2str(subSizeBlocksFound),' #'])
                    repIter = repIter + 1;
                end
                %plot(normalize(temp))
                %plot(SplicedRedLightBin)
                
            catch
                ['-# Caution: Could not obtain red light regime from ancillary data #-']
            end
            %Post-cleaning QA
            if abs( nanmax(unique(bwlabel(SplicedRedLightBin))) - (EEG.epoch_end - EEG.epoch_start) / nansum(redLightRegime(1,:)) ) > (EEG.epoch_end - EEG.epoch_start) / nansum(redLightRegime(1,:)) * 0.2
                ['-# Caution: Red light blocks may have been lost (or gained) #-']
            end 
        end
        
        %Integrated data preparation
        if integMode == 1
            behavCorrected = behavLoad.overVar.railStruct.sleepRail; 
            %Starting (sleepRail):
                %(Right,Left,Prob) "%Col 1 - Sleep binary, Col 2 - Posix, Col 3 - PE binary, Col 4/6/8 - Perio. in right/left/prob binary, Col 5/7/9 - Freq. pos. of perio. in right/left/prob, Col 10 - Time since 5PM, Col 11 - Inter-frame interval", 
                %(Prob) "%Col 1 - Sleep binary, Col 2 - Posix, Col 3 - PE binary, Col 4 - Perio. in prob binary, Col 5 - Freq. pos. of perio. in prob, Col 6 - Time since 5PM, Col 7 - Inter-frame interval",
            %Ending (sleepRail + new cols):
                %(Right, Left, Prob) Col 1:11 - ditto, ...
                %Red
                %(Prob) Col 1:7 - ditto, Col 8 - BehavCorrected index, Col 9/10 - Time since/to start/end of behav bout, Col 11,12 - PE point indicator(Pre interp),PE point indicator(Post interp), Col 13 - Ac/Inac data, Col 14 - Red light binary, Col 15/16 - Red light bwlabel( and inv, respectively), Col 17 - behavInterp index
                %Not red
                %(Prob) Col 1:7 - ditto, Col 8 - BehavCorrected index, Col 9/10 - Time since/to start/end of behav bout, Col 11,12 - PE point indicator(Pre interp),PE point indicator(Post interp), Col 13 - Raw Ac/Inac data, Col 14 - alt event detection point indicator, Col 15 - alt event detection full indices,  Col 16 - PE original, Col 17 - behavInterp index
                    %Note : Two cols for PE point indicator because interp broadens points
                    
            behavCorrectedLabels = [{'sleepBinary'},{'posix'},{'peBinary'}];
            %Dynamic rail fields
            railFiels = fieldnames( behavLoad.overVar.railStruct );
            antPerioNames = []; %Will be used to store all process types where perio ("ant" is a misnomer nowadays) was calculated 
            for rap = 1:size(railFiels,1)
                if isempty(strfind(railFiels{rap},'sleepRailZTAntPerioBinned_')) ~= 1
                	antPerioNames{size(antPerioNames,1)+1,1} = railFiels{rap}( strfind(railFiels{rap},'_')+1:end );
                    behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = strcat(antPerioNames{size(antPerioNames,1),1},'PerioPresence'); %Note subtly different index to above
                    behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = strcat(antPerioNames{size(antPerioNames,1),1},'PerioFreq'); %Note subtly different index to above
                end
            end
            behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'TimeSince5PM';
            behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'InterFrameInterval';
            
            if nansum( isnan(behavCorrected(:,2)) ) ~= 0
                disp(['-# Warning: NaNs detected in Behav timescale; Correcting with ZOH #-'])
                nanList = find( isnan( behavCorrected(:,2) ) );
                for i = 1:size(nanList,1)
                    %behavLoad.overVar.railStruct.sleepRail( nanList(i) ,:) = behavLoad.overVar.railStruct.sleepRail( find( isnan( behavLoad.overVar.railStruct.sleepRail(1:nanList(i),2) ) ~= 1 , 1, 'last') , : ); %Find last non-nan value and use that
                    behavCorrected( nanList(i) , [1,3:size(behavCorrected,2)] ) = behavCorrected( nanList(i)-1 , [1,3:size(behavCorrected,2)] ); %Start by replacing entire row with previous element
                    if nansum( isnan( behavCorrected( nanList(i) : end , 2 ) ) ~= 1 ) > 0 %"At least one non-NaN element before end of data"
                        nextNonNaN = find( isnan(behavCorrected( nanList(i) : end , 2 )) ~= 1, 1 , 'first' ) + nanList(i) - 1; %Find next non-NaN element
                        behavCorrected( nanList(i) , 2 ) = behavCorrected( nanList(i)-1 , 2 ) + ( ( behavCorrected( nextNonNaN , 2 ) - behavCorrected( nanList(i)-1 , 2 ) ) / ( nextNonNaN - nanList(i) ) ); %Bootleg rolling interpolation to next non-NaN
                    else %"No non-NaN elements before end of data"
                        behavCorrected( nanList(i) , 2 ) = behavCorrected( nanList(i)-1 , 2 ) + behavCorrected( nanList(i)-1 , end ); %Use previous inter-frame duration to extrapolate time for this frame
                    end
                end
            end
            if nansum( diff( behavCorrected(:,2) ) == 0 ) > 0
                disp(['-# Warning: Zero-sum time differences detected in Behav timescale; Correcting in a bootleg manner #-'])
                zeroList = find( diff( behavCorrected(:,2) ) == 0 );
                for i = 1:size( zeroList , 1 )
                    nextNonZero = find( behavCorrected( zeroList(i) : end , end ) ~= 0 , 1, 'first' ) + zeroList(i) - 1; %Leaning heavily on self-calculated inter-frame interval to find next instance of non-zero interval
                    behavCorrected( zeroList(i) , 2 ) =  behavCorrected( zeroList(i) , 2 ) - ( 0.5 * behavCorrected( nextNonZero , end) ); %Subtract half an interval
                        %Note: This is a bootleg system that is theoretically weak to massive inter-frame variability, but it's simpler than other methods
                end    
            end

            %Correct behav epoch times
            disp(['-- Correcting behavioural epoch times for timezone --'])
            tic
            temp = datetime(behavCorrected(1,2) , 'ConvertFrom', 'posixtime', 'TimeZone', '+10:00');
            disp([ 'Starting behav epoch time: ', datestr(temp) ])
            %Datestr/Datetime based system (Fails to capture milliseconds)
            %{
            behavCorrected(:,2) = posixtime(datetime(datestr( datetime(behavCorrected(:,2) , 'ConvertFrom', 'posixtime', 'TimeZone', 'UTC') ),'TimeZone', '+10:00'));
            %posixtime(datetime(datestr( datetime(behavCorrected(1,2) , 'ConvertFrom', 'posixtime', 'TimeZone', 'UTC') , 'yyyy-mm-dd HH:MM:SS:FFF' ), 'InputFormat', 'yyyy-mm-dd HH:MM:SS:FFF' ,'TimeZone', '+10:00'))
            %datestr( datetime(behavCorrected(1,2) , 'ConvertFrom', 'posixtime', 'TimeZone', 'UTC') , 'yyyy-mm-dd HH:MM:SS:FFF' )
            %}
            %Bootiest of bootleg solutions (Valid as long as data recorded in Brisbane and DST never implemented)
            behavCorrected(:,2) = behavCorrected(:,2) - 10*60*60;
            temp = datetime(behavCorrected(1,2) , 'ConvertFrom', 'posixtime', 'TimeZone', '+10:00');
            disp([ 'Corrected behav epoch time: ', datestr(temp) ])
            disp(['-- Behavioural epoch times corrected in ',num2str(toc),'s --'])

            %QA now that times are 'corrected'
            if abs( splicedEpochCorrected(1) - behavCorrected(1,2) ) > 60*60 %"Start times dissimilar by more than an hour"
                ['## Alert: Dissimilar start times detected; Timezone correction may have been misapplied or failed ##']
                crash = yes
            end

            %Tack on index indicator to behav
            behavCorrected( : , size(behavCorrected,2)+1 ) = [1:size(behavCorrected,1)];
            behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'behavCorrectedIndex';
            
            %Separate bouts into 5 minute bins a la Lucy
            disp(['-- Separating inactivity and activity bouts into durations --'])
                
            boutDurCol = size(behavCorrected,2)+1;
            behavCorrected(:,boutDurCol:boutDurCol+1) = NaN;
            behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'activityDur';
            behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'inactivityDur';
                        
            typeIndex = [-1,1;...
                          0,1]; %Row 1 specifies what the diff should be to detect this bout type, row 2 is the behavCorrected column 1 value that indicates this bout type is occurring
            typeNameIndex = [{'Activity'},{'Inactivity'}];
            
            for side = 1:size(typeIndex,2)
                disp([typeNameIndex{side},' bouts:'])
                %boutOnsets = find( diff(behavCorrected(:,1)) == 1 )+1; %Find sleep bout onsets
                boutOnsets = find( diff(behavCorrected(:,1)) == typeIndex(1,side) )+1; %Find sleep bout onsets
                if behavCorrected(1,1) == typeIndex(2,side) %Catches the first bout, whatever it may be (Since there is no diff for the first bout)
                    boutOnsets = [1; boutOnsets];
                end
                for bout = 1:size(boutOnsets,1) 
                    row = boutOnsets(bout);
                    boutStartTime = behavCorrected(row,2);
                    while row <= size(behavCorrected,1) & behavCorrected(row,1) == typeIndex(2,side) 
                        behavCorrected(row,boutDurCol) = behavCorrected(row,2) - boutStartTime; %Calculate time from start of bout (s)
                        row = row + 1;
                    end
                    behavCorrected( boutOnsets(bout) : row-1 , boutDurCol + 1 ) = behavCorrected( boutOnsets(bout) : row-1 , boutDurCol ) - behavCorrected( row-1 , boutDurCol ); %Tack on post-calculated time till end of bout
                    disp([typeNameIndex{side},' bout ',num2str(bout),' - ',num2str(row - boutOnsets(bout)),' frames, ',num2str( behavCorrected(row - 1,boutDurCol) - behavCorrected(boutOnsets(bout) ,boutDurCol) ),'s (Start idx: ',num2str(boutOnsets(bout)),')'])
                end
            end
            
            %Tack on PE point indicators (from allPERail)
            if size(behavCorrected,1) == size(behavLoad.overAllPE.allPEStruct.allPERail,1)
                behavCorrected( : , size(behavCorrected,2)+1 ) = behavLoad.overAllPE.allPEStruct.allPERail(:,2); %Col /11
                    % "%Col 2 - All detected PE locations"
                behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'allPELocations';
                behavCorrected( : , size(behavCorrected,2)+1 ) = NaN; %Preparing this column to be filled post-interp (Col /12)
                behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'allPELocations_postInterp';
            else
                ['-# Alert: Behavioural rail and PE rail size mismatch #-']
                crash = yes
            end
            
            %And raw activity, if data existing
            if isfield( behavLoad.overVar, 'overGlob' ) == 1 && ( isfield(behavLoad.overVar.overGlob, 'acRaw') == 1 || isfield(behavLoad.overVar.overGlob, 'tempRaw') == 1 )
                if isfield(behavLoad.overVar.overGlob, 'acRaw') == 1
                    acFiel = 'acRaw';
                elseif isfield(behavLoad.overVar.overGlob, 'tempRaw') == 1
                    acFiel = 'tempRaw';
                end
                if size(behavCorrected,1) == size(behavLoad.overVar.overGlob.(acFiel),1)
                    behavCorrected( : , size(behavCorrected,2)+1 ) = behavLoad.overVar.overGlob.(acFiel);  %Col /13
                    %behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'rawActivity';
                else
                    ['-# Alert: Behavioural rail and activity data size mismatch #-']
                    crash = yes
                end
            else
                behavCorrected( : , size(behavCorrected,2)+1 ) = nan(size(behavCorrected,1),1);
                ['-# Caution: Raw activity data missing #-']
            end
            behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'rawActivity';
            
            %And altStruct data, if data existing
            if isfield( behavLoad, 'overAllPE' ) == 1 && isfield(behavLoad.overAllPE, 'altStruct') == 1 
                behavCorrected( : , size(behavCorrected,2)+1 ) = 0;
                %behavCorrected( behavLoad.overAllPE.altStruct.probInds , size(behavCorrected,2) ) = 1; %Col /14
                behavCorrected( behavLoad.overAllPE.altStruct.probInds , size(behavCorrected,2) ) = 1;
                behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'altStructEventsPoint';
                if isfield(behavLoad.overAllPE.altStruct,'probIndsAll') == 1
                    behavCorrected( : , size(behavCorrected,2)+1 ) = 0; %Col 15
                    altFullInds = reshape(behavLoad.overAllPE.altStruct.probIndsAll',[],1);
                    altFullInds( isnan(altFullInds) == 1 ) = [];
                    %QA
                    if nanmax(altFullInds) > size(behavCorrected,1)
                        ['## Alert: Integ alt detection data size mismatch with rail ##']
                        crash = yes
                    end
                    behavCorrected( altFullInds , size(behavCorrected,2) ) = 1;
                    behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'altStructEventsFull';
                end
            end
            
            %Expand PE binary based on W
            if isfield(behavLoad.overAllPE.allPEStruct,'allW') == 1
                allLocations = behavLoad.overAllPE.allPEStruct.allLOCS; %Note that allLOCS/LOCS is the original source of PE binary in the PE rail as well
                allWidths = behavLoad.overAllPE.allPEStruct.allW; %ALLMIND Welcomes You
                LOCSPAN = nan( size(behavCorrected,1) , 1);
                for i = 1:size(allLocations,1)
                    coords = floor([ allLocations(i)-(allWidths(i)*0.5) : allLocations(i)+(allWidths(i)*0.5) ]);
                    coords( coords < 1 ) = []; 
                    coords( coords > size(behavCorrected,1) ) = []; 
                    LOCSPAN( coords ) = 1;
                end
                behavCorrected( : , size(behavCorrected,2)+1 ) = 0; %Col 16
                behavCorrected( LOCSPAN == 1 , size(behavCorrected,2) ) = 1;
                behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'peBinaryFull';
            end

            %Add in frame count till next PE (Original)
            peBinaryCol = find(contains(behavCorrectedLabels,'peBinaryFull'));
            %if isequal(behavCorrectedLabels{16},'peBinaryFull') == 1 %Note: Would be smarter to iterate and find this col, but no time
            if ~isempty( peBinaryCol ) %Note: Would be smarter to iterate and find this col, but no time
                %blorg = nan(size(behavCorrected,1),1);
                behavCorrected( : , size(behavCorrected,2)+1 ) = nan(size(behavCorrected,1),1); %Col 17
                behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'peBinaryFramesFromLast';
                behavCorrected( : , size(behavCorrected,2)+1 ) = nan(size(behavCorrected,1),1); %Col 18
                behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'peBinaryFramesTillNext';
                %peLabel = bwlabel(~behavCorrected(:,16));
                peLabel = bwlabel(~behavCorrected(:,peBinaryCol));
                for i = 1:nanmax(peLabel)
                    behavCorrected( peLabel == i , size(behavCorrected,2)-1 ) = [1:nansum(peLabel == i)];
                    behavCorrected( peLabel == i , size(behavCorrected,2) ) = [nansum(peLabel == i):-1:1];
                end
            end
            
            %Add in frame count till next alt event (and alt event identity, if applicable)
            altStructCol = find(contains(behavCorrectedLabels,'altStructEventsFull'));
            %if isequal(behavCorrectedLabels{15},'altStructEventsFull') == 1 %Note: Would be smarter to iterate and find this col, but no time
            if ~isempty(altStructCol) %Note: Would be smarter to iterate and find this col, but no time
                %blorg = nan(size(behavCorrected,1),1);
                behavCorrected( : , size(behavCorrected,2)+1 ) = nan(size(behavCorrected,1),1); %Col 19
                behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'altFramesFromLast';
                behavCorrected( : , size(behavCorrected,2)+1 ) = nan(size(behavCorrected,1),1); %Col 20
                behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'altFramesTillNext';
                %altLabel = bwlabel(~behavCorrected(:,15));
                altLabel = bwlabel(~behavCorrected(:,altStructCol));
                for i = 1:nanmax(altLabel)
                    behavCorrected( altLabel == i , size(behavCorrected,2)-1 ) = [1:nansum(altLabel == i)];
                    behavCorrected( altLabel == i , size(behavCorrected,2) ) = [nansum(altLabel == i):-1:1];
                end
                %Recapitulate identities as done in SASIFRAS
                if isfield(behavLoad.overAllPE.altStruct,'overAltAng')
                    altInds = behavLoad.overAllPE.altStruct.probInds;
                    altIdents = zeros( size(altInds) );
                    altIndsFull = [];
                    for altI = 1:size(behavLoad.overAllPE.altStruct.overAltAng,2)
                        thisAng = behavLoad.overAllPE.altStruct.overAltAng{altI};
                        coords = behavLoad.overAllPE.altStruct.probAngMeds >= thisAng(1) & behavLoad.overAllPE.altStruct.probAngMeds <= thisAng(2);
                            %Note: overAltAngGroups do not cover all cases, and currently 0 is used for alt events that do not match either
                                %These are registered as point values, but not full values
                        altIdents( coords ) = altI;
                        altIndsFull{altI} = reshape( behavLoad.overAllPE.altStruct.probIndsAll( coords, : )' , [], 1);
                        altIndsFull{altI}( isnan(altIndsFull{altI}) ) = [];
                    end
                    behavCorrected( : , size(behavCorrected,2)+1 ) = NaN;
                    behavCorrected( altInds , size(behavCorrected,2) ) = altIdents; %Note column index, due to NaN
                    behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'altIdentityPoint';
                    thisCol = size(behavCorrected,2)+1;
                    behavCorrected( : , thisCol ) = NaN;
                    for altI = 1:size(altIndsFull,2)
                        behavCorrected( altIndsFull{altI}, thisCol ) = altI;
                    end
                    behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'altIdentityFull';
                end

            end
            
            %anexchos
            %Append prob raw data for usefulness
            if isfield(behavLoad.overVar, 'probMetric')
                behavCorrected( : , size(behavCorrected,2)+1 ) = behavLoad.overVar.probMetric; %Will crash if async
                behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'probMetric';
            end
            
            %Old, non-dynamic system
            %{
            inacDurCol = size(behavCorrected,2)+1;
            behavCorrected(:,boutDurCol) = NaN;
            inacBoutOnsets = find( diff(behavCorrected(:,1)) == 1 )+1; %Find sleep bout onsets
            for inac = 1:size(inacBoutOnsets,1) 
                row = inacBoutOnsets(inac);
                inacStartTime = behavCorrected(row,2);
                while behavCorrected(row,1) == 1 
                    behavCorrected(row,boutDurCol) = behavCorrected(row,2) - inacStartTime;
                    row = row + 1;
                end
                disp(['Inactivity bout ',num2str(inac),' - ',num2str(row - inacBoutOnsets(inac)),' frames, ',num2str( behavCorrected(row - 1,inacDurCol) - behavCorrected(inacBoutOnsets(inac) ,inacDurCol) ),'s'])
            end
            %}
            
            %Align LFP and behav timescales
            tic

            tempLFPEpoch = [ splicedEpochCorrected' , nan(size(splicedEpochCorrected',1),1)];
            %tempBehavEpoch = flip( behavCorrected(:,1:2) , 2);

            %Interp1 method
            %behavInterp = interp1(tempBehavEpoch(:,1),tempBehavEpoch(:,2),tempLFPEpoch(:,1), 'previous');
            behavInterp = interp1(behavCorrected(:,2),behavCorrected(:,:),tempLFPEpoch(:,1), 'previous');
                %Note: Any rows of behavCorrected that precede splicedEpochCorrected will be removed
            clear tempLFPEpoch

            disp(['-- Behavioural times interpolated in ',num2str(toc),'s --'])
            
            %Convert now-broadened PE LOCs back into point-markers
            %behavInterp( find( [0;diff(behavInterp(:, 11 ))] == 1 ) , 12 ) = 1;
            behavInterp( find( [0;diff(behavInterp(:, size(behavInterp,2)-2 ))] == 1 ) , size(behavInterp,2)-1 ) = 1; %Now less vulnerable to different processList sizes! 
                %Works by finding onset of all post-interpolated LOCs and writing those as point-markers
                    %Note: In theory this shifts PE onset forwards by half the number of expansion frames between
                    %behav and LFP data (e.g. 10 if behav data was 30FPS and LFP was 300 samples/s),
                    %but it seems like a minor issue
                    %Also, some PEs may be lost, but this qualitatively seems in the order of 1 in 1000 so eh
            
            %Add red light information
            if modernData == 1
                if length(behavInterp) ~= length(SplicedRedLightBin)
                    ['-# Caution: Red light information (SplicedStim) and behavInterp size do not match #-']
                    behavInterp(:,size(behavInterp,2)+1:size(behavInterp,2)+3) = NaN;
                else
                    behavInterp(:,size(behavInterp,2)+1) = SplicedRedLightBin;
                    behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'redLightBinary';
                    %Add data about red bout onset/offset
                    redBool = nan( 2, size(SplicedRedLightBin,2) );
                    redBool(1,:) = bwlabel( SplicedRedLightBin );
                    redBool(2,:) = bwlabel( ~SplicedRedLightBin );
                    %QA in case of starting high state
                    if SplicedRedLightBin(1) == 1
                        redBool(2, redBool(2,:) ~= 0) = redBool(2, redBool(2,:) ~= 0) + 1; %Force increase by 1
                    end
                    behavInterp(:,size(behavInterp,2)+1:size(behavInterp,2)+2) = redBool';
                    behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'redLightBool';
                    clear redBool
                end
            end
                    
            %Add post-interpolation indices
            behavInterp(:,size(behavInterp,2)+1) = [1:size(behavInterp,1)];
            behavCorrectedLabels{ size(behavCorrectedLabels,2)+1 } = 'postInterpIndex';

            overVar(IIDN).behavInterp = behavInterp;
            overVar(IIDN).behavCorrectedLabels = behavCorrectedLabels; %Might vary in columns by 1 with interp
            
            %hyperGroup QA
            if exist('colChecks') == 1
                for i = 1:size(colChecks,2)
                    if isequal( behavCorrectedLabels{colChecks{i}{1}} , colChecks{i}{2} ) ~= 1
                        ['-# Alert: Potential hyperGroup column desync with behavCorrected #-']
                        disp(['(Expected ',colChecks{i}{2},', received ',behavCorrectedLabels{colChecks{i}{1}},')'])
                        crash = yes
                    end
                end 
            end
            
            %liethis

        end
            
        %--------------
        
        %----------------------------------------------------------------
        
        if modernData == 1 %Capacity for red light analysis
            %{
            %(SplicedRedLightBin definition moved above behavCorrected/Interp for integration peurposes)
            SplicedRedLight = SplicedStim(4,:);
            temp = nanstd( SplicedRedLight(1: EEG.PDec.sourceFramerates.Wave ) ); %Calculate prospective flat noise level from first second of data
            if nanstd( SplicedRedLight ) > 4*temp %"STD of whole thing is more than 4x STD of 1s of data"
                SplicedRedLightBin = nan(1,size(SplicedRedLight,2));
                temp = nanmean(SplicedRedLight);
                SplicedRedLightBin( SplicedRedLight >= temp ) = 1;
                SplicedRedLightBin( SplicedRedLight < temp ) = 0;
            else
                ['#- No detectable differences between red light data and baseline noise level -#']
            end
            
            %Cleaning
            %figure
            %hold on
            %plot(SplicedRedLightBin)
            try
                redLightRegime = [matStruct.ancillary.flagParamSaveStruct.redDur ; matStruct.ancillary.flagParamSaveStruct.redStatus]; %Collect the presented red light regime
                %temp = bwlabel(SplicedRedLightBin);
                redLightMinBreakSize = nanmin( redLightRegime(1,redLightRegime(2,:) == 0 ) ); %Finds the minimum off time in the regime
                redLightMinBlockSize = nanmin( redLightRegime(1,redLightRegime(2,:) == 1 ) ); %Finds the minimum off time in the regime
                %Remove sub-size breaks and blocks in a looping manner
                    %Note: This will probably be an impediment for dealing with TDT crashes, which may cause 'legitimate' blocks of very short or long duration
                subSizeBreaksFound = -1;
                subSizeBlocksFound = -1;
                repIter = 1; %Used to prevent infiniloop
                while subSizeBreaksFound ~= 0 | subSizeBlocksFound ~= 0
                    temp = bwlabel(SplicedRedLightBin); %Finds contiguous stimulus blocks
                    invTemp = bwlabel(~SplicedRedLightBin);
                    %Check for sub-size breaks
                    subSizeBreaksFound = 0;
                    for i = 1:nanmax(unique(invTemp))
                        if nansum(invTemp == i) < redLightMinBreakSize*0.95
                            SplicedRedLightBin( invTemp == i ) = 1;
                            subSizeBreaksFound = subSizeBreaksFound + 1;
                        end
                    end

                    %Recalculate bwlabels
                    temp = bwlabel(SplicedRedLightBin); %Finds contiguous stimulus blocks
                    invTemp = bwlabel(~SplicedRedLightBin);

                    %Check for sub-size blocks
                    subSizeBlocksFound = 0;
                    for i = 1:nanmax(unique(temp))
                        %if nansum(allSignalStimBlocksRaw == i) < breakArtefactToleranceSize
                        if nansum(temp == i) < redLightMinBlockSize*0.95
                            SplicedRedLightBin( temp == i ) = 0;
                            subSizeBlocksFound = subSizeBlocksFound + 1;
                        end
                    end

                    %Report
                    disp(['# Loop ',num2str(repIter),' - Sub-size breaks: ',num2str(subSizeBreaksFound),' - Sub-size blocks: ',num2str(subSizeBlocksFound),' #'])
                    repIter = repIter + 1;
                end
                %plot(normalize(temp))
                %plot(SplicedRedLightBin)
                
            catch
                ['-# Caution: Could not obtain red light regime from ancillary data #-']
            end
            %Post-cleaning QA
            if abs( nanmax(unique(bwlabel(SplicedRedLightBin))) - (EEG.epoch_end - EEG.epoch_start) / nansum(redLightRegime(1,:)) ) > (EEG.epoch_end - EEG.epoch_start) / nansum(redLightRegime(1,:)) * 0.2
                ['-# Caution: Red light blocks may have been lost (or gained) #-']
            end
            %}
            
            if exist('SplicedRedLightBin') == 1 && integMode == 1
                redCoords = [{SplicedRedLightBin == 1},{SplicedRedLightBin == 0}]; %On and off, respectively
                %temp = [ nansum( behavInterp( SplicedRedLightBin == 1 , 1 )  ) , nansum( behavInterp( SplicedRedLightBin == 0 , 1 )  ) ];
                %temp2 = [ nansum( SplicedRedLightBin == 1 ) , nansum( SplicedRedLightBin == 0 ) ];
                temp = [ nansum( behavInterp( redCoords{1} , 1 )  ) , nansum( behavInterp( redCoords{2} , 1 )  ) ];
                temp2 = [ nansum( redCoords{1} ) , nansum( redCoords{2} ) ];
                
                %Plot red schema
                figure
                hold on
                plot( SplicedRedLightBin , 'r' )
                plot( (behavInterp(:,3)*0.5)+0.25 , 'g' )
                plot( (-behavInterp(:,1)*0.5)-0.25 , 'b' ) %Note that inversion means that high is activity
                ylim([-1,2])
                title(['Red experimental schema (w/ PE binary and sleep)'])
                set(gcf,'Name','Red schema')
                
                %PRepare
                xlabs = [{'Red light On'},{'Red light Off'}];
                
                %Total
                figStr = [];
                figure
                subplot(2,1,1)
                bar(temp)
                xticklabels(xlabs)
                ylabel(['Total # of frames'])
                title(['Total sleep frames during red light conditions'])
                subplot(2,1,2)
                bar(temp2)
                xticklabels(xlabs)
                ylabel(['Total # of frames'])
                title(['Total red light and no red light frames, respectively'])
                set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - RedLightTotal']);
                thisFigName = 'RedLightSleepTotal';
                %###########
                %Save figure
                if saveFigs == 1
                    try
                        savePlot(saveName,thisFigName,figStr)
                    catch 
                        ['-# Alert: Failure to save plot #-']
                    end
                end
                %###########
                
                tempNorm = [ nansum( behavInterp( redCoords{1} , 1 )  ) / nansum( redCoords{1} ) , nansum( behavInterp( redCoords{2} , 1 )  ) / nansum( redCoords{2} ) ];
                temp2Norm = [nansum( redCoords{1} ) , nansum( redCoords{2} )]/size(SplicedRedLightBin,2);
                
                %Total
                figStr = [];
                figure
                subplot(2,1,1)
                bar(tempNorm)
                xticklabels(xlabs)
                ylabel(['Proportion of condition'])
                title(['Proportion of time asleep during red light conditions'])
                subplot(2,1,2)
                bar(temp2Norm)
                xticklabels(xlabs)
                ylabel(['Proportion of time'])
                title(['Red vs not red proportion of whole time'])
                set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - RedLightNorm']);
                thisFigName = 'RedLightSleepNorm';
                %###########
                %Save figure
                if saveFigs == 1
                    try
                        savePlot(saveName,thisFigName,figStr)
                    catch 
                        ['-# Alert: Failure to save plot #-']
                    end
                end
                %###########
                
                %Calculate stats-capable plot
                redBool(1,:) = bwlabel( SplicedRedLightBin );
                redBool(2,:) = bwlabel( ~SplicedRedLightBin );
                redBehaVals = [];
                for state = 1:size(redBool,1)
                    for i = 1:nanmax( redBool(state,:) )
                        redBehaVals( state , i ) = nansum( behavInterp( redBool(state,:) == i , 1 ) ) / nansum( redBool(state,:) == i );
                    end
                end
                redBehaValsNoZero = redBehaVals;
                redBehaValsNoZero( redBehaValsNoZero == 0 ) = NaN;
                redBehaMean = [ nanmean( redBehaVals , 2 ) , nanmean( redBehaValsNoZero , 2 ) ];
                redBehaSTD = [ nanstd( redBehaVals , [] , 2 ) , nanstd( redBehaValsNoZero , [] , 2 ) ];
                figure
                subplot(1,2,1)
                barwitherr( redBehaSTD(:,1) , redBehaMean(:,1) )
                hold on
                %scatter( [ repmat([1],1,size(redBehaVals,2)) , repmat([2],1,size(redBehaVals,2)) ] , [ redBehaVals(1,:) , redBehaVals(2,:) ] )
                scatter( [ repmat([1],1,size(redBehaVals,2))+(0.2*(rand(1,size(redBehaVals,2))-0.5)) , repmat([2],1,size(redBehaVals,2))+(0.2*(rand(1,size(redBehaVals,2))-0.5)) ] , [ redBehaVals(1,:) , redBehaVals(2,:) ] )
                xticklabels([{'Red on'},{'Red off'}])
                ylabel(['Average proportion of state asleep'])
                [h,p] = ttest2( redBehaVals(1,:) , redBehaVals(2,:) );
                title(['Average sleep red on vs off (p=',num2str(p),')'])
                subplot(1,2,2)
                barwitherr( redBehaSTD(:,2) , redBehaMean(:,2) )
                hold on
                %scatter( [ repmat([1],1,size(redBehaValsNoZero,2)) , repmat([2],1,size(redBehaValsNoZero,2)) ] , [ redBehaValsNoZero(1,:) , redBehaValsNoZero(2,:) ] )
                scatter( [ repmat([1],1,size(redBehaValsNoZero,2))+(0.2*(rand(1,size(redBehaValsNoZero,2))-0.5)) , repmat([2],1,size(redBehaValsNoZero,2))+(0.2*(rand(1,size(redBehaValsNoZero,2))-0.5)) ] , [ redBehaValsNoZero(1,:) , redBehaValsNoZero(2,:) ] )
                xticklabels([{'Red on'},{'Red off'}]);
                ylabel(['Average proportion of sleep explainable by state']);
                [h,p] = ttest2( redBehaValsNoZero(1,:) , redBehaValsNoZero(2,:) );
                title(['Average (non-zero) proportion of state spent asleep (p=',num2str(p),')']);
                    %These two graphs are very similar, except that zeroes are removed in the second
                        %Technically this improves the noise level by excluding times when no sleep whatsoever was occurring
                        %(Which may be a fallacy potentially)
                clear redBool %"RedBull"
                
                %---------------------------------------------------------------------------------------------------------
                
                %Red FFT
                rIndex = [{'k'},{'r'}];
                redViewWindow = [0 , 15]; %Hardcoded cos f1 not calculated yet
                superSpec = [];
                superSpace = [];
                superAs = [];
                for redSide = 0:1
                    temp = SplicedData( : , SplicedRedLightBin == redSide );
                    thisPlotColour = rIndex{redSide+1};

                    %blirg = transpose( SplicedData(1,:) );
                    temp = transpose( temp );
                    tempFFT = fft(temp, [], 1);
                    specTemp = 2 * (1/resampleFreq)^2 / (length(temp)/resampleFreq) * tempFFT.*conj(tempFFT);
                    specTemp = specTemp(1:length(specTemp)/2+1,:);
                    if normaliseRedFFT == 1
                        for chanInd = 1:size(specTemp,2)
                            specTemp(:,chanInd) = specTemp(:,chanInd) ./ nanmax( specTemp(:,chanInd) );
                        end
                    end
                    freqRes = 1 / max( length(temp)/resampleFreq );
                    nyqFreq = 1 / (1 / resampleFreq)/2;
                    tempF2 = (0:freqRes:nyqFreq);

                    [~, viewWindowFloorIndex] = min( abs(tempF2 - redViewWindow(1)) );
                    [~, viewWindowCeilIndex] = min( abs(tempF2 - redViewWindow(2)) );
                    standViewWindowRange = [ viewWindowFloorIndex : viewWindowCeilIndex ];
                    %blirgF2([viewWindowFloorIndex , viewWindowCeilIndex])
                    %length( standViewWindowRange )
                    baseViewWindowRange = standViewWindowRange;

                    tempSpace = linspace( redViewWindow(1), redViewWindow(2) , length( baseViewWindowRange ) );

                    %blirgData = specBlirg( baseViewWindowRange ); 
                    %blirgSpace = linspace( viewWindow(1), viewWindow(2) , size(blirgData,1) );

                    figure
                    %plot( blirgSpace, blirgData )
                    %hold on
                    for chanInd = 1:size( tempFFT , 2 )
                        subplot( 2 ,  ceil( size( tempFFT , 2 ) / 2 ) , chanInd )
                        plot( tempSpace, specTemp( baseViewWindowRange , chanInd ) , thisPlotColour )
                        if normaliseRedFFT == 0
                            ylim([0,1e5])
                        else
                            ylim([0,1e-3])
                        end
                    end
                    nameStr = ['FFT for red=',num2str(redSide)];
                    if normaliseRedFFT == 1
                        nameStr = [nameStr, ' (Self channel max normalised)'];
                    end
                    set(gcf,'Name',nameStr)

                    clear temp
                    
                    %superSpec{redSide + 1} = specBlirg;
                    superSpec{redSide + 1} = specTemp( baseViewWindowRange , : );
                    superSpace{redSide + 1} = tempSpace;
                    superAs(redSide+1) = size( tempSpace,2 );
                    clear specBlirg
                end
                
                %Comparative
                %Downterpolate larger case into smaller
                [~,downTargInd] = nanmin(superAs); %Find smallest A
                downTargs = [1:size( superSpace,2 )]; %Make list of all sides
                downTargsOrig = downTargs;
                downTargs(downTargs == downTargInd) = []; %Subtract smallest A element from list
                downSuperBlirg = [];
                for downInd = downTargs
                    downSuperBlirg{downInd} = interp1( superSpace{downInd} , superSpec{downInd} , superSpace{downTargInd} );
                end
                downSuperBlirg{downTargInd} = superSpec{downTargInd}; %Append down target
                downSuperSubtraction = [];
                for downInd = 1:size(downSuperBlirg,2) %Note: Different coords than immediately above
                    downSuperSubtraction{downInd} = downSuperBlirg{downInd} - superSpec{downTargInd};
                end
                    %Note: At least one of these elements will always be zeroes 
                %Plot
                figure
                a = 1;
                for downInd = downTargs
                    subplot( 1 , size(downTargs,2) , a ) %Note: downTargs size dimensionality not verified
                    plot( superSpace{downTargInd}, downSuperSubtraction{downInd}(:,1) )
                    %title(['Red ',num2str(downTargs(downInd)-1),' - Red ',num2str(downTargInd-1)]) %NOTE: ACCURACY NOT VERIFIED IN ANY CASE OTHER THAN TWO RED CONDITIONS
                    title(['Red ',num2str(downTargsOrig(downInd)-1),' - Red ',num2str(downTargInd-1)])
                end
                nameStr = ['Subtraction of red FFTs'];
                if normaliseRedFFT == 1
                    nameStr = [nameStr, ' (Self channel max normalised)'];
                end
                set(gcf,'Name',nameStr)
                
                %---------------------------------------------------------------------------------------------------------
                 
                %Compare prob activity during red/not red
                
                thisRedTime = [];
                thisRedPEs = [];
                for redSide = unique(SplicedRedLightBin)
                    thisRedTime(redSide+1) = nansum( SplicedRedLightBin == redSide );
                    %thisRedPEs(redSide+1) = nansum( behavInterp( SplicedRedLightBin == redSide , 3 ) );
                    thisRedPEs(redSide+1) = nansum( behavInterp( SplicedRedLightBin == redSide , 12 ) ); %Note: Sensitive to changes in column architecture of behavInterp
                end
                thisRedPEsNorm = ( thisRedPEs ./ ( thisRedTime / EEG.srate ) ) * 60; %Calculate PEs / min

                figure
                hold on
                for redSide = unique(SplicedRedLightBin)
                    h = bar( redSide , thisRedPEsNorm(redSide+1) );
                    set(h,'FaceColor',[1,0,0]*(redSide / nanmax(unique(SplicedRedLightBin)) ) );
                end
                xticks(unique(SplicedRedLightBin))
                xlabel(['Red light state'])
                ylabel(['PEs / min'])
                title(['Normalised PE rate during red states'])
                set(gcf, 'Name', [behavLoad.overVar.flyName,' - PEs not red/red'])
                
                %---------------------------------------------------------------------------------------------------------
                
                %Compare activity during red/not red
                if exist('acFiel') ~= 0 %isfield(behavLoad.overVar, 'acRaw') == 1
                    %behavAc = behavLoad.overVar.acRaw;
                    %Calculate
                    redAc = [];
                    redAcMean = [];
                    redAcSD = [];
                    redAcSEM = [];
                    highRed = [];
                    for redSide = unique(SplicedRedLightBin)
                        redAc{redSide+1} = behavInterp( SplicedRedLightBin == redSide ,13); %Col 13 - acRaw
                        redAcMean(redSide+1) = nanmean( redAc{redSide+1} );
                        redAcSD(redSide+1) = nanstd( redAc{redSide+1} );
                        redAcSEM(redSide+1) = nanstd( redAc{redSide+1} ) / sqrt( size( redAc{redSide+1} , 1 ) );
                        highRed(redSide+1) = nanmax(redAc{redSide+1});
                    end
                    
                    %Plot
                    figure
                    numRedStates = size( unique(SplicedRedLightBin) , 2 );
                    for redSide = unique(SplicedRedLightBin)
                        subplot( numRedStates , 3 , [ (redSide *3) + 1 : (redSide *3) + 2 ] )
                        plot( redAc{redSide+1} , 'Color', [1,0,0]*(redSide / nanmax(unique(SplicedRedLightBin)) ) )
                        title(['Activity during red = ',num2str(redSide)])
                        ylim([0,nanmax(highRed)])
                    end
                    subplot( numRedStates , 3 , [ 3 : 3 : ((numRedStates-1) *3) + 3 ] )
                    barwitherr( redAcSEM , redAcMean )
                    xticks(unique(SplicedRedLightBin)+1)
                    xticklabels(unique(SplicedRedLightBin))
                    title(['Red state mean +- SEM'])
                    set(gcf, 'Name', [behavLoad.overVar.flyName,' - activity not red/red'])
                    
                    %clear behavAc
                else
                    ['-# No activity field detected in behavLoad #-']
                end
                
                %---------------------------------------------------------------------------------------------------------

                %Compare sleep/wake PEs during not red/red
                stateRedTime = nan( nanmax(unique( behavInterp(:,1) )) , nanmax(unique( SplicedRedLightBin )) );
                stateRedPEs = nan( nanmax(unique( behavInterp(:,1) )) , nanmax(unique( SplicedRedLightBin )) );
                stateRedPEsNorm = nan( nanmax(unique( behavInterp(:,1) )) , nanmax(unique( SplicedRedLightBin )) );
                for behavState = unique( behavInterp(:,1) )'
                    for redSide = unique( SplicedRedLightBin )
                        stateCoords = intersect( find(behavInterp(:,1) == behavState) , find(SplicedRedLightBin == redSide) );
                        stateRedTime(behavState+1,redSide+1) = size( stateCoords,1 ) / resampleFreq;
                        stateRedPEs(behavState+1,redSide+1) = ...
                            nansum( behavInterp( stateCoords , 12 ) );
                        stateRedPEsNorm(behavState+1,redSide+1) = ( stateRedPEs(behavState+1,redSide+1) / stateRedTime(behavState+1,redSide+1) ) * 60;
                    end
                end
                
                %Plot
                figure
                hold on
                for behavState = unique( behavInterp(:,1) )'
                    exCoords = linspace( behavState-0.15 , behavState+0.15, size(unique( SplicedRedLightBin ),2) );
                    for redSide = unique( SplicedRedLightBin )
                        h = bar( exCoords(redSide+1) , stateRedPEsNorm(behavState+1,redSide+1) , 0.5/size(unique( SplicedRedLightBin ),2) );
                        set(h,'FaceColor',[1,0,0]*(redSide / nanmax(unique(SplicedRedLightBin)) ) );
                    end
                end
                xticks( unique( behavInterp(:,1) )' )
                xlabel(['Inactivity state'])
                ylabel(['PEs / min'])
                %legend
                set(gcf, 'Name', [behavLoad.overVar.flyName,' - PEs during red states separated by activity state'])
                
                %---------------------------------------------------------------------------------------------------------
                
                %Save for overuse
                overVar(IIDN).red.redStates = unique(SplicedRedLightBin);
                overVar(IIDN).red.redBehaVals = redBehaVals;
                overVar(IIDN).red.redBehaValsNoZero = redBehaValsNoZero;
                overVar(IIDN).red.redTime = thisRedTime;
                overVar(IIDN).red.redPEsNorm = thisRedPEsNorm;
                if exist('acFiel') ~= 0
                    overVar(IIDN).red.redActivity = redAc;
                end
            end
        end
        
        %----------------------------------------------------------------

        %%

        %Confirm correct time alignment of stimulus and data files
        %eegStartTimePosix = posixtime(datetime(strcat(EEG.info.date,'-', EEG.info.utcStartTime),'Format', 'yyyy-MMM-dd-HH:mm:ss')); %Changed from "MMMM" to "MMM" (Possibly MATLAB 2020 thing?)
        %eegEndTimePosix = posixtime(datetime(strcat(EEG.info.date,'-', EEG.info.utcStopTime),'Format', 'yyyy-MMM-dd-HH:mm:ss'));
        eegStartTimePosix = posixtime(datetime(strcat(EEG.info.date,'-', EEG.info.utcStartTime),'Format', 'yyyy-MMM-dd-HH:mm:ss', 'TimeZone','+10:00')); %Incorporated timezone (31/03/21)
        eegEndTimePosix = posixtime(datetime(strcat(EEG.info.date,'-', EEG.info.utcStopTime),'Format', 'yyyy-MMM-dd-HH:mm:ss', 'TimeZone','+10:00'));
        %eegStartTimePosix = EEG.info.headerstarttime;
        %eegEndTimePosix = EEG.info.headerstoptime;
            %Note: headerstarttime appears different from utcstarttime, with utcstarttime appearing to be the time at which the stimulus paradigm was started
                %(headerstarttime may refer to the time the physical block was started?)
        %firstSentTimePosix = posixtime(datetime(strcat(sentStimuliStruct(1).trialSendDatestr),'Format', 'yyyy dd/MM HH:mm:ss:SSS'));
        firstSentTimePosix = posixtime(datetime(strcat(matStruct.sentStimuli(1).trialSendDatestr),'Format', 'yyyy dd/MM HH:mm:ss:SSS', 'TimeZone', '+10:00'));
        %disp(['-- First trial (',sentStimuliStruct(1).Condition,') sent ',num2str( (firstSentTimePosix - eegStartTimePosix) ),'s after block commencement --']) 
        disp(['-- First trial (',matStruct.sentStimuli(1).Condition,') sent ',num2str( (firstSentTimePosix - eegStartTimePosix) ),'s after block commencement --'])   
        if firstSentTimePosix - eegStartTimePosix > 5*60 %"Difference in seconds between TDT start and first stim sent is more than 5 minutes"
            ['## Alert: First (apparent) stimulus sent with a significant delay from data start time ##']
            %{
            proceed = input('Continue? (0/1)')
            %This either indicates that a stimulus MAT file has been missed or that there was a delay in initiating the stimulus script
            if proceed == 0
                crash = yes
            end
            %}
        end
        %Note: A check for the last block sent time would be symmetrical but is impractical, given that TDT ceasing can be >15m after end of stimulus
        
        if overnightMode == 1
            %This section accounts for the fact that currently sentStimuli holds *all* block information from start of experiment, in a progressive manner
            if (firstSentTimePosix - eegStartTimePosix) < 0
                disp(['#- sentStimuli first trial reported to be prior to chunk commencement; Posix-assisted deletion will be deployed -#'])
                sentBlocksWiped = 0;
                for sentBlockInd = size(matStruct.sentStimuli,2):-1:1
                    thisSentTimePosix = posixtime(datetime(strcat(matStruct.sentStimuli(sentBlockInd).trialSendDatestr),'Format', 'yyyy dd/MM HH:mm:ss:SSS'));
                    if (thisSentTimePosix - eegStartTimePosix) < 0
                        matStruct.sentStimuli(sentBlockInd) = [];
                    end
                end
                firstSentTimePosix = posixtime(datetime(strcat(matStruct.sentStimuli(1).trialSendDatestr),'Format', 'yyyy dd/MM HH:mm:ss:SSS'));
                disp(['-- New first trial (',matStruct.sentStimuli(1).Condition,') sent ',num2str( (firstSentTimePosix - eegStartTimePosix) ),'s after block commencement --'])   
            else
                disp(['-- sentStimuli first trial sent after chunk commencement; No deletion required --'])
            end
        end
            %Note: Probably incompatible with old, non-saveStruct experimental protocols

        %Calculate StimOn friendly rest-less condition order list
        condSansRestOrder = []; %Desynced from m
        condNum = []; %Synced with cond
        a = 1;
        %if isempty(sentStimuliStruct) ~= 1 %"sentStimuli exists"
        if isfield(matStruct,'sentStimuliStruct') ~= 1 %"sentStimuli exists"
            for i = 1:size(matStruct.sentStimuli,2)
                if isempty(matStruct.sentStimuli(i).Condition) ~= 1
                    condSansRestOrder{1,a} = matStruct.sentStimuli(i).Condition;
                    a = a + 1;
                    if isempty(strfind(matStruct.sentStimuli(i).Condition,'carrieronly')) ~= 1
                        condNum(i,1) = 1;
                    elseif isempty(strfind(matStruct.sentStimuli(i).Condition,'oddball')) ~= 1
                        condNum(i,1) = 2;
                    end
                else
                    condNum(i,1) = 0;
                end
            end
        end

        %Calculate unbiased stimulus onset
        %Attempt to pull max freq and use for artefact tolerance intelligence
        if isfield(matStruct,'flagParamStruct') == 1 %Second-to-last generation
            prosMaxFreq = matStruct.flagParamStruct.f1(1); %Note: Hardcoded assumption of frequency invariance across CarrierOrder
        elseif isfield(matStruct,'ancillary') == 1 & isfield(matStruct.ancillary,'flagParamSaveStruct') == 1 %Current generation
            prosMaxFreq = matStruct.ancillary.flagParamSaveStruct.f1(1); %Note: Hardcoded assumption of frequency invariance across CarrierOrder
        else
            prosMaxFreq = 10; %Assumption, but QA code will check
        end
        arbitrarySDFactor = 8; %Sets the minimum number of SD higher than the baseline SD the data must possess
        %artefactToleranceSize = 0.5*resampleFreq; %Any 'rests' shorter than this threshold will be assumed to be in fact momentary virtual channel artefacts
            %Hardcoded 0.5s or less in size detection
                    %Note: This implementation fatally weak to early artefacts that cause the starts of blocks to be incorrectly detected as sub-size blocks
        %artefactToleranceSize = 2 * (1.0/prosMaxFreq) * resampleFreq; %Any 'rests' shorter than this threshold will be assumed to be in fact momentary virtual channel artefacts
        breakArtefactToleranceSize = 2 * (1.0/prosMaxFreq) * resampleFreq; %Updated name to allow for separate break/bock criteria
            %Currently set to detect any breaks 2 cycle periods or less in size
            %"More like...arte-Facked up"
        blockArtefactToleranceSize = matStruct.ancillary.stimduration * 0.90 * resampleFreq; %Exclude blocks less than 90% of the normal length (Will crash if ancillary does not exist)
            %Note: This is inimical to having blocks of different durations, but that is currently not on the cards

        %Iterate and collect stim data from one or more channels
        stimChannelList = [1,2]; %Which virtual channels to collect and collate stimulus data from

        allSignalStimBool = zeros(1,size(SplicedStim,2));

        figure %Testatory fig
        insuffDataCount = 0; %Counts how many channels lacked proper data

        for vChan = stimChannelList
            stimSignalData = SplicedStim(vChan,:); %Pure sine (both carrier and oddball Note: Synchronicity with jitter not confirmed)
            stimSignalDiff = [0, diff(stimSignalData)]; %Proximal zero insertion necessary for correct matrix sizing

            if condNum(1) == 0 %"First trial was rest"
                allSignalBaseline = stimSignalData(1:20*resampleFreq); %Hardcoded 20s trial and 1000Hz fs
                    %A method that actually finds a rest trial here would be superior but is currently infeasible
            else
                allSignalBaseline = stimSignalData(1:20*resampleFreq); %The same operation, but less confidently
                ['# Warning: Using fixed 20s at start of exp as baseline but this may not be correct #']
                %Depending on waitMinutes and hardcoded waits in the stimulus script there may not be a full 20s at the start as a baseline
            end

            stimSignalBaselineMean = nanmean(allSignalBaseline);
            stimSignalBaselineSD = nanstd(allSignalBaseline);

            %QA for following processing effectiveness
            if nanstd(stimSignalData) < arbitrarySDFactor*stimSignalBaselineSD %*8 completely arbitrary
                ['## Warning: Not enough difference between SD of baseline and data remainder for stim channel ',num2str(vChan),' ##']
                %crash = yes
                insuffDataCount = insuffDataCount+1;
                %This is likely in conditions where no stimulus was delivered ever (for whatever reason) or massive noise in the virtual channel (for whatever reason)
            end

            %Now here is where the true genius shows
            %allSignalStimBool = ( abs(allSignalDiff) > arbitrarySDFactor*allSignalBaselineSD | abs(allSignalData - allSignalBaselineMean) > arbitrarySDFactor*allSignalBaselineSD );
            allSignalStimBool( abs(stimSignalDiff) > arbitrarySDFactor*stimSignalBaselineSD | abs(stimSignalData - stimSignalBaselineMean) > arbitrarySDFactor*stimSignalBaselineSD ) = 1; %Mod to work easier with for loop
                %"Find all points where the instantaneous difference is greater than X times the SD OR the value is more than X times away from the mean"
                    %The first half captures the majority of a sine wave but fails at the peak and trough, thus the second half to find points that are flat but not of the same value as the baseline mean
                        %Note: If the peak or trough are aligned with the mean the second half will fail
                %Secondary note: This may behave unpredictably now that it is preserved across loops

            %Testatory fig cont.
            plot(SplicedStim(vChan,:));
            hold on
            plot(allSignalStimBool*4e5+(vChan-1)*0.5e5) %Good for showing at the same scale as the data
            %plot(allSignalBaselineMean + allSignalStimBool*(arbitrarySDFactor*allSignalBaselineSD)) %Good for showing how the detection fits with the noise level
            %xlim([4.6531e5 , 4.8173e5])
            xlim([6.8112e5 , 6.8168e5])
            title(['Virtual channels ', num2str(stimChannelList)])

        end
        set(gcf,'Name',[flies(IIDN).name, ' - SyncPlot']); %Set name of figure window to include fly name

        allSignalData = SplicedStim( stimChannelList(2) ,:); %Set here manually, rather than relying on remnants of prior loop
        
        %if useOutPData == 1 && outPExisting == 1
        %    allOutPData = SplicedOutP(1:3,:);
        %end
        
        %QA
        if insuffDataCount == size(stimChannelList,2)
            ['## No non-zero data detected in any stimulus channel ##']
            crash = yes;
        end

        %Remove sub-size breaks and blocks in a looping manner
            %Note: This will probably be an impediment for dealing with TDT crashes, which may cause 'legitimate' blocks of very short or long duration
        subSizeBreaksFound = -1;
        subSizeBlocksFound = -1;
        repIter = 1; %Used to prevent infiniloop
        while subSizeBreaksFound ~= 0 | subSizeBlocksFound ~= 0
            allSignalStimBlocksRaw = bwlabel(allSignalStimBool); %Finds contiguous stimulus blocks
            invAllSignalStimBlocksRaw = bwlabel(~allSignalStimBool);
            %Check for sub-size breaks
            subSizeBreaksFound = 0;
            for i = 1:nanmax(unique(invAllSignalStimBlocksRaw))
                if nansum(invAllSignalStimBlocksRaw == i) < breakArtefactToleranceSize
                    allSignalStimBool( invAllSignalStimBlocksRaw == i ) = 1;
                    subSizeBreaksFound = subSizeBreaksFound + 1;
                end
            end

            %Recalculate bwlabels
            allSignalStimBlocksRaw = bwlabel(allSignalStimBool); %Finds contiguous stimulus blocks
            invAllSignalStimBlocksRaw = bwlabel(~allSignalStimBool);

            %Check for sub-size blocks
            subSizeBlocksFound = 0;
            for i = 1:nanmax(unique(allSignalStimBlocksRaw))
                %if nansum(allSignalStimBlocksRaw == i) < breakArtefactToleranceSize
                if nansum(allSignalStimBlocksRaw == i) < blockArtefactToleranceSize
                    allSignalStimBool( allSignalStimBlocksRaw == i ) = 0;
                    subSizeBlocksFound = subSizeBlocksFound + 1;
                end
            end

            %Report
            disp(['# Loop ',num2str(repIter),' - Sub-size breaks: ',num2str(subSizeBreaksFound),' - Sub-size blocks: ',num2str(subSizeBlocksFound),' #'])
            repIter = repIter + 1;
            %{
            %QA to prevent infini-loop
            if repIter > 15
                ['## Alert: Sub-size break/block correction failed to optimise to zero ##']
                crash = yes
            end
            %}
        end
        %Honestly this is just a manual implementation of a smoothing function
            %Note: It would be recommended to improve the intelligence of this, perhaps with some contiguity detection/etc

        allSignalStimBlocksProc = bwlabel(allSignalStimBool); %Honestly bless the person who invented bwlabel
        numStimBlocksFound = nanmax(unique(allSignalStimBlocksProc));
        disp(['-- ',num2str(numStimBlocksFound),' stimulus blocks detected --'])
            %Note: The current system works by identifying sine wave blocks and assigning those as stimulus blocks. By iterating across multiple channels the chance of a block
            %being missed are lowered, but there is a chance for overfinds, etc. Also, in places where one sine wave block is translated and the second wave is missing,
            %the system may incorrectly identify oddball gaps as breaks between blocks. To fix this issue would require some sort of rolling sine-wave offset correction system.

        %Supplement rolling testatory figure
        for i = 1:nanmax(unique(allSignalStimBlocksProc))
            text( [find(allSignalStimBlocksProc == i, 1)] , [5.2e5] , num2str(i) , 'Color', 'm' )
        end
        plot(~(~(allSignalStimBlocksProc))*5e5, 'm') %Rolling testatory fig. ended (Assuming no ligation necessary)

        %Testatory fig to confirm accurate separation of stim and rest
        %{
        figure
        for vChan = stimChannelList
            plot(SplicedStim(vChan,:));
            hold on
        end
        %plot(SplicedData(16,:)*1000)
        plot(allSignalStimBool*2e5) %Good for showing at the same scale as the data
        %plot(allSignalBaselineMean + allSignalStimBool*(arbitrarySDFactor*allSignalBaselineSD)) %Good for showing how the detection fits with the noise level
        plot(~(~(allSignalStimBlocksProc))*5e5)
        xlim([4.6531e5 , 4.8173e5]) %End of stimulus block 12 for Block 3 of 1/5/20 Oddball
        %}

        %########

        %Report on detected block sizes
        %Attempt to pull stimulus duration
        if isfield(matStruct,'ancillary') == 1 & isfield(matStruct.ancillary,'stimduration') == 1 %Current generation
            stimDuration = matStruct.ancillary.stimduration; %Note: Hardcoded assumption of frequency invariance across CarrierOrder
        else
            stimDuration = 20.01; %Assumption
        end
        potSubSize = 0; %Count of how many blocks may have been truncated by overly-aggressive sub-size break/block removal
        potSubList = []; %List of above
        maxUnSig = nanmax(unique(allSignalStimBlocksProc));
        potSubList = nan(1,maxUnSig);
        for i = 1:maxUnSig
            if maxUnSig < 128 || ( maxUnSig >= 128 && i <= 36 )
                disp(['Block ',num2str(i), ' - Dur.: ',num2str(nansum(allSignalStimBlocksProc == i)/resampleFreq),'s, Start time: ~',num2str(find(allSignalStimBlocksProc == i,1)/resampleFreq),'s'])
            elseif maxUnSig >= 128 && i == 37
                disp(['(Truncating further block information for brevity [',num2str(maxUnSig),' blocks total])']) 
            end
            if nansum(allSignalStimBlocksProc == i)/resampleFreq < stimDuration
            %if sum(allSignalStimBlocksProc == i)/resampleFreq < stimDuration
                potSubSize = potSubSize + 1; %Iterate counter by 1
                %potSubList = [potSubList, i];
                potSubList(i) = i;
            end
        end
        potSubList( isnan(potSubList) ) = [];
        %QA
        if potSubSize > 0
            ['## Warning: ',num2str(potSubSize),' blocks may have been truncated, either during presentation or analysis ##']
            disp(['## (Block/s ',num2str(potSubList), ') ##'])
            %crash = yes %Potentially over-catchable offense here

            %Ligation repair
            if floor(potSubSize/2.0) == potSubSize / 2.0
                ['#- Attempting to ligate presumably aberrantly separated blocks -#']
                for i = 1:2:size(potSubList,2) %Jump by 2
                    truncBlockNum = potSubList(i);
                    truncBlockDur = nansum(allSignalStimBlocksProc == truncBlockNum)/resampleFreq;
                    if truncBlockNum ~= nanmax(unique(allSignalStimBlocksProc)) && ...
                            (truncBlockDur) + (nansum(allSignalStimBlocksProc == truncBlockNum+1)/resampleFreq) < stimDuration && ...
                            size(unique(allSignalStimBlocksProc( [find(allSignalStimBlocksProc == truncBlockNum,1) : find(allSignalStimBlocksProc == truncBlockNum,1)+stimDuration*resampleFreq])),2) == 3
                            %"Not last block AND block + following block together are still less than normal block size AND no less or more than 2 blocks present in what should be 1 block's span"
                                %Note: The last of these booleans will technically exclude cases of 3 or more aberrantly split blocks in close succession, but we can cross that bridge if it comes to it
                            %Ligate block and following block together
                            ligRange = [find(allSignalStimBlocksProc == truncBlockNum,1) : find(allSignalStimBlocksProc == truncBlockNum+1,1,'last')]; %Use start of block and end of following block as range to ligate
                            %allSignalStimBlocksProc(ligRange) = truncBlockNum;
                            allSignalStimBool(ligRange) = 1;
                            allSignalStimBlocksProc = bwlabel(allSignalStimBool);
                            %numStimBlocksFound = numStimBlocksFound - 1; %Because two have become one ("Aww how sweet")     
                            numStimBlocksFound = nanmax(unique(allSignalStimBlocksProc)); %More rigorous method that should theoretically also just subtract 1
                            ['#- Blocks ',num2str(truncBlockNum),' and ',num2str(truncBlockNum+1),' have been ligated together into block ',num2str(truncBlockNum),' -#']
                            plot(~(~(allSignalStimBlocksProc))*5.5e5, 'c')
                            for textI = 1:nanmax(unique(allSignalStimBlocksProc))
                                text( [find(allSignalStimBlocksProc == textI, 1)] , [5.72e5] , num2str(textI) , 'Color', 'c' )
                            end
                    else
                        ['## Could not ligate block ',num2str(truncBlockNum),' for one or more reasons ##']
                    end
                end                
            end

        end

        %########

        %QA to check sanity of block detection
            %Graph disabled for auto operation as may or may not be very slow to plot/save
        if useAutoList ~= 1 
            sentStartTimesPosix = [];
            c = 1;
            for sEnt = 1:size(matStruct.sentStimuli,2)
                if isempty( matStruct.sentStimuli(sEnt).Condition ) ~= 1
                    sentStartTimesPosix(c,1) = posixtime(datetime(strcat(matStruct.sentStimuli(sEnt).trialSendDatestr),'Format', 'yyyy dd/MM HH:mm:ss:SSS','TimeZone','+10:00'));
                    sentStartTimesPosix(c,2) = sEnt;
                    c = c + 1;
                end
            end
            detStartTimesPosix = [];
            for deBlock = 1:numStimBlocksFound
                detStartTimesPosix(deBlock,1) = splicedEpoch( find(allSignalStimBlocksProc == deBlock,1) );
                detStartTimesPosix(deBlock,2) = deBlock;
            end
            temp = sentStartTimesPosix;
            temp(1:size(detStartTimesPosix,1),3:4) = detStartTimesPosix; %Purposely designed to allow zero padding when mismatched
            tempDiff = [];
            for i = 1:size(temp,1)
                tempDiff(i,1) = temp(i,1) - temp(i,3); %Because I can't figure out how to use diff properly
            end
            %Diff
            figure
            plot(tempDiff)
            ylim([-80,80])
            title(['Sent vs Detected posix diff.'])
            %Posixes
            figure
            for i = 1:size(sentStartTimesPosix,1)
                line([sentStartTimesPosix(i),sentStartTimesPosix(i)],[0,1], 'LineStyle','--', 'Color', 'r')
                hold on
            end
            for i = 1:size(detStartTimesPosix,1)
                line([detStartTimesPosix(i),detStartTimesPosix(i)],[1,2], 'LineStyle','-.', 'Color', 'b')
            end
            title(['Posixes across time'])
        end
        
        %For plotting of very specific areas of the data
        blockToPlot = 57;
        startCoords = find(allSignalStimBlocksProc == blockToPlot,1);
        plotRange = [startCoords - 25*resampleFreq : startCoords + (50*resampleFreq)];
        figure
        plot( SplicedData(1,plotRange ))
        hold on
        plot( SplicedStim(1, plotRange)*0.0001)
        %plot( SplicedStim(4, plotRange)*0.0001)
        plot( SplicedPhot(1, plotRange)*0.0001)
        plot( SplicedStim(2, plotRange)*0.0001)
        detBlocksInThisRange = unique( allSignalStimBlocksProc(plotRange) );
        detBlocksInThisRange(detBlocksInThisRange == 0) = [];
        for i = 1:size(detBlocksInThisRange,2)
            startCoordsLine = find(allSignalStimBlocksProc == detBlocksInThisRange(i),1) - startCoords;
            endCoordsLine = find(allSignalStimBlocksProc == detBlocksInThisRange(i),1,'last') - startCoords;
            %line([ startCoordsLine , endCoordsLine ], [ detBlocksInThisRange(i) , detBlocksInThisRange(i) ]-1200, 'Color', 'k')
            line([ startCoordsLine , endCoordsLine ], [ i*10 , i*10 ], 'Color', 'k')
            text(startCoordsLine , detBlocksInThisRange(i)-1200, num2str(detBlocksInThisRange(i)))
        end
        title(['StimBool for detected block ',num2str(blockToPlot)])
        set(gcf,'Name',[flies(IIDN).name, ' - StimBool']);

        %QA for asynchrony between Detected and sentStimuli
            %Moved below initial blockStruct and sentStruct (New) construction to allow for preemptive fixing if applicable
        %{
        if numStimBlocksFound ~= nansum(condNum ~= 0)
            ['## Alert: Disparity between detected stimulus blocks (',num2str(numStimBlocksFound),') and self-reported non-rest blocks delivered (',num2str(nansum(condNum ~= 0)),')']
            if isfield(matStruct.sentStimuli,'tdtCrash') == 1 && ( abs( numStimBlocksFound - nansum(condNum ~= 0) ) == nansum([ matStruct.sentStimuli.tdtCrash ]) || matStruct.sentStimuli(end).tdtCrash == 1 )
                disp(['#- Difference explicable as result of self-reported TDT crash/s -#'])
                disp(['Block/s ',num2str( find([ matStruct.sentStimuli.tdtCrash ] == 1) )])
                %Remove terminal block if happening and requested
                if deleteTerminalCrashSentBlocks == 1 && matStruct.sentStimuli(end).tdtCrash == 1
                    disp(['-# Deleting terminal crash block from sentStimuli as requested #-'])
                    matStruct.sentStimuli(end) = [];
                end
            else
                disp(['## Difference not explicable ##'])
                crash  = yes
            end
            %It is probably tempting to merge this with the sub-size break/block while condition, but that would be unwise, since it might lead to early termination when the number of blocks is coincidentally reached
            %but the smoothing has not technically converged yet
        end
        %}

        disp(['-- Collating block information --'])
        %Collate block information
        disp(['Constructing initial data in blockStruct from stimulus data...'])
        tic
        blockStruct = struct;
        for sBlock = 1:numStimBlocksFound
            blockStruct(sBlock).ID = sBlock;
            blockStruct(sBlock).duration = nansum(allSignalStimBlocksProc == sBlock)/resampleFreq;
            blockStruct(sBlock).startEnd = [ find(allSignalStimBlocksProc == sBlock,1) , find(allSignalStimBlocksProc == sBlock,1,'last') ]; %'True' startpoint, based on bwlabel of stim channels
            blockStruct(sBlock).range = [ find(allSignalStimBlocksProc == sBlock,1) : find(allSignalStimBlocksProc == sBlock,1,'last') ];
            blockStruct(sBlock).startTimeRel = blockStruct(sBlock).startEnd(1)/resampleFreq;
            blockStruct(sBlock).startTimeEpoch = splicedEpoch( blockStruct(sBlock).startEnd(1) ); %Note: This indexing should be accurate, as long as SplicedStim and splicedEpoch occupy the same reference frame
            %blockStruct(sBlock).startTimeEpochDatestr = datestr(datetime(blockStruct(sBlock).startTimeEpoch, 'ConvertFrom', 'posixtime', 'TimeZone', '+10:00')); %Timezone valid as long as experiments performed in Brisbane...
            blockStruct(sBlock).startTimeEpochDatestr = datestr(datetime(blockStruct(sBlock).startTimeEpoch, 'ConvertFrom', 'posixtime', 'TimeZone', '+10:00'), 'yyyy dd/mm HH:MM:SS:FFF'); %New, now with millisecond accuracy 
            if sBlock > 1
                blockStruct(sBlock).startIBI = blockStruct(sBlock).startTimeRel - blockStruct(sBlock-1).startTimeRel; %where IBI stands for Inter-Block Interval
            else
                blockStruct(sBlock).startIBI = NaN;
            end
        end
        disp(['Initial construction completed in ',num2str(toc),'s'])

        %Combine detected blocks with sentStimuli information
        disp(['Acumulating sentStimuli information...'])
        tic
        a = 1;
        crashCorrection = 0; %Starting value
        %%%badPosixDiffIndices = []; %List of times where the posix diff between start and sent was greater than an arbitrary threshold
            %(This seems to precede TDT crashes)
        sentStruct = struct;    
        for sEnt = 1:size(matStruct.sentStimuli,2)
            if isempty(matStruct.sentStimuli(sEnt).Condition) ~= 1
                sentStruct(a).sentID = sEnt;
                sentStruct(a).sentIDSansRest = a; %Nominally useful for desync conditions where the final number of detected and sent blocks does not match 
                sentStruct(a).sentCondition = matStruct.sentStimuli(sEnt).Condition;
                sentStruct(a).sentConditionNum = condNum(sEnt);
                sentStruct(a).sentTTL = matStruct.sentStimuli(sEnt).TTLvector;
                sentStruct(a).sentCycleIdent = matStruct.sentStimuli(sEnt).cycleIdent;
                sentStruct(a).sentDatestr = matStruct.sentStimuli(sEnt).trialSendDatestr;
                sentStruct(a).sentTimePosix = posixtime(datetime(strcat(matStruct.sentStimuli(sEnt).trialSendDatestr),'Format', 'yyyy dd/MM HH:mm:ss:SSS','TimeZone','+10:00'));
                sentStruct(a).sentTimeRel = sentStruct(a).sentTimePosix - eegStartTimePosix;
                %blockStruct(a).sentStartDelay = blockStruct(a).startTimeRel - blockStruct(a).sentTimeRel; %DIsabled here because of separation between initial construction of blockStruct and sentStruct
                %%%blockStruct(a).sentStartDelay = blockStruct(a).startTimeRel - blockStruct(a).sentTimeRel + crashCorrection; %Crash correction added 31/3/21; Works by subtracting delay value at crash point from all subsequent calculations
                    %Note that does nothing to fix the problem, but it does prevent the QA from aberrantly catching non-crash blocks after the crash
                        %The permanent increase in sentStartDelay after crashes is probably due to an accumulated desync between the sentPosix and the startPosix
                            %It is probable that the issue lies with startTimeEpoch (splicedEpoch), since this just an interpolated value and is probably weak to system lag/etc
                %%%blockStruct(a).sentStartPosixDiff = blockStruct(a).startTimeEpoch - blockStruct(a).sentTimePosix;
                %sentStimuli timing consistency
                
                %%%
                
                %{
                if a > 1
                    blockStruct(a).sentIBI = blockStruct(a).sentTimeRel - blockStruct(a-1).sentTimeRel; %where IBI stands for Inter-Block Interval
                else
                    blockStruct(a).sentIBI = NaN;
                end
                %}
                if isfield(matStruct.sentStimuli,'sentTDTCrash') == 1
                    sentStruct(a).sentTDTCrash = matStruct.sentStimuli(sEnt).sentTDTCrash; %Pulls self-reported TDT crash data from when experiment ran
                else
                    sentStruct(a).sentTDTCrash = NaN; %No self-reported crash data available
                end
                sentStruct(a).tdtCrashDetected = 0; %Post-hoc calculation of the above; Will be overwritten by QA if occurs
                                
                %%%
                
                %Parse Channel into actual stimulus that was sent
                %sentTypes = find(m(2).data(:,sEnt) == 1); %Use Gating to find what Gates were active
                sentTypes = find(matStruct.Gating(:,sEnt) == 1); %Use Gating to find what Gates were active
                sentColours = [];
                for colourInd = 1:size(sentTypes,1)
                    %sentColourStr = chanCodecContents( find(chanCodecIndex == m(3).data(sentTypes(colourInd),sEnt)) ); %Bring together Gating and Channel information to identify colours
                    sentColourStr = chanCodecContents( find(chanCodecIndex == matStruct.Channel(sentTypes(colourInd),sEnt)) ); %Bring together Gating and Channel information to identify colours
                    sentColours = [sentColours, sentColourStr{1}];
                end
                sentStruct(a).sentColours = sentColours;
                sentStruct(a).sentCarrierSwitch = matStruct.carrierOrderBlock(sEnt); %Not tested thoroughly

                a = a + 1; 
            end
        end
        disp(['sentStimuli accumulation completed in ',num2str(toc),'s'])

        matStruct.sentStimuli = rmfield( matStruct.sentStimuli, 'TTLvector' ); %Save memory
        overSaveStruct.saveStruct.sentStimuli = rmfield( overSaveStruct.saveStruct.sentStimuli , 'TTLvector' );
                
        %QA for posix diff (Old position)
        %{
        if isempty(badPosixDiffIndices) ~= 1
            ['-# Caution: start and sent posixes different by >5s in at least ',num2str(size(badPosixDiffIndices,2)),' blocks #-']
            %badPosixDiffIndices
        end
        %}
                
        %=========================================================================================================
        %Derive sentColours
            %Useful later on as well, so moved out of patternMode == 1 constraints
        %First, find all unique sentColours (Pretty sure this already exists in the code but cbf finding it)
        uniqueSentColours = [];
        uniqueSentColourConditions = [];
        for sentInd = 1:size(sentStruct,2)
            thisSentColour = sentStruct(sentInd).sentColours;
            thisSentCondition = sentStruct(sentInd).sentCondition;
            isUniqueColour = 1; %In a change from usual, will only be set to False if that is indeed the case
            for u = 1:size(uniqueSentColours,2)
                if isequal( uniqueSentColours{u} , thisSentColour ) == 1
                    isUniqueColour = 0;
                end
            end
            if isUniqueColour == 1 %Was never made not true
                uniqueSentColours{ size(uniqueSentColours,2)+1 } = thisSentColour;
                uniqueSentColourConditions{ size(uniqueSentColourConditions,2)+1 } = thisSentCondition;
            end
        end
        
        %Similarly (but less ambiguously) use sentStimuli information to calculate numbered colour groups
        for sentInd = 1:size(sentStruct,2)
                thisColour = sentStruct(sentInd).sentColours;
                thisColourNum = nan;
                for u = 1:size(uniqueSentColours,2)
                    if isequal( thisColour , uniqueSentColours{u} ) == 1
                        thisColourNum = u; %Specificity semi-guaranteed by unique
                    end
                end
                sentStruct(sentInd).sentColourNum = thisColourNum;            
        end
        
        if doPatternMatching == 1
            
            %Aggressive pattern matching
            %if patternMode == 1
            if patternModeActive == 1
                baselineNoiseLevelData = [];
                interStimSDData = [];
                stimPhotSDData = [];
                %Find difference between stim channels and stim vs phot
                    %The idea here is that a homogenous carrieronly trial will approach a TTL-like range of values, whereas a trial featuring oddballs
                    %will have gradations due to luminosity differences between green and blue LED output (or any colour and missing)
                        %Note that this specifically relies on imperfect luminosity matching between the green and blue LEDs (At least, according to the photodiode)
                for qaTarget = 1:size(blockStruct,2)
                    %%qaTarget = 1; %Now dynamic

                    %Calculate noise levels and things
                    if modernData == 1
                        interStimDiff = rescale(SplicedStim(1, blockStruct(qaTarget).range )) - rescale(SplicedStim(2, blockStruct(qaTarget).range ));
                    else
                        interStimDiff = (SplicedStim(1, blockStruct(qaTarget).range )./nanmax(nanmax([SplicedStim(1:3, blockStruct(qaTarget).range )]))) -...
                            (SplicedStim(2, blockStruct(qaTarget).range )./nanmax(nanmax([SplicedStim(1:3, blockStruct(qaTarget).range )])));
                    end
                    sumInterStimDiff = nansum( interStimDiff );
                    interStimSD = nanstd(interStimDiff);

                    %stimPhotDiff = rescale(SplicedStim(1, blockStruct(qaTarget).range )) - rescale(-SplicedStim(4, blockStruct(qaTarget).range )); %Note negative because that's how photodiode works
                    %stimPhotDiff = rescale(SplicedStim(1, blockStruct(qaTarget).range )) - rescale(SplicedPhot(1, blockStruct(qaTarget).range ));
                    if modernData == 1
                        stimPhotDiff = abs( rescale(SplicedStim(1, blockStruct(qaTarget).range )) - rescale(SplicedPhot(1, blockStruct(qaTarget).range )) );
                    else
                        stimPhotDiff = abs( (SplicedStim(1, blockStruct(qaTarget).range )./nanmax([SplicedStim(1:3, blockStruct(qaTarget).range )])) -...
                            SplicedPhot(1, blockStruct(qaTarget).range ) );
                    end
                    sumStimPhotDiff = nansum( stimPhotDiff );
                    stimPhotSD = nanstd(stimPhotDiff);

                    qaBaseline = rescale(SplicedStim(1, blockStruct(qaTarget).range(1) - 1.5*resampleFreq : blockStruct(qaTarget).range(1) + 1.5*resampleFreq )); %Hardcoded selection of 1.5s pre block start to 1.5 post start

                    baselineNoiseLevel = nanstd(qaBaseline( 1 : 1*resampleFreq ));

                    %disp(['Block ',num2str(qaTarget),' (rescaled) SplicedStim channel 1 and 2 differ by ',num2str(interStimSD / baselineNoiseLevel),'x baseline noise level (',num2str(baselineNoiseLevel),')'])
                    %disp(['Block ',num2str(qaTarget),' (rescaled) SplicedStim channel 1 and phot (4) differ by ',num2str(stimPhotSD / baselineNoiseLevel),'x baseline noise level (',num2str(baselineNoiseLevel),')'])
                    baselineNoiseLevelData(qaTarget,1) = baselineNoiseLevel;
                    interStimSDData(qaTarget,1) = interStimSD;
                    stimPhotSDData(qaTarget,1) = stimPhotSD;
                end

                %###
                %Note: The following section is just a bootleg implementation of a clustering script to identify how many different groups of differences there are in the Stim - Phot data
                %###
                %Calculate hist of SDs
                [N,X] = hist(stimPhotSDData,384); %384 arbitrary
                NProp = N / size(blockStruct,2); %Proportionalised version of N

                %Plot differences
                figure
                plot(X,NProp)
                xlim([0 , nanmean(stimPhotSDData) + 2*nanstd(stimPhotSDData)])
                title(['Stim-Phot SD per block (X-limit forced)'])

                %Derive peak positions
                [~, clustLOCS, ~, ~] = findpeaksbase( NProp , 'MinPeakHeight', 0.02 , 'MinPeakDistance', 7.5 ); %MINPEAKHEIGHT AND MINPEAKDISTANCE COMPLETELY ARBITRARILY DERIVED FROM N = 1 DATASET
                clustCentroids = X(clustLOCS);

                disp(['-- Stim-Phot comparison yielded ',num2str(size(clustLOCS,2)),' bootleg clusters (',num2str(X(clustLOCS)),') --'])

                %Tack on cluster locations to plot
                hold on
                scatter( X(clustLOCS) , NProp(clustLOCS) )
                
                %Now use stimPhotSD data to try back-calculate block identity
                %This rests primarily on the assumption that the smallest stimPhotSD values will come from carrieronly blocks where the colour did not change over time
                    %As such, it will probably fail horribly on a hypothetical alternating carrieronly block
                for blockInd = 1:size(blockStruct,2)
                    diffToGroups = abs( stimPhotSDData(blockInd) - clustCentroids ); %Find the difference between this stimPhotSD and the detected groups
                        %Note: This forces a choice and has no allowance for sitting halfway between two groups
                    [~,closestGroup] = nanmin(diffToGroups); %Find the group that this stimPhotSD is closest to
                    blockStruct(blockInd).closestGroup = closestGroup;
                end
                
                %QA based on number of different colour sent groups reported in sentStimuli
                %{
                %First, find all unique sentColours (Pretty sure this already exists in the code but cbf finding it)
                uniqueSentColours = [];
                uniqueSentColourConditions = [];
                for sentInd = 1:size(sentStruct,2)
                    thisSentColour = sentStruct(sentInd).sentColours;
                    thisSentCondition = sentStruct(sentInd).sentCondition;
                    isUniqueColour = 1; %In a change from usual, will only be set to False if that is indeed the case
                    for u = 1:size(uniqueSentColours,2)
                        if isequal( uniqueSentColours{u} , thisSentColour ) == 1
                            isUniqueColour = 0;
                        end
                    end
                    if isUniqueColour == 1 %Was never made not true
                        uniqueSentColours{ size(uniqueSentColours,2)+1 } = thisSentColour;
                        uniqueSentColourConditions{ size(uniqueSentColourConditions,2)+1 } = thisSentCondition;
                    end
                end

                %Next, see if more clusters were found than unique colour groups exist
                    %Note: It is highly likely that clustering will find less groups than exist in sentStimuli if symmetrical colour groups were used
                        %I.e. green carrieronly will probably give the same stimPhotSD value as blue carrieronly
                if size(clustLOCS,2) > size(uniqueSentColours,2)
                    ['-# Warning: More stim-phot clusters found than unique colour groups reported sent #-']
                        %Not a guaranteed error state, but probably bad if more than one or two above the number of unique sent colour groups
                end

                %Similarly (but less ambiguously) use sentStimuli information to calculate numbered colour groups
                for sentInd = 1:size(sentStruct,2)
                        thisColour = sentStruct(sentInd).sentColours;
                        thisColourNum = nan;
                        for u = 1:size(uniqueSentColours,2)
                            if isequal( thisColour , uniqueSentColours{u} ) == 1
                                thisColourNum = u; %Specificity semi-guaranteed by unique
                            end
                        end
                        sentStruct(sentInd).sentColourNum = thisColourNum;            
                end
                %}
                %See if more clusters were found than unique colour groups exist
                    %Note: It is highly likely that clustering will find less groups than exist in sentStimuli if symmetrical colour groups were used
                        %I.e. green carrieronly will probably give the same stimPhotSD value as blue carrieronly
                if size(clustLOCS,2) > size(uniqueSentColours,2)
                    ['-# Warning: More stim-phot clusters found than unique colour groups reported sent #-']
                        %Not a guaranteed error state, but probably bad if more than one or two above the number of unique sent colour groups
                end
                
            else %OutP identity
                
                %QA for OutP existence, rather than having whole rest of section be within if loop
                if exist('SplicedOutP') ~= 1
                    ['## Alert: Cannot perform OutP-based stimulus detection when OutP does not exist (In usable form) ##']
                    crash = yes
                end
                
                %Iterate through each block and query OutP values to determine identity
                    %This section calculates how different the OutP channel 1 (Carrieronly TTL) is from being 100% high
                    %and if it is less than 5%, assigns the block as "probably carrieronly"
                        %This will probably fail if blockStruct range is very desynchronised from OutP
                for qaTarget = 1:size(blockStruct,2)
                    if abs(nansum( SplicedOutP(1, blockStruct(qaTarget).range) ) - size( blockStruct(qaTarget).range , 2 ) ) < 0.05*size( blockStruct(qaTarget).range , 2 )
                        blockStruct(qaTarget).outPDerivedGroup = 1; %Carrieronly
                    else
                        blockStruct(qaTarget).outPDerivedGroup = 2; %Oddball
                    end
                end
                disp(['-- OutP block derivation finished --'])
                disp([num2str(nansum([blockStruct.outPDerivedGroup]==1)),' blocks were detected as carrieronly'])
                disp([num2str(nansum([blockStruct.outPDerivedGroup]==2)),' blocks were detected as oddball'])
                
                %Identify unique sentConditionNums
                uniqueSentCondNums = unique([sentStruct.sentConditionNum]);
                uniqueSentCondNumConditions = [];
                for sentInd = 1:size(sentStruct,2)
                    thisSentCondition = sentStruct(sentInd).sentCondition;
                    isUniqueCondition = 1; %In a change from usual, will only be set to False if that is indeed the case
                    for u = 1:size(uniqueSentCondNumConditions,2) %By nature this will iterate to zero initially
                        if isequal( uniqueSentCondNumConditions{u} , thisSentCondition ) == 1
                            isUniqueCondition = 0;
                        end
                    end
                    if isUniqueCondition == 1 %Was never made not true
                        uniqueSentCondNumConditions{ size(uniqueSentCondNumConditions,2)+1 } = thisSentCondition;
                    end
                end
                
            end
            
            proceed = 0;
            while proceed ~= 1
                
                %Calculate all possible orderings of sentStimuli colour groups and their respective levels of mismatch
                    %Note: This will be less than accurate if number of detected groups is different to number of sent groups
                %if patternMode == 1
                if patternModeActive == 1
                    sentPerms = perms([1:size(uniqueSentColours,2)]);
                    sentStructOrder = [sentStruct.sentColourNum]'; %Collect original list of sent colour groups ("Sent/Struct: First Order")
                else
                    sentPerms = perms([1:size(uniqueSentCondNums,2)]);
                    sentStructOrder = [sentStruct.sentConditionNum]'; %Collect original list of sent colour groups ("Sent/Struct: First Order")
                end
                %Iterate along said permutation groups and calculate closeness to blockStruct closest groups
                blockStructIdentityActive = nan(size(sentStruct,2),1); %Prepare
                maxSize = nanmin([ size(sentStruct,2) , size(blockStruct,2) ]); %Find which is smaller; blockStruct or sentStruct
                %if patternMode == 1
                if patternModeActive == 1
                    blockStructIdentityActive(1 : maxSize) = [blockStruct(1:maxSize).closestGroup]; %Pull in (colour-derived) data
                else
                    blockStructIdentityActive(1 : maxSize) = [blockStruct(1:maxSize).outPDerivedGroup]; %Pull in (OutP-derived) data
                end

                permScores = [];
                %sentStructOrder = [sentStruct.sentColourNum]'; %Collect original list of sent colour groups ("Sent/Struct: First Order")
                sentStructOrderActives = []; %Because lazy
                for permInd = 1:size(sentPerms,1)
                    sentStructOrderActives{permInd} = sentStructOrder; %Active copy of above (To prevent self-catching as iterating through transformation)
                    for p = 1:size(sentPerms,2)
                        sentStructOrderActives{permInd}( sentStructOrder == p ) = sentPerms( permInd, p ); %Change elements of sentStructOrderActive according to perm transformation
                        %e.g. If perm is [3,2,1] then all 1s will become 3s, 2s will stay as 2s and 1s will become 3s 
                        %Note that it is critical to not use the active variable for this indexing, given that it will change on each p iteration
                    end

                    thisPermScore = nansum( blockStructIdentityActive ~= sentStructOrderActives{permInd}); %How far from perfect equality this permutation is
                    permScores(permInd) = thisPermScore;

                    disp(['- Perm. ',num2str(sentPerms( permInd, : )), ' mismatch score: ',num2str(thisPermScore),' -'])

                end

                %Report on most accurate perm and its properties
                    %Note: 'Most accurate' is a relative term (e.g. 80% mismatch is technically more accurate than 82% mismatch)
                [~, mostAccurateInd] = nanmin(permScores);
                disp([char(10),'-- Most accurate permutation: ',num2str(sentPerms( mostAccurateInd, : )),' --'])
                %if patternMode == 1
                if patternModeActive == 1
                    for p = 1:size(sentPerms,2)
                        disp(['- sentColourNum ',num2str(p),' as ',uniqueSentColours{ sentPerms( mostAccurateInd, p ) },' (',uniqueSentColourConditions{ sentPerms( mostAccurateInd, p ) },') w/ stimPhot group ',...
                            num2str(p),', stimPhot SD value of ',num2str(clustCentroids(p)),'  -'])
                    end
                else
                    for p = 1:size(sentPerms,2)
                        %disp(['- sentConditionNum ',num2str(p),' as ',uniqueSentCondNums( sentPerms( mostAccurateInd, p ) ),' (',uniqueSentCondNumConditions{ sentPerms( mostAccurateInd, p ) },') -'])
                        disp(['- sentConditionNum ',num2str(p),' as ',num2str(uniqueSentCondNums( sentPerms( mostAccurateInd, p ) )),' (',uniqueSentCondNumConditions{ sentPerms( mostAccurateInd, p ) },') -'])
                    end
                end

                %Plot divergence from blockStruct        
                figure
                plot( sentStructOrderActives{ mostAccurateInd } ~= blockStructIdentityActive )
                hold on
                sentTDTCrashes = find([sentStruct.sentTDTCrash] == 1);
                for i = 1:size(sentTDTCrashes,2)
                    line( [sentTDTCrashes(i),sentTDTCrashes(i)] , [-1,2], 'LineStyle', ':', 'Color', 'r')
                end
                ylim([-1,2])
                title(['Pattern matching divergence for best scoring permutation, #',num2str(mostAccurateInd),' (Score: ',num2str(permScores(mostAccurateInd)),')'])
                set(gcf,'Name',[flies(IIDN).name, ' - Pattern Match']);
                
                if permScores(mostAccurateInd) == 0
                    disp(['-- Perfect pattern match obtained --'])
                    proceed = 1;
                elseif permScores(mostAccurateInd) > 0 && ditchSentStructIfNecessary == 1
                    %Preliminary QA to prevent infiniloop
                    if proceed == 2
                        ['## Patterns still diverge ##']
                        crash = yes
                    end
                    ['-# Caution: Perfect pattern match not obtained; Attempting sentStruct ditch -#']
                    ditchPoint = find( sentStructOrderActives{ mostAccurateInd } ~= blockStructIdentityActive , 1 , 'first' );
                    %QA
                    if ditchPoint < ceil( size(sentStruct,2) * 0.05 )
                        ['## Alert: Dissonance appears present from start; Cannot safely ditch ##']
                        crash = yes
                    end
                    sentStruct(ditchPoint) = [];
                    disp(['(sentStruct element ',num2str(ditchPoint),' has been ditched)'])
                    proceed = 2;
                    %Recalculate some things
                    %Calculate StimOn friendly rest-less condition order list
                        %(Borrowed from above)
                    condSansRestOrder = []; %Desynced from m
                    condNum = []; %Synced with cond
                    a = 1;
                    %if isempty(sentStimuliStruct) ~= 1 %"sentStimuli exists"
                    %if isfield(matStruct,'sentStimuliStruct') ~= 1 %"sentStimuli exists"
                    for i = 1:size(sentStruct,2)
                        if isempty(sentStruct(i).sentCondition) ~= 1
                            condSansRestOrder{1,a} = sentStruct(i).sentCondition;
                            a = a + 1;
                            if isempty(strfind(sentStruct(i).sentCondition,'carrieronly')) ~= 1
                                condNum(i,1) = 1;
                            elseif isempty(strfind(sentStruct(i).sentCondition,'oddball')) ~= 1
                                condNum(i,1) = 2;
                            end
                        else
                            condNum(i,1) = 0;
                        end
                    end
                    %end

                end
                
            end
            
            %If not perfectly matching
            if permScores(mostAccurateInd) > 0
                ['-# Caution: Detected block identity and sentStruct identities do not perfect match #-']
                crash = yes
            end
        
        end
        
        %=========================================================================================================
                
        %{
        qaTarget = 1;
        %Resample sentStimuli TTL to match SplicedStim fs
        temp = sentStruct(qaTarget).sentTTL;
        resampleFreq = EEG.srate;
        fsStim = EEG.sourceFramerates.Wave; 
        [N,D] = rat(resampleFreq/fsStim); % Rational Fraction Approximation
        tempResamp = [];
        %for i = 1:size(blockStruct,2)
        for idx = 1:size(temp,1)
            tempResamp(idx,:) = round( resample(double(temp(idx,:)), N, D) );% Resampled Signal 
            %Note: Rounding necessary because otherwise small decimals creep in
        end
        %{
        %sentStimuli TTL xample
        figure
        %plot(sentStruct(1).sentTTL(1,:))
        temp = sentStruct(1).sentTTL;
        %end
        hold on
        plot(tempResamp(2,:))
        plot(tempResamp(3,:) - 1.1)

        %SplicedStim
        figure
        plot( rescale(SplicedStim(1, blockStruct(1).range )) )
        hold on
        plot( rescale(SplicedStim(2, blockStruct(1).range )) - 1.1 )
        %plot( rescale(SplicedStim(4, blockStruct(1).range )) - 2.1 )
        plot( rescale(SplicedPhot(1, blockStruct(1).range )) - 2.1 )
        %}
        
        %Combined
        figure
        plot( rescale(SplicedStim(1, blockStruct(qaTarget).range )) )
        hold on
        plot( rescale(SplicedStim(2, blockStruct(qaTarget).range )) - 1.1 )
        %plot( rescale(SplicedStim(4, blockStruct(qaTarget).range )) - 2.1 )
        plot( rescale(SplicedPhot(1, blockStruct(qaTarget).range )) - 2.1 )
        plot(tempResamp(2,:) - 3.1)
        plot(tempResamp(3,:) - 4.1)
        %}
       
        %QA for asynchrony between Detected and sentStimuli
        if numStimBlocksFound ~= nansum(condNum ~= 0)
            ['## Alert: Disparity between detected stimulus blocks (',num2str(numStimBlocksFound),') and self-reported non-rest blocks delivered (',num2str(nansum(condNum ~= 0)),')']
            if isfield(matStruct.sentStimuli,'tdtCrash') == 1 && ( abs( numStimBlocksFound - nansum(condNum ~= 0) ) == nansum([ matStruct.sentStimuli.tdtCrash ]) || matStruct.sentStimuli(end).tdtCrash == 1 )
                disp(['#- Difference explicable as result of self-reported TDT crash/s -#'])
                disp(['Block/s ',num2str( find([ matStruct.sentStimuli.tdtCrash ] == 1) )])
                %Remove terminal block if happening and requested
                if deleteTerminalCrashSentBlocks == 1 && matStruct.sentStimuli(end).tdtCrash == 1
                    disp(['-# Deleting terminal crash block from sentStimuli as requested #-'])
                    matStruct.sentStimuli(end) = [];
                end
            else
                disp(['## Difference not explicable ##'])
                crash  = yes
            end
            %It is probably tempting to merge this with the sub-size break/block while condition, but that would be unwise, since it might lead to early termination when the number of blocks is coincidentally reached
            %but the smoothing has not technically converged yet
        end
        
        %##################################################
        
        %Merge blockStruct and sentStruct
            %Note: If blockStruct shorter than sentStruct then truncation will occur
            %Secondary note: This rather critically relies on synchronicity between blockStruct and sentStruct, obviously 
        for prosInd = 1:size(blockStruct,2)
            sentFiels = fieldnames(sentStruct(prosInd));
            for fielInd = 1:size( sentFiels,1 )
                blockStruct(prosInd).( sentFiels{fielInd} ) = sentStruct(prosInd).( sentFiels{fielInd} );
            end            
        end
        disp(['-- blockStruct and sentStruct successfully merged --'])
            %Is it ever feasible that this script will be run without the existence of sentStruct? If so then contingencies might have to be set up
        clear sentStruct

        %##################################################
        
        %------------------------------------------------------------------
        %QA loop mostly for timing
        badPosixDiffIndices = [];
        for a = 1:size(blockStruct,2)
            blockStruct(a).sentStartDelay = blockStruct(a).startTimeRel - blockStruct(a).sentTimeRel;
            if a > 1
                blockStruct(a).sentIBI = blockStruct(a).sentTimeRel - blockStruct(a-1).sentTimeRel; %where IBI stands for Inter-Block Interval
            else
                blockStruct(a).sentIBI = NaN;
            end
            blockStruct(a).sentStartPosixDiff = blockStruct(a).startTimeEpoch - blockStruct(a).sentTimePosix;
            %---
            %QA for sentStimuli vs data timestamps
            %{
            if abs(blockStruct(a).sentStartDelay) > matStruct.ancillary.stimduration %May fail with older data and/or where the ancillary field does not exist
                ['## Alert: Block ',num2str(a),' time disparity with sentStimuli exceeds stimulus duration ##']
                crashCorrection = crashCorrection + abs(blockStruct(a).sentStartDelay); %Calculate permanent correction to carry forward
                blockStruct(a).tdtCrashDetected = 1;
                blockStruct(a).sentStartDelay = blockStruct(a).startTimeRel - blockStruct(a).sentTimeRel + crashCorrection; %A copy of the code above to overwrite (to a perfect 0, for this block at least)
                            %Note: Correct sign usage tenuous here
                %%crash = yes %More nuance added
                %if isfield(matStruct.sentStimuli,'tdtCrash') ~= 1 %No helpful field to indicate when crashes occurred
                if isnan(blockStruct(a).sentTDTCrash) == 1 %No helpful field to indicate when crashes occurred
                    if a > 1 && blockStruct(a-1).duration > 1.25*matStruct.ancillary.stimduration && blockStruct(a).sentIBI > 1.25*matStruct.ancillary.stimduration
                        disp(['(-# TDT crash assumed because previous block duration exceeeds standard stimduration AND sent IBI exceeds normal bounds  #-)'])
                        %crashCorrection = crashCorrection + abs(blockStruct(a).sentStartDelay); %Calculate permanent correction to carry forward
                        %blockStruct(a).tdtCrashDetected = 1;
                        %blockStruct(a).sentStartDelay = blockStruct(a).startTimeRel - blockStruct(a).sentTimeRel + crashCorrection; %A copy of the code above to overwrite (to a perfect 0, for this block at least)
                            %Note: Correct sign usage tenuous here
                    else
                        ['## No apparent extenuating explanation for disparity ##']
                        crash = yes
                    end
                else %Yes helpful field
                    if blockStruct(a).sentTDTCrash == 1
                        ['(-# TDT crash self-reported during experiment here #-)']
                    else
                        ['## No crash self-reported ##']
                        crash = yes
                    end
                end
            end

            %QA for self-reported crash
            if isnan(blockStruct(a).sentTDTCrash) ~= 1 && blockStruct(a).sentTDTCrash == 1
                %A little bit derivative in conjunction with the above QA but not worth trying to integrate into one delicate QA imo
                disp(['## Warning: TDT crash self-reported for block ',num2str(a),' ##'])
                %No crashCorrection code here because unsure what TDT crashes that don't proc sentStartDelay would even look like
            end
            %QA based on IBI
            if blockStruct(a).sentIBI >  1.5*matStruct.ancillary.stimduration && blockStruct(a).sentID - blockStruct(a-1).sentID < 2
                    %"Inter-Block Interval larger than expected AND not because Rest"
                        %Note: 1.25 * stimduration is a relatively tight tolerance, and values exceeding this by chance may occur
                ['## Warning: Inter-Block Interval for sEnt ',num2str(a),' larger than expected ##']
                if blockStruct(a).tdtCrashDetected ~= 1 %"Don't double up on QA"
                    crash = yes
                else
                    disp(['(-# But this appears to be because TDT crashed #-)'])
                end
            end
            %Silent QA based on posix diff, will be brought to awareness if non-empty at end of loop, rather than spamming on every instance
            if abs(blockStruct(a).sentStartPosixDiff) > 5 %"Difference between 'start' (detected block starts in data) and 'sent' posixes larger than 5s"
                badPosixDiffIndices = [badPosixDiffIndices, a];
            end
            %---
            %}
        end
        
        %QA for posix diff (Old position)
        if isempty(badPosixDiffIndices) ~= 1
            ['-# Caution: start and sent posixes different by >5s in at least ',num2str(size(badPosixDiffIndices,2)),' blocks #-']
            %badPosixDiffIndices
        end
        
        %------------------------------------------------------------------
        
        %QA for block duration
            %Basically a poor-man's substitute for a proper block verification
            %Note: If ever blocks correctly vary in length, this will be an issue
        durMed = nanmedian( [blockStruct.duration] );
        durStd = nanstd( [blockStruct.duration] );
            %If these are not done here they will be continuously recalculated, which will lead to aberrant ditching of every block
        for i = size(blockStruct,2):-1:1
            if abs( blockStruct(i).duration - durMed ) > 4*durStd && abs( blockStruct(i).duration - stimDuration ) > 0.05*stimDuration %Added 5% stimDuration to prevent aberrant overdetection with very (truthfullly) homogenous datasets
                ['-# Alert: Block #',num2str(i), ' duration outside normal range (',num2str(nanmedian( [blockStruct.duration] )),'+-',num2str(nanstd( [blockStruct.duration] )),') by ',num2str(abs( blockStruct(i).duration - nanmedian( [blockStruct.duration] ) )),'s; Ditching #-']
                blockStruct(i) = [];
            end
        end
        
        %------------------------------------------------------------------
        
        %Plot detected/sent synchronisation figure
        figure
        subplot(4,1,1)
        detectSentPosixDiffs =  abs( [blockStruct.startTimeEpoch] - [blockStruct.sentTimePosix] );
        plot( detectSentPosixDiffs )
        xlabel(['Block #'])
        ylabel(['Time difference (s)'])
        hold on
        for i = 1:size(blockStruct,2)
            if blockStruct(i).tdtCrashDetected == 1
                line([i,i],[nanmin(detectSentPosixDiffs),nanmax(detectSentPosixDiffs)],'LineWidth', 2, 'LineStyle', ':', 'Color', 'r')
            end
        end
        title(['Block by block difference between detected and sent posix [Including rests/chunks]'])
        subplot(4,1,2)
        plot(diff([blockStruct.startTimeEpoch]), 'b')
        xlabel(['Block #'])
        ylabel(['Detected inter-block interval (s)'])
        title(['Detected start time difference [Including rests/chunks]'])
        subplot(4,1,3)
        plot(diff([blockStruct.sentTimePosix]), 'm')
        xlabel(['Block #'])
        ylabel(['Sent inter-block interval (s) [Not including rests]'])
        title(['Sent start time difference [Including rests/chunks]'])
        subplot(4,1,4)
        plot( ([blockStruct.ID] - [blockStruct.sentID]) , 'g')
        xlabel(['Block #'])
        ylabel(['Block # diff.'])
        title(['Detected block ID diff. from sentID [Including rests/chunks]'])
        set(gcf,'Name',[flies(IIDN).name, ' - DetectedVsSentTiming']);

        %Resample sent TTL
        disp(['Performing other blockStruct processing steps...'])
        if isfield(EEG,'sourceFramerates') == 1 && isfield(EEG.sourceFramerates,'Wave') == 1
            fs = EEG.sourceFramerates.Wave;
        elseif isfield(EEG,'Wave') == 1 && isfield(EEG.Wave,'sourceFramerates') == 1 && isfield(EEG.Wave.sourceFramerates,'Wave') == 1
            fs = EEG.Wave.sourceFramerates.Wave;
        else
            ['#- Caution: fs could not be successfully retrieved from data -#']
            %fs = 2.4414e+04;
            fs = 2.44140625e+04; %Slightly more accurate number
        end
        resampleFreq = EEG.srate;
        %inputfreq = data.streams.InpP.fs;% Actual Sampling Frequency
        [N,D] = rat(resampleFreq/fs); % Rational Fraction Approximation
        for i = 1:size(blockStruct,2)
            for idx = 1:size(blockStruct(i).sentTTL,1)
                blockStruct(i).sentTTLResamp(idx,:) = round( resample(double(blockStruct(i).sentTTL(idx,:)), N, D) );% Resampled Signal 
                %Note: Rounding necessary because otherwise small decimals creep in
            end
        end
        blockStruct = rmfield( blockStruct, 'sentTTL' ); %Save (significant) memory

        clear EEG %Save some memory
        
        %if exist('overSaveStruct') == 1 & isfield(overSaveStruct,'flagParamStruct') == 1
        if isfield(matStruct,'flagParamStruct') == 1 %Second-to-last generation
            f1 = matStruct.flagParamStruct.f1(1); %Note: Hardcoded assumption of frequency invariance across CarrierOrder
            f2 = matStruct.flagParamStruct.f2(1); %Note: Hardcoded assumption of frequency invariance across CarrierOrder
        elseif isfield(matStruct,'ancillary') == 1 & isfield(matStruct.ancillary,'flagParamSaveStruct') == 1 %Current generation
            f1 = matStruct.ancillary.flagParamSaveStruct.f1(1); %Note: Hardcoded assumption of frequency invariance across CarrierOrder
            f2 = matStruct.ancillary.flagParamSaveStruct.f2(1);
        else
            f1 = 10; %Assumption, but QA code will check
            f2 = 2; %Assumption, QA code may check (but a little more difficult)
        end
        f = f1 / resampleFreq;
        %Amp = 1;
        %QA for likely failure of analysis
        if f1/resampleFreq > 0.5 || f2/resampleFreq > 0.5
            ['## ALERT: F1 OR F2 APPROACHES NYQUIST OF RESAMPLE; CORRECT FUNCTION OF ANALYSIS SCRIPT UNLIKELY ##']
            crash = yes
            %Technically this only applies to a known subset, but the unknown subset is likely high
        end
        
        %=========================================================================================================
        %SUPER CARRIERONLY PHOTODIODE SYNCHRONISATION MODO
        %parallel
        
        if doCarrieronlyPhotSynchronisation == 1 %&& useOutPData == 1 && outPExisting == 1
            disp([char(10),'----- Beginning carrieronly phot synchronisation -----'])
            %SplicedPhotOriginal = SplicedPhot;
            %carrierOnlyStartInds = [];
            phaseFixedBlocks = 0;
            for i = 1:size(blockStruct,2)
                phaseShift = NaN;
                try
                    proceed = isequal( blockStruct(i).sentCondition , 'carrieronly' ) == 1 & ...
                        ( isequal(blockStruct(i).sentColours , 'blue') == 1 || isequal(blockStruct(i).sentColours , 'green') );
                            %( ( contains( blockStruct(i).sentColours , 'blue' ) == 1 | strfind( blockStruct(i).sentColours , 'blue' ) == 1 ) || ... %Unwieldy, given carrieronly nature (But necessary if not using carrieronly in future)
                            %( contains( blockStruct(i).sentColours , 'green' ) == 1 | strfind( blockStruct(i).sentColours , 'green' ) == 1 ) ); %Also, this arrangement prone to crash because empty nature of strfind
                catch
                    disp(['-# Failure to identify colour groups for block ',num2str(i),' #-'])
                    proceed = 0;
                end
                %if isequal( blockStruct(i).sentCondition , 'carrieronly' ) == 1 & ...
                %        ( ( contains( blockStruct(i).sentColours , 'blue' ) == 1 | strfind( blockStruct(i).sentColours , 'blue' ) == 1 ) || ...
                %        ( contains( blockStruct(i).sentColours , 'green' ) == 1 | strfind( blockStruct(i).sentColours , 'green' ) == 1 ) )
                if proceed == 1
                    %temp = find( round(normalize(SplicedStim( carrierOnlyStimChan, blockStruct(i).range )),2) == 1, 1 ); %First (theoretical) instance of onset
                        %Caution: If stim data is junk this will silently fail without realising, on account of normalizing
                    coords = floor([blockStruct(i).range(1) - searchWindow*resampleFreq : blockStruct(i).range(1) + searchWindow*resampleFreq]);
                    stimSlice = SplicedStim( carrierOnlyStimChan, coords );
                    %Quick QA to establish whether valid phot data in this block
                    if nansum( abs( stimSlice - nanmean(stimSlice) ) > 1*nanstd(stimSlice) ) < 0.05*size(stimSlice,2) 
                        disp(['Carrieronly block ', num2str(i), ' may not have stim data'])
                        continue
                    end
                    stimSlice = round(normalize(stimSlice,'range',[0,1]),1);
                    %stimSlice = round(normalize(stimSlice,'range',[0,1]),0);
                    %stimSlice = normalize(round(stimSlice,2),'range',[0,1]);
                    stimSlice(stimSlice < 0.75) = 0;
                    stimSlice(stimSlice >= 0.75) = 1; %Ugly way to enforce binarity

                    temp = find( stimSlice >= 1, 1 ); %First peak
                    %tempDiff = find( [0,diff(stimSlice)] >= 0.4 ); %All peaks in window
                    
                    stimLabel = bwlabel(stimSlice);
                    tempLabelOnset = [];
                    for a = 1:nanmax(stimLabel)
                        %tempLabelOnset(a) = find(stimLabel == a, 1);
                        if nansum(stimLabel == a) > 1 
                            tempLabelOnset = [tempLabelOnset, find(stimLabel == a, 1) ];
                        end
                    end
                    %QA for no labels found
                    if isempty(tempLabelOnset) == 1
                        disp(['Carrieronly block ', num2str(i), ' no stim high values detected'])
                        continue
                    end
                    
                        
                    if isempty(temp) == 1 || temp == 1
                        disp(['Carrieronly block ', num2str(i), ' either failed stim data or first-frame onset'])
                        continue
                    else
                        photSlice = SplicedPhot(1, coords );
                            %Assumption of phot channel 1 as proper phot, but this is hardcoded elsehwere so...
                        %Testatory fig
                        %{
                        figure
                        plot(round(normalize(photSlice,'range',[0,1]),2),'Color','r')
                        hold on
                        plot(stimSlice, 'Color', 'k')
                        %}
                        %Quick QA to establish whether valid phot data in this block
                        if nansum( abs( photSlice - nanmean(photSlice) ) > 1*nanstd(photSlice) ) < 0.05*size(photSlice,2) 
                            disp(['Carrieronly block ', num2str(i), ' may not have phot data'])
                            continue
                        end
                        photSlice = round(normalize(photSlice,'range',[0,1]),2);
                        photSlice = round(normalize(photSlice,'range',[0,1]),1);
                        photSlice(photSlice < 0.75) = 0; %Aggressive noise removal (Won't help if noise reaches 1 level)
                        photSlice(photSlice >= 0.75) = 1;
                        temp2 = find( photSlice >= 1, 1 );
                        %temp2Diff = find( [0,diff(photSlice)] >= 0.4 ); %All peaks in window
                        photLabel = bwlabel(photSlice);
                        temp2LabelOnset = [];
                        for a = 1:nanmax(photLabel)
                            %tempLabelOnset(a) = find(stimLabel == a, 1);
                            if nansum(photLabel == a) > 1 
                                temp2LabelOnset = [temp2LabelOnset, find(photLabel == a, 1) ];
                            end
                        end
                        %QA for no labels found
                        if isempty(temp2LabelOnset) == 1
                            disp(['Carrieronly block ', num2str(i), ' no phot high values detected'])
                            continue
                        end
                        %QA for likely overdetection
                        if nanmin(diff(tempLabelOnset)) < nanmin( [(1/f1)*resampleFreq,(1/f2)*resampleFreq] )*0.75 || ...
                                nanmin(diff(temp2LabelOnset)) < nanmin( [(1/f1)*resampleFreq,(1/f2)*resampleFreq] )*0.75
                            disp(['-# Stim and/or phot overdetection (Too fast) may have occurred in block ',num2str(i),' #-'])
                            %abort
                            continue
                        end
                        %if temp ~= temp2 %Phot shift required (according to stim)
                        %if size(intersect(tempDiff,temp2Diff),2) < 0.25*nanmean( [length(tempDiff),length(temp2Diff)] ) %"Less than ~2 stim and phot onsets match"
                        if size(intersect(tempLabelOnset,temp2LabelOnset),2) < 0.25*nanmean( [length(tempLabelOnset),length(temp2LabelOnset)] ) %"Less than ~2 stim and phot onsets [based on bwlabel] match" (Daily reminder to thank the inventor of bwlabel in thesis acknowledgements)
                            %blrg
                            %QA to match sizes
                            %%tempDiff = tempDiff(1:nanmin([length(tempDiff),length(temp2Diff)]));
                            %%temp2Diff = temp2Diff(1:nanmin([length(tempDiff),length(temp2Diff)]));
                            tempLabelOnset = tempLabelOnset(1:nanmin([length(tempLabelOnset),length(temp2LabelOnset)]));
                            temp2LabelOnset = temp2LabelOnset(1:nanmin([length(tempLabelOnset),length(temp2LabelOnset)]));
                            %if nanmean(diff([tempDiff;temp2Diff])) >= 1 %"Consistent phase shift"
                            if abs(nanmean(diff([tempLabelOnset;temp2LabelOnset]))) >= 1 %"Consistent phase shift"
                                    %Note: In theory, half of the block having supremely early and vice versa would also yield an averaged diff of 0, but that seems unlikely
                                    %Secondary note: Just one missed cycle detection for either stim or phot can cause an aberrant false positive here (Though, intersect might save that)
                                %phaseShift = floor(nanmean(diff([tempDiff;temp2Diff])));
                                phaseShift = floor(nanmean(diff([tempLabelOnset;temp2LabelOnset])));
                                tic
                                if phaseShift > 0
                                    SplicedPhot( : , coords(temp2-phaseShift)-1:coords(temp2)-1 ) = []; %Hard shift (Not an efficient way of doing this but eh)
                                        %Note: Could also do all phase shifts as local (As in, pad with NaN after block) but that doesn't seem correct for what seems to be happening here 
                                    SplicedPhot( : , end:end+phaseShift+1 ) = NaN;
                                else
                                    SplicedPhot = [ SplicedPhot(:, 1:temp2-1)  , nan(size(SplicedPhot,1),abs(phaseShift)) , SplicedPhot(:, temp2:end) ];
                                    SplicedPhot(:, end+phaseShift:end) = [];
                                end
                                phaseFixedBlocks = phaseFixedBlocks + 1;
                                disp(['Phot. phase shift: ',num2str(phaseShift),' at block ',num2str(i),' corrected for whole SplicedPhot in ',num2str(toc),'s'])
                                %Testatory reporter figure
                                if phaseFixedBlocks <= 5
                                    figure
                                    plot(photSlice,'Color','r')
                                    hold on
                                    scatter(temp2LabelOnset,photSlice(temp2LabelOnset), [], 'r')
                                    plot(stimSlice*0.9, 'Color', 'k')
                                    scatter(tempLabelOnset,stimSlice(tempLabelOnset)*0.9, [], 'k')
                                    %And replot phtoSlice to show improvement
                                    photSlice = SplicedPhot(1, coords ); photSlice = round(normalize(photSlice,'range',[0,1]),2); photSlice = round(normalize(photSlice,'range',[0,1]),1); photSlice(photSlice < 1) = 0;
                                    plot(photSlice,'Color','m')
                                    legend([{'Phot original'},{'Phot scatter'},{'Stim'},{'Stim scatter'},{'Phot new'}])
                                    xlim([180,250])
                                    title([num2str(i)])
                                    %set(gcf,'Name', ['Phot phaseShift plot'])
                                    set(gcf,'Name', ['Phot phaseShift plot (',num2str(phaseFixedBlocks),' of 5 max)'])
                                end
                            end
                        end
                    end
                    
                end
                blockStruct(i).carrOnlyPhotPhaseShift = phaseShift;
            end
            
            disp([char(10),'-- ',num2str(phaseFixedBlocks),' blocks had phot phase shifts corrected --'])
        end
        
        %suddenly
        
        %=========================================================================================================

        
        %---------------------------------

        %Assemble underlying sine or square wave based on synchronisation
        %{
        %Moved above
        %if exist('overSaveStruct') == 1 & isfield(overSaveStruct,'flagParamStruct') == 1
        if isfield(matStruct,'flagParamStruct') == 1 %Second-to-last generation
            f1 = matStruct.flagParamStruct.f1(1); %Note: Hardcoded assumption of frequency invariance across CarrierOrder
            f2 = matStruct.flagParamStruct.f2(1); %Note: Hardcoded assumption of frequency invariance across CarrierOrder
        elseif isfield(matStruct,'ancillary') == 1 & isfield(matStruct.ancillary,'flagParamSaveStruct') == 1 %Current generation
            f1 = matStruct.ancillary.flagParamSaveStruct.f1(1); %Note: Hardcoded assumption of frequency invariance across CarrierOrder
            f2 = matStruct.ancillary.flagParamSaveStruct.f2(1);
        else
            f1 = 10; %Assumption, but QA code will check
            f2 = 2; %Assumption, QA code may check (but a little more difficult)
        end
        f = f1 / resampleFreq;
        %Amp = 1;
        %}

        %Detect whether data was square or sine
        sineIndex = [{'square'},{'sine'}];
        if useSaveStruct == 1
            didSine = matStruct.ancillary.flagParamSaveStruct.doSine;
        elseif isfield(matStruct,'flagParamStruct') == 1 && isfield(matStruct.flagParamStruct, 'doSine') == 1
            didSine = matStruct.flagParamStruct.doSine;
        else
            disp('# Could not automatically detect sine/square status; Defaulting to sine #')
            didSine = 1;
        end
        disp(['- Stimulus form: ',sineIndex{didSine+1},' -'])
        if didSine == 0
            captureWindowGeometry = windowGeometries{1};
        else
            captureWindowGeometry = windowGeometries{2};
            %QA for PTTs
            if enforcePTTPostStimulus == 1
                ['-# Alert: Cannot proceed with current PTT enforcement and sine stimuli #-']
                crash = yes
            end
        end
        baselineCorrectionMethodActive = NaN;
        if didSine == 0
            baselineCorrectionMethodActive = baselineCorrectionMethod;
        else
            baselineCorrectionMethodActive = 0;
            disp(['(Baseline correction forced to be pre-block)'])
        end
        
        %captureWindowSize = floor(1/f1 * resampleFreq * 0.95); %Window full-size (frames); Cannot be moved completely up top on account of f1 reliance
            %Note: Forces window to be <size of ISI
        captureWindowSize = floor(1/f1 * resampleFreq * sum(abs(captureWindowGeometry))); %Window full-size (frames)
        captureWindowGeometryActive = (1/sum(abs(captureWindowGeometry)))*captureWindowGeometry; %Unlike specified windowGeometries, this is in fractions of windowSize
        
        %QA in case of very low resampling rates
            %This tests to see if either the start (most likely) or end (less likely) of the capture window does not in fact differ from the centroid positions
                %Note that this is not *technically* a critical issue, but it is not great
        if ( floor(captureWindowGeometryActive(1)*captureWindowSize)+1 == 0 ) || ( floor(captureWindowGeometryActive(2)*captureWindowSize) == 0 );
            ['## Alert: One or more elements of captureWindowGeometryActive has failed (Likely due to resampling frequency) ##']
            crash = yes
        end

        for i = 1:size(blockStruct,2)
            artUnderSignal = zeros(1,size(blockStruct(i).range,2));

            t = [1:size(artUnderSignal,2)];

            if didSine == 1 
                artUnderSignal = -sin(2*pi*f*t);
            else
                artUnderSignal = -square(2*pi*f*t);
            end

            blockStruct(i).artUnderSignal = artUnderSignal; %Note: High f1 frequencies may result in this being clipped to sub-1 values

            %plot( [blockStruct(i).startEnd(1):blockStruct(i).startEnd(1)+size(blockStruct(i).artUnderSignal,2)-1], blockStruct(i).artUnderSignal*2e5 , 'r') %Tacks on to virtual channels fig for testatory
        end
        
        disp(['-- Attempting to synchronise artificial sine/square waves and TTL with virtual channel data for all blocks --'])
        unsuccessfulSyncCount = 0;
        successfulOffsetData = [];
        tic
        %Synchronise artificial underlying sine with virtual channel (EXPERIMENTAL)
        for i = 1:size(blockStruct,2)
            relStimSignalData = ( allSignalData(blockStruct(i).range) - nanmean(allSignalData(blockStruct(i).range)) ) / nanmax(allSignalData(blockStruct(i).range));
                %Adjust allSignalData to be relative to its own mean data, then make it a proportion for easy comparison with artUnderSignal
            relStimSignalData = relStimSignalData(1:size(blockStruct(i).artUnderSignal,2)); %Will fail if artUnderSignal is larger than virtual channel data for some reason
                %Truncate relStimSignalData to be same length as artUnderSignal (Perhaps not an optimal implementation...)
            relArtSignalData = blockStruct(i).artUnderSignal;
                %No processing necessary for artUnderSignal
                
            if nansum(relStimSignalData > 0.75) ~= 0 %Check for valid data
                %Select mode for synchronisation
                if synchroniseMode == 1
                    disp(['-- Using peak finding to synchronise between stim and art --'])
                    if didSine == 1
                        [~, relStimPeaksLOCS, ~, ~] = findpeaksbase( relStimSignalData , 'MinPeakHeight', 0.75 , 'MinPeakDistance', (1/f1)*resampleFreq*0.5 );
                        [~, relArtPeaksLOCS, ~, ~] = findpeaksbase( relArtSignalData , 'MinPeakHeight', 0.75 , 'MinPeakDistance', (1/f1)*resampleFreq*0.5 );
                        %No QA is really needed here, since there is only one positive peak per cycle for sine waves
                    else
                        [~, relStimPeaksLOCS, ~, ~] = findpeaksbase( relStimSignalData , 'MinPeakHeight', 0.75 , 'MinPeakDistance', (1/f1)*resampleFreq*0.25 ); %Designed catch both positive and negative deflections of TTL, due to shorter lonesome window
                        [~, relArtPeaksLOCS, ~, ~] = findpeaksbase( relArtSignalData , 'MinPeakHeight', 0.75 , 'MinPeakDistance', (1/f1)*resampleFreq*0.25 );
                        stimLOCSCoords =  floor(relStimPeaksLOCS+(halfWidthTTLCorrection*(1/f1)*resampleFreq)); artLOCSCoords =  floor(relArtPeaksLOCS+(halfWidthTTLCorrection*(1/f1)*resampleFreq));
                        stimLOCSCoordsBool = zeros(1,size(stimLOCSCoords,2)); artLOCSCoordsBool = zeros(1,size(artLOCSCoords,2));
                        stimLOCSCoordsBool( stimLOCSCoords > size(relStimSignalData,2) ) = 1; artLOCSCoordsBool( artLOCSCoords > size(relArtSignalData,2) ) = 1;
                        stimLOCSCoordsBool( relStimSignalData( stimLOCSCoords(stimLOCSCoordsBool==0) ) < 0 ) = 1; artLOCSCoordsBool( relArtSignalData( artLOCSCoords(artLOCSCoordsBool==0) ) < 0 ) = 1;
                        relStimPeaksLOCS( stimLOCSCoordsBool == 1 ) = []; %Remove all detected peaks where 25% later was a low state (i.e., the end components of the TTL)
                        relArtPeaksLOCS( artLOCSCoordsBool == 1 ) = [];
                        %relArtPeaksLOCS( relArtSignalData( artLOCSCoords ) < 0 ) = [];
                            %Note: This filtering method will fail if the duty cycle is odd (as halfwidthTTLCorrection% later might end up being the up state of the next cycle or similar)
                        %QA to check that correct part of square wave slope has been captured (on average)
                        collectedStimSignalPost = relStimSignalData( floor(relStimPeaksLOCS + (0.25*(1/f1)*resampleFreq)) ); collectedArtSignalPost = relArtSignalData( floor(relArtPeaksLOCS + (0.25*(1/f1)*resampleFreq)) );
                        if nanmedian(collectedStimSignalPost) < 0.75 | nanmedian(collectedArtSignalPost) < 0.75
                            ['## Alert: Failure in correct signal peak detection on square waves for either stim or artificial underlying signal ##']
                            crash = yes
                        end
                        %Testatory figure
                        figure
                        plot( relStimSignalData )
                        hold on
                        scatter( relStimPeaksLOCS , relStimSignalData( relStimPeaksLOCS ) )
                        title(['Stimulus data and detected stimulus onsets'])
                    end

                    if abs( size(relStimPeaksLOCS,2) - size(allSignalData(blockStruct(i).range),2)/resampleFreq * f1 ) < size(allSignalData(blockStruct(i).range),2)/resampleFreq * f1 * 0.05
                        sortCombPeaksLOCS = sort([relStimPeaksLOCS , relArtPeaksLOCS]);

                        [N,X] = hist(diff(sortCombPeaksLOCS),256);
                        averageMinDist = X(find( N == nanmax( N(1:floor(size(N,2)/2) ) ) , 1));
                           %Finds the average smallest difference between the two sets of peaks
                               %Use of a hist means that artefactual small differences are not abberantly used
                               %Selecting from the first half of the data excludes the half-phase separated large difference between peak positions
                           %Note: There is a chance this method could find a minimum difference that is a full phase too big
                        if round(averageMinDist,0) == 0 || ...
                                ( size(relStimPeaksLOCS,2) == size(relArtPeaksLOCS,2) && nansum(relStimPeaksLOCS == relArtPeaksLOCS) == size(relStimPeaksLOCS,2) ) 
                                %"No synchronisation needed because sines are already near or are perfectly matching"
                            synct = [];
                            syncArtUnderSignal = artUnderSignal;
                            averageMinDist = 0; %Overwrite to indicate that no synchronisation was applied
                        else  
                            synct = [1 : size(blockStruct(i).artUnderSignal,2) + round(averageMinDist,0)]; %Make a new timescale that is longer than the source by the phase offset
                            if didSine == 1
                                syncArtUnderSignal = -sin(2*pi*f*synct); %Make a new artificial sine wave
                            else
                                syncArtUnderSignal = -square(2*pi*f*synct);
                            end
                            syncArtUnderSignal = syncArtUnderSignal( round(averageMinDist,0) : end ); %Select from <phase offset size> to data end to offset data
                               %Note: A method that applies a constant offset to the original phase would probably be superior here, but I don't know math
                        end

                        %Save synchronised artificial sine/square
                        blockStruct(i).syncArtUnderSignal = syncArtUnderSignal;
                        blockStruct(i).successfulSignalSync = 1;
                        blockStruct(i).offsetApplied = round(averageMinDist,0);
                        successfulOffsetData = [successfulOffsetData, blockStruct(i).offsetApplied];

                        %Synchronise TTL
                        syncTTLResamp = [zeros( size(blockStruct(i).sentTTLResamp,1) , blockStruct(i).offsetApplied ) , blockStruct(i).sentTTLResamp ];
                        blockStruct(i).syncSentTTLResamp = syncTTLResamp;
                        
                        %####
                        %Synchronise OutP (if applicable)
                        if useOutPData == 1 && outPExisting == 1
                            %temp = allOutPData( : , blockStruct(i).range ); %Grab
                            temp = SplicedOutP( : , blockStruct(i).range ); %Grab
                            if synchroniseOutP == 0
                                blockStruct(i).syncOutP = temp;
                            else
                                offShift = blockStruct(i).offsetApplied;
                                if offShift > 0
                                    blockStruct(i).syncOutP = [ zeros( size(temp,1) , offShift-1 ) , temp( : , 1 : end- (offShift-1) ) ]; 
                                else
                                    blockStruct(i).syncOutP = [ temp( : , abs(offShift)+1 : end ) ,  zeros( size(temp,1) , abs(offShift) ) ]; 
                                end
                                %QA
                                if size( blockStruct(i).syncOutP , 2 ) ~= size( temp , 2 )
                                    ['## Critical OutP shifting correct sizing failure ##']
                                    crash = yes
                                end
                            end
                        end
                        %####

                    else

                        disp(['# Disparity in detected peaks for virtual ',sineIndex{didSine+1},' wave (Block ',num2str(i),') #'])
                        blockStruct(i).syncArtUnderSignal = NaN;
                        blockStruct(i).successfulSignalSync = 0;
                        blockStruct(i).offsetApplied = NaN;
                        unsuccessfulSyncCount = unsuccessfulSyncCount + 1;
                        blockStruct(i).syncSentTTLResamp = NaN;
                        
                        if useOutPData == 1 && outPExisting == 1
                            blockStruct(i).syncOutP = NaN;
                        end
                        
                    end
                    
                else %Use subtraction diff
                    %disp(['-- Using subtraction to synchronise stim and art --'])
                    
                    relStimSignalDataNorm = normalize( relStimSignalData , 'range', [-1,1] );
                    
                    stimEstimateWidthUse = ceil( (1/f1)*resampleFreq * 0.5 ); %Estimate width of high component (or low component) of 50/50 sized TTL

                    %offsetRangeToTest = [-stimEstimateWidthUse:1:stimEstimateWidthUse]; %Assemble a testing range from -0.5 highwidth to +0.5 highwidth
                    offsetRangeToTest = [-stimEstimateWidthUse:1:stimEstimateWidthUse]; %Assemble a testing range from -0.5 highwidth to +0.5 highwidth
                    offsetMismatchScores = []; %Store scores
                    a = 1;
                    for offSize = offsetRangeToTest %Iterate
                        shiftRelArtSignalData = circshift( relArtSignalData , offSize ); %Shift art signal by testing offset
                        thisOffsetMismatchScore = floor(nansum(abs(shiftRelArtSignalData - relStimSignalData))); %Calculate mismatch from stim signal
                            %This system should be robust to odd stimSignals, since they will all be equally divergent 
                        offsetMismatchScores(a) = thisOffsetMismatchScore; %Save score
                        a = a + 1;
                    end
                    
                    [~, optimalOffsetInd] = nanmin( offsetMismatchScores );
                    
                    syncArtUnderSignal = circshift( relArtSignalData , offsetRangeToTest(optimalOffsetInd) );
                    
                    %Save synchronised artificial sine/square
                    blockStruct(i).syncArtUnderSignal = syncArtUnderSignal;
                    blockStruct(i).successfulSignalSync = 1;
                    blockStruct(i).offsetApplied = offsetRangeToTest(optimalOffsetInd);
                    successfulOffsetData = [successfulOffsetData, blockStruct(i).offsetApplied];
                    
                    %Synchronise TTL                    
                    syncTTLResamp = [zeros( size(blockStruct(i).sentTTLResamp,1) , blockStruct(i).offsetApplied ) , blockStruct(i).sentTTLResamp ]; %Old system
                    %syncTTLResamp = circshift( blockStruct(i).sentTTLResamp , offsetRangeToTest(optimalOffsetInd) , 2 ); %New
                        %Note dimension specification, which is v. important
                    blockStruct(i).syncSentTTLResamp = syncTTLResamp;
                    
                    %####
                    %Synchronise OutP (if applicable)
                    if useOutPData == 1 && outPExisting == 1
                        %temp = allOutPData( : , blockStruct(i).range ); %Grab
                        temp = SplicedOutP( : , blockStruct(i).range ); %Grab
                        if synchroniseOutP == 0
                            blockStruct(i).syncOutP = temp;
                        else
                            offShift = blockStruct(i).offsetApplied;
                            if offShift > 0
                                blockStruct(i).syncOutP = [ zeros( size(temp,1) , offShift-1 ) , temp( : , 1 : end- (offShift-1) ) ]; 
                            else
                                blockStruct(i).syncOutP = [ temp( : , abs(offShift)+1 : end ) ,  zeros( size(temp,1) , abs(offShift) ) ]; 
                            end
                            %QA
                            if size( blockStruct(i).syncOutP , 2 ) ~= size( temp , 2 )
                                ['## Critical OutP shifting correct sizing failure ##']
                                crash = yes
                            end
                        end
                    end
                    %Figure for sync
                    %{
                    figure
                    plot( relStimSignalData )
                    hold on
                    plot( circshift( relArtSignalData , 0 )*1.025 )
                    %plot( circshift( relArtSignalData , -7 )*1.05 )
                    plot( circshift( relArtSignalData , offShift )*1.1 )
                    plot( allOutPData( : , blockStruct(i).range )*1.2 )
                    plot( allOutPData( 2 , blockStruct(i).range )*1.2 )
                    plot( allOutPData( 3 , blockStruct(i).range )*1.225 )
                    %}
                    %####
                                        
                %synchroniseMode end
                end
            else

                disp(['# Could not detect sine wave in virtual channel for synchronisation (Block ',num2str(i),') #'])
                blockStruct(i).syncArtUnderSignal = NaN;
                blockStruct(i).successfulSignalSync = 0;
                blockStruct(i).offsetApplied = NaN;
                unsuccessfulSyncCount = unsuccessfulSyncCount + 1;
                blockStruct(i).syncSentTTLResamp = NaN;
                if useOutPData == 1 && outPExisting == 1
                    blockStruct(i).syncOutP = NaN;
                end
                
            end
    
        end

        disp(['-- Artificial sine/square waves and TTL synchronised with virtual channel data in ',num2str(toc),'s --'])

        %Apply assumed synchronisation to blocks that could not be initially synchronised (EXPERIMENTAL)
        if unsuccessfulSyncCount > 0
            disp(['- Applying averaged synchronisation offset to blocks that failed synchronisation -'])

            if isempty(successfulOffsetData) ~= 1
                averageOffset = round(nanmean(successfulOffsetData),0);
            else
                ['## No successful synchronisation detected to have been completed ##']
                crash = yes
            end

            for i = 1:size(blockStruct,2)
                if blockStruct(i).successfulSignalSync == 0
                    if averageOffset == 0 %Perfect synchronisation on average
                        synct = [];
                        syncArtUnderSignal = blockStruct(i).artUnderSignal;
                    else
                        synct = [1 : size(blockStruct(i).artUnderSignal,2) + averageOffset]; %Make a new timescale that is longer than the source by the phase offset
                        if didSine == 1
                            syncArtUnderSignal = -sin(2*pi*f*synct); %Make a new artificial sine wave
                        else
                            syncArtUnderSignal = -square(2*pi*f*synct); %Make a new artificial sine wave
                        end
                        syncArtUnderSignal = syncArtUnderSignal( averageOffset : end );
                    end
                    blockStruct(i).syncArtUnderSignal = syncArtUnderSignal;
                    blockStruct(i).offsetApplied = averageOffset;

                    syncTTLResamp = [zeros( size(blockStruct(i).sentTTLResamp,1) , averageOffset ) , blockStruct(i).sentTTLResamp ];
                    blockStruct(i).syncSentTTLResamp = syncTTLResamp;
                    
                    %####
                    %Synchronise OutP (if applicable)
                    if useOutPData == 1 && outPExisting == 1
                        %temp = allOutPData( : , blockStruct(i).range ); %Grab
                        temp = SplicedOutP( : , blockStruct(i).range ); %Grab
                        if synchroniseOutP == 0
                            blockStruct(i).syncOutP = temp;
                        else
                            offShift = blockStruct(i).offsetApplied;
                            if offShift > 0
                                blockStruct(i).syncOutP = [ zeros( size(temp,1) , offShift-1 ) , temp( : , 1 : end- (offShift-1) ) ]; 
                            else
                                blockStruct(i).syncOutP = [ temp( : , abs(offShift)+1 : end ) ,  zeros( size(temp,1) , abs(offShift) ) ]; 
                            end
                            %QA
                            if size( blockStruct(i).syncOutP , 2 ) ~= size( temp , 2 )
                                ['## Critical OutP shifting correct sizing failure ##']
                                crash = yes
                            end
                        end
                    end
                    %####
                    
                end
            end
            disp(['- Averaged synchronisation offset of ',num2str(averageOffset),' applied to ',num2str(unsuccessfulSyncCount),' blocks -'])
        end
        
        %Testatory for sync
        figure
        plot(relStimSignalData, 'b')
        hold on
        plot(relArtSignalData, 'r')
        ylim([-1.25, 1.25])
        xlim([0,400])
        if synchroniseMode == 1
            scatter( relStimPeaksLOCS, [repmat(1.1, 1, size(relStimPeaksLOCS,2))] , [], 'b' )
            scatter( relArtPeaksLOCS, [repmat(1.2, 1, size(relArtPeaksLOCS,2))] , [], 'r' )
        end
        plot(syncArtUnderSignal*1.05, 'm')
        plot(syncTTLResamp(3,:)*0.5, 'LineStyle', ':', 'Color', 'g') %Plot oddball TTL
        plot(blockStruct(i).syncSentTTLResamp(2,:)*0.4, 'LineStyle', ':', 'Color', 'b') %Carrier TTL (of last block)
        set(gcf,'Name',flies(IIDN).name);

        %Identify personalised (per block) baseline data
        baselinePreOffset = 0.25; %"Roll back baselinePreOffset seconds before selecting baseline, in case of mild desync"
        baselineSize = 0.5; %How much baseline to extract, in s (Note: Must be less than the average time between blocks)
        for i = 1:size(blockStruct,2)
            prosBaselineStartEnd = [nanmin(blockStruct(i).range) - resampleFreq*baselinePreOffset - resampleFreq*baselineSize , nanmin(blockStruct(i).range) - resampleFreq*baselinePreOffset];
            if ( i == 1 & prosBaselineStartEnd(1) < 1 ) | ...
                    ( i > 1 & prosBaselineStartEnd(1) < nanmax(blockStruct(i-1).range) ) | ...
                    ( prosBaselineStartEnd(1) > nanmin(blockStruct(i).range) ) 
               %"First block and attempted to sample before data exists OR not-first block and attempted to sample from prior block OR attempted to sample from current block"
                %The first condition is highly unlikely unless trials began practically immediately after recording started
                %The second condition is possible if the time between blocks is reduced for some reason
                %The third condition could occur if the baselinePreOffset is not large enough or the baselineSize is too large
                ['## Error in coordinate selection for baseline for block ',num2str(i), ' ##']
                if blockStruct(i).tdtCrashDetected == 1 || ( i ~= size(blockStruct,2) && blockStruct(i+1).tdtCrashDetected == 1 )
                    disp(['(-# Probably because of TDT crash; Using minimal available data as baseline #-)'])
                    prosBaselineStartEnd = [ nanmax(blockStruct(i-1).range) : nanmin(blockStruct(i).range) ]; %Use entire range between end of last block and start of this block as baseline
                        %Note: Will crash if this is first block
                        %Second note: This block will be noisier and probably shorter (by a variable amount) than a normal baseline block
                else
                    crash = yes
                end
            end
            baselineStartEnd = prosBaselineStartEnd;
            blockStruct(i).blockBaseline = SplicedData(:,baselineStartEnd(1):baselineStartEnd(2)-1); %Minus 1 to keep nicely 1s*sampleRate in size
            blockStruct(i).blockBaselineAv = nanmean(blockStruct(i).blockBaseline,2); %Ditto above except averaged across time for speediness in later use
        end
        
        %=============================================================================================
        %Post-synchronise select data according to stim onset
        if applyAggressivePostSync == 1
            %Automate (Without scatter)
            %acRange = [1425];
            acRange = [1:size(blockStruct,2)];

            %allHiOnsets = [ nan(5,size(blockStruct,2)) ];
            allHiOnsets = [];
            %ditchList = []; %Was written in preparation for a phost-based block ditching system that was not implemented

            for i = acRange%1:size(blockStruct,2)
                data = [];
                %coords = floor([ nanmin( blockStruct(i).range ) - 0.5*resampleFreq : nanmin( blockStruct(i).range ) + 2*resampleFreq ]); %Different coords from above plots, to increase speed
                coords = [ nanmin( blockStruct(i).range ) - floor(0.5*resampleFreq) : nanmin( blockStruct(i).range ) + floor(2*resampleFreq) ]; %Different coords from above plots, to increase speed
                    %Minor modification to armour against weird resample freqs
                if modernData == 1 %Note: It is an assumption that modernData corresponds also to modern stim data  
                    thisStimData = normalize(SplicedStim(1, coords )); %Current assumption that this is meant to target stimtype invariant sync cycle
                    %qaTarget = -42; %Need to empirically determine
                else
                    thisStimData = normalize(SplicedStim(2, coords )); %....which is true here for ch. 2
                    %qaTarget = 4;
                end
                %Quick QA for correct stim row targetting
                %(This QA also doing double duty to protect against modernData incorrect targetting)
                    %((Although it won't stop accidental targetting of the oddball stim channel when the carrieronly was intended, etc))
                if nanstd( thisStimData(1:ceil( 0.5*resampleFreq/2 )) )*2 > nanstd( thisStimData(end-ceil( 0.5*resampleFreq/2 ):end) )
                    disp(['## Alert: stimData pre-baseline indistinguishable from active section (Block ',num2str(i),') ##'])
                    %This works on the assumption that the first 0.5s of the coords are pre stimulus
                    %crash = yes
                    allHiOnsets(:,i) = nan( size(allHiOnsets,1) , 1 ); %Horrible issues if first element called
                    continue
                end
                %Determine channel for stim/sentTTL comparison
                    %(Deprecated with current state of thisSync boolean operations)
                %{
                if isempty( strfind( blockStruct(i).sentCondition , 'carrieronly' ) ) ~= 1
                    if modernData == 1
                        qaTarget = -42; %Need to find proper value
                    else
                        qaTarget = 3;
                    end
                else
                    if modernData == 1
                        qaTarget = -42; %Need to find proper value
                    else
                        qaTarget = 4;
                    end
                end
                %}
                %thisOutPData = SplicedOutP(1:3, coords );
                thisPhotData = normalize( SplicedPhot(1,coords) - SplicedPhot(1,coords(1)) );
                %thisLFPData = normalize( SplicedData(1,coords) ); %Not currently confident in trying to synchronise LFP data
                %Quick QA for phot
                %photBaseline = SplicedPhot(1, coords(1:floor(0.25*resampleFreq)) );
                if (firstSentTimePosix - eegStartTimePosix) > 5 %"First trial sent at least 5s after EEG data start"
                    photBaseline = SplicedPhot(1, 1:floor(5*resampleFreq) ); %Use literal first 5 seconds of data
                else
                    photBaseline = SplicedPhot(1, coords(1:floor(0.25*resampleFreq)) ); %Use data from 0.25s before stim onset
                        %Note: With extreme phot desnc, this time portion can actually capture phot events
                end
                if nanmax( SplicedPhot(1,coords) ) - nanmean( SplicedPhot(1,coords) ) < nanmean( photBaseline ) + 4*nanstd( photBaseline ) %Only support for positive phot signal
                    disp(['-# Warning: No apparent phot signal detected for block ',num2str(i),' (Max ',num2str(nanmax( SplicedPhot(1,coords) ) / nanmean( SplicedPhot(1,coords) )),'x mean) #-'])
                    if nanmax( -SplicedPhot(1,coords) ) - nanmean( -SplicedPhot(1,coords) ) < nanmean( photBaseline ) + 4*nanstd( photBaseline )
                        disp(['(But signal might be inverted based on evidence)'])
                    end
                    if isempty( strfind( blockStruct(i).sentColours , 'blankblank' ) ) == 1
                        crash = yes
                    else
                        disp(['[This is expected because stimuli were blankblank]'])
                    end
                    thisPhotData = nan(1,size(thisStimData,2));
                end

                data = [ thisStimData ; thisPhotData ];%; normalize(SplicedData(1,coords))*0.25 ]; %'Simplified'/Made OutP optional

                dataTargs = [ 0.95 ; 0.95 ];%; nanmedian( data(6, data(6, : ) > 0 ) ) ]; %Hardcoded and curated/No OutP

                dataInv = [ -1 ; 1]; %Inversion where necessary (To allow the negative deflection of SplicedStim to be detected while the rest are searched for positive deflections)
                    %Note: Very odd stimulus cases (e.g. Missing oddball, big variance between carrier/oddball) may lead to odd normalize behaviour and thus problematic onset detection for Phot data

                if useOutPData == 1
                    thisOutPData = SplicedOutP(1:3, coords );
                    data = [data; thisOutPData];
                    dataTargs = [dataTargs; 1 ; 1 ; 1 ];
                    dataInv = [dataInv ; 1 ; 1 ; 1 ];
                end

                %Tack on extra copy of stimData for half-phase phot data synchronisation
                data = [data; thisStimData];
                dataTargs = [dataTargs; 0.95];
                dataInv = [ dataInv ; 1 ]; %Don't invert copy of stimData

                dataHiOnset = [];
                for rowInd = 1:size(data,1)
                    %temp = find( data(rowInd,:) >= dataTargs(rowInd) , 1 );
                    %temp = find( abs(data(rowInd,:)) >= dataTargs(rowInd) , 1 ); %Abs to catch negative deflection of SplicedStim better
                    temp = find( dataInv(rowInd)*data(rowInd,:) >= dataTargs(rowInd) , 1 );
                    if isempty( temp ) ~= 1
                        dataHiOnset(rowInd,1) = temp;
                    else
                        dataHiOnset(rowInd,1) = NaN;
                    end
                end
                
                allHiOnsets(:,i) = nan( size(data,1) , 1 ); %Will be overwritten with values if applicable
                
                %QA to check for interference from first-cycle oddball events
                    %Note: This critical relies on syncSentTTLResamp (from matStruct) row 2 being a carrier indicator 
                thisSync = [ nan( size(blockStruct(i).syncSentTTLResamp,1) , floor(0.5*resampleFreq) ) , blockStruct(i).syncSentTTLResamp(:,1:floor(2*resampleFreq)) ];
                    %resampleFreq multipliers based on values currently used above
                    %Secondary note: syncSentTTLResamp comes from sentStimuli TTL vector, not stimData
                %if nansum( thisSync( 2 , dataHiOnset( isnan(dataHiOnset)~=1 ) + (1/f1*resampleFreq*halfWidthTTLCorrection) ) == 0 ) > 0 && isempty( strfind( blockStruct(i).sentCondition, 'oddball') ) ~= 1
                    %This boolean checks all stim channels against the sent TTL, but it is weak to oddball presence (and subsequent 'correct' determination of an [incorrect] first-cycle oddball event
                    %Note: This aberrantly sets coloured oddball blocks to be skipped where they could probably be photosynchronised
                %if nansum( thisSync( 2 , dataHiOnset( qaTarget ) + (1/f1*resampleFreq*halfWidthTTLCorrection) ) == 0 ) > 0
                    %This boolean has inbuilt halfwidth TTL correction and relies on different channels depending on modernData and block type
                if nansum( thisSync( 2 , dataHiOnset( end ) ) == 0 ) > 0
                    %This boolean ditches all that and just uses the row used for the eventual phase shift (i.e. the end one)
                    %Note: Untested whether this works for jittering missing oddball 
                    disp(['-# Caution: First-cycle TTL low event detected in block ',num2str(i),'; Photosynchronisation skipped for this block #-'])
                else
                    allHiOnsets(:,i) = dataHiOnset; %Moved here to only be enacted if all good
                end

                %allHiOnsets(:,i) = nan( size(data,1) , 1 );
                %allHiOnsets(:,i) = dataHiOnset;
                %disp([num2str(i),' processed'])

                %Plot if not ridic numbers of targets
                if size(acRange,2) <= 3
                    figure
                    hold on
                    for rowInd = 1:size(dataHiOnset,1)
                        plot(data(rowInd,:))
                        if isnan( dataHiOnset(rowInd) ) ~= 1
                            scatter( dataHiOnset(rowInd) , data(rowInd,dataHiOnset(rowInd)  ) )
                        end
                    end
                    %plot( thisLFPData, 'Color', 'k' ) %Tack on LFP
                    plot( thisLFPData, 'Color', [0.8,0.8,0.8] ) %Tack on LFP
                    title([num2str(i), ' - ',blockStruct(i).sentColours,' - ',blockStruct(i).sentCondition])
                    legend
                    %Tack on sync data
                    thisSync = [ nan( size(blockStruct(i).syncSentTTLResamp,1) , floor(0.5*resampleFreq) ) , blockStruct(i).syncSentTTLResamp(:,1:floor(2*resampleFreq)) ];
                        %resampleFreq multipliers based on values currently used above
                    for row = 1:size( thisSync,1 )
                        plot( thisSync(row,:) )
                    end
                end
                
            end
            %---
            %Plot automate results
            if size(acRange,2) == size(blockStruct,2)
                figure
                hold on
                for rowInd = 1:size(allHiOnsets,1)
                    plot(allHiOnsets(rowInd,:))
                end
                legend
                title(['All blocks - pre sync onsets'])
                set(gcf,'Name',[flies(IIDN).name, ' - SyncOnsetPre']);
            end
            %---
            %Post-synchronise 
            for i = acRange
                %Phot
                phaseShift = allHiOnsets(2,i) - allHiOnsets( end , i ); %Use non-inverted stimData copy for half-phase sync
                if isnan(phaseShift) ~= 1
                    photRange = blockStruct(i).range + phaseShift; %Note: No protection against proximal or distal overrun, but the odds of such a thing are v. low
                        %Secondary note: Be careful with plus vs minus for shifting here
                else
                    photRange = blockStruct(i).range;
                    disp(['-# Caution: NaN phaseShift detected for phot post-sync for block ',num2str(i),' #-'])
                end
                blockStruct(i).photRange = photRange;
                blockStruct(i).photPostSyncShift = phaseShift;
                %OutP (if applicable)
                if useOutPData == 1
                    phaseShift = nanmin( allHiOnsets(3:5,i) ) - allHiOnsets(1,i); %Nanmin because want to find first onset, not oddball or similar
                    if isnan(phaseShift) ~= 1
                        outPRange = blockStruct(i).range + phaseShift; %Note: No protection against proximal or distal overrun, but the odds of such a thing are v. low
                    else
                        outPRange = blockStruct(i).range;
                        disp(['-# Caution: NaN phaseShift detected for OutP phot post-sync for block ',num2str(i),' #-'])
                    end
                    blockStruct(i).OutPRange = outPRange;
                    blockStruct(i).syncOutP = SplicedOutP(:,outPRange); 
                        %Note: All OutP data is synchronised here, even the 4th channel, which (currently) relates to red light, even though its onset is not used for sync calculations
                    blockStruct(i).OutPPostSyncShift = phaseShift;
                end

                %Figure to report
                if size(acRange,2) <= 3 %Only run if not ridiculous number of plots
                    coords = floor([ nanmin( blockStruct(i).range ) - 0.5*resampleFreq : nanmin( blockStruct(i).range ) + 2*resampleFreq ]); %Different coords from above plots, to increase speed
                    postPhotCoords = [ nanmin( blockStruct(i).photRange ) - 0.5*resampleFreq : nanmin( blockStruct(i).photRange ) + 2*resampleFreq ]; %??????????????????

                    thisStimData = normalize(SplicedStim(1, coords ));
                    thisPhotData = normalize( SplicedPhot(1,coords) - SplicedPhot(1,coords(1)) );

                    thisPostPhotData = normalize( SplicedPhot(1,postPhotCoords) - SplicedPhot(1,postPhotCoords(1)) );
                    
                    thisLFPData = normalize( SplicedData(1,coords) );

                    if useOutPData == 1
                        postOutPCoords = [ nanmin( blockStruct(i).OutPRange ) - 0.5*resampleFreq : nanmin( blockStruct(i).OutPRange ) + 2*resampleFreq ];
                        thisOutPData = SplicedOutP(1:3, coords );
                        thisPostOutPData = SplicedOutP(1:3, postOutPCoords );
                    end

                    figure
                    hold on
                    plot( thisStimData, 'Color', 'k' )
                    plot( thisPhotData, 'LineStyle', ':'  )
                    plot( thisPostPhotData)
                    if useOutPData == 1
                        for rowInd = 1:size(thisOutPData,1)
                            plot( thisOutPData(rowInd,:), 'LineStyle', ':' )
                            plot( thisPostOutPData(rowInd,:) )
                        end
                    end
                    plot( thisLFPData, 'Color', 'm' )
                    legend
                    title([num2str(i), ' - ',blockStruct(i).sentColours,' - post sync'])
                end
            end
            %---
            %Post-post sync report
            if size(acRange,2) == size(blockStruct,2)
                figure
                hold on
                plot( allHiOnsets(1,:) )
                plot( allHiOnsets(2,:) - [blockStruct.photPostSyncShift] )
                if useOutPData == 1
                    for rowInd = 1:3
                        plot( allHiOnsets(2+rowInd,:) - [blockStruct.OutPPostSyncShift] )
                    end
                end
                legend
                title(['All blocks - post sync onsets'])
                set(gcf,'Name',[flies(IIDN).name, ' - SyncOnsetPost']);
            end
            %QA
            if nanmax(abs([blockStruct.photPostSyncShift])) >= 1.0/f1*resampleFreq
                ['-# Caution: Aberrant full-phase synchronisation shift/s may have occurred #-']
                %crash = yes %Will almost certainly make this a non-crash incident once spurious frequency determined
            end
            %---
            if useOutPData ~= 1
                disp(['-- Phot data post-synchronised  --'])
            else
                disp(['-- Phot and OutP data post-synchronised  --'])
            end
            if size(acRange,2) ~= size(blockStruct,2)
                ['-# Alert: Post-synchronisation was run in debug mode #-'] %This is to prevent a custom acRange from being set and then accidentally using that for normal operation
            end
        else %No sync
            for i = 1:size(blockStruct,2)
                blockStruct(i).photRange = blockStruct(i).range;
                blockStruct(i).photPostSyncShift = NaN;
                
                if useOutPData == 1
                    blockStruct(i).OutPRange = blockStruct(i).range;
                    blockStruct(i).syncOutP = blockStruct(i).syncOutP;
                    blockStruct(i).OutPPostSyncShift = NaN;
                end
            end
        end

        %=============================================================================================

        %###############################################
        %QA check for drift of OutP, if applicable
        if useOutPData == 1 && ( exist('allowNullPhot') == 0 || allowNullPhot == 0 )
            outPOddCentroidPhotVals = [];
            for condCol = 1:size(uniqueSentColourConditions,2) %Will probs crash if no sent data, but what are the odds of that nowadays
                outPOddCentroidPhotVals{condCol} = [];
                if isempty( strfind( uniqueSentColourConditions{condCol} , 'odd' ) ) ~= 1 %Currently not feasible to do carrieronly check (Might be possible by working together with high state of art signal though)
                    for i = 1:size(blockStruct,2)
                        if blockStruct(i).sentConditionNum == 2 && isempty( strfind(blockStruct(i).sentColours, uniqueSentColours{condCol}) )
                            temp = blockStruct(i).syncOutP(3,:);
                            tempBW = bwlabel(temp);
                            tempAll = [];
                            for un = 1:nanmax( unique(tempBW) )
                                tempCoords = find(tempBW == un);
                                tempCentroid = floor(nanmean(tempCoords));
                                %tempAll = [tempAll, SplicedPhot(1, blockStruct(i).range(tempCentroid) ) ];
                                tempAll = [tempAll, SplicedPhot(1, blockStruct(i).photRange(tempCentroid) ) ]; %Relies on assumption that photRange will be valid, if perhaps frame-shifted wrt range
                            end
                            outPOddCentroidPhotVals{condCol} = [outPOddCentroidPhotVals{condCol}, [nanmean(tempAll);i] ];
                        end
                    end
                    %Plot
                    figure
                    plot( outPOddCentroidPhotVals{condCol}(2,:) , outPOddCentroidPhotVals{condCol}(1,:) )
                    ylim([nanmin(SplicedPhot(1,:)) , nanmax(SplicedPhot(1,:))])
                    title([uniqueSentColours{condCol}, ' ' , uniqueSentColourConditions{condCol}, ' centroid average phot. values'])
                end
            end
        end
        %###############################################

        %Prepare for post-sync mediated block ditching
        if useOutPData == 1 && applyAggressivePostSync == 1
            temp = [blockStruct.OutPPostSyncShift];
            tempMean = movmean( temp , ceil( size(blockStruct,2)*0.01 ) );
            tempSD = movstd( temp , ceil( size(blockStruct,2)*0.01 ) );
            
            %Testatory plot
            figure
            hold on
            plot( temp )
            plot( tempMean )
            plot( tempMean + tempSD )
            plot( tempMean - tempSD )
            legend
            title(['Aggressive post-sync pre-ditch plot'])
            set(gcf,'Name',[flies(IIDN).name, ' - APSPD']);
        end
        
        
        %Separate underlying sine peaks into carrier/oddball
        lossCount = 0; %Keeps track of how many cycles were lost on account of imperfect resampling of sentTTL
        ditchCount = 0; %Ditto, but for blocks that were ditched for various reasons (Currently only failing OutP matching)
        ditchIdentities = []; %Tracks the IDs of the ditched blocks
        %for i = 1:size(blockStruct,2) %Old, forward iteration
        for i = size(blockStruct,2):-1:1 %New, reverse iteration to facilitate ditching
            ditchThisBlock = 0; %Will be set to 1 if so desired
                %If this is 1 at the end of the processing loop then this block will be jettisoned from blockStruct
                    %Note: This may cause inter-block timing asynchronies
            
            artUnderPeaks = []; artUnderPeaksCarrier = []; artUnderPeaksOddball = [];   

            %artUnderPeaks = find(blockStruct(i).artUnderSignal == 1);
            %artUnderPeaks = find(blockStruct(i).syncArtUnderSignal == 1);
            artSignalData = blockStruct(i).syncArtUnderSignal;
            %artSignalData(artSignalData < 0) = NaN; %Remove baseline
            %artSignalData(artSignalData < nanmedian(artSignalData)) = NaN; %Remove lower half of data
            %artSignalData(artSignalData < nanmean(artSignalData)) = NaN; %Remove lower half of data
                %Note: Disabled removal of lower half of data as was causing issues
            [artSignalDataHist, artSignalDataHistCenters] = hist(artSignalData,256); %Make hist
            [ ~ , artSignalConsistentPeakHeightIdx] = nanmax(artSignalDataHist); %Find bin position of peak of hist (Coincides with peak of sine wave)
            artSignalConsistentPeakHeight = artSignalDataHistCenters(artSignalConsistentPeakHeightIdx); %Find Y value of bin position
            
            %New, while-loop based system
            proceed = 0;
            hasInitiated = 0;
            while proceed == 0 %Turned into a while loop 6/4/21 (See bug note #1)
                [artSignalPeaksPKS, artSignalPeaksLOCS, W, P] = findpeaksbase( artSignalData , 'MinPeakHeight', artSignalConsistentPeakHeight*0.95 ,...
                    'MinPeakDistance', (1/(f1*2))*resampleFreq ); 
                artUnderPeaks = artSignalPeaksLOCS;
                
                beyondRangePeaks = nansum( artUnderPeaks > size(blockStruct(i).syncSentTTLResamp,2) );
                %%lossCount = lossCount + nansum( artUnderPeaks > size(blockStruct(i).syncSentTTLResamp,2) ); %This occurs when syncSentTTLResamp is shorter than artSignalData (Moved outside while loop)
                artUnderPeaks(artUnderPeaks > size(blockStruct(i).syncSentTTLResamp,2)) = [];

                if blockStruct(i).sentConditionNum == 1 %Carrieronly
                    artUnderPeaksCarrier = artUnderPeaks( blockStruct(i).syncSentTTLResamp(1,artUnderPeaks) == 1 ); %Assume that all detected peaks are carrier
                    artUnderPeaksOddball = [];
                elseif blockStruct(i).sentConditionNum == 2 %Oddball
                    %artUnderPeaksCarrier = artUnderPeaks( blockStruct(i).sentTTLResamp(2,artUnderPeaks) == 1 ); %Find all peaks where Carrier TTL was high (not synchronised)
                    %artUnderPeaksOddball = artUnderPeaks( blockStruct(i).sentTTLResamp(3,artUnderPeaks) == 1 ); %Find all peaks where Oddball TTL was high (not synchronised)
                    if didSine == 1
                        artUnderPeaksCarrier = artUnderPeaks( blockStruct(i).syncSentTTLResamp(2,artUnderPeaks) == 1 ); %Find all peaks where Carrier TTL was high (Synchronised)
                        artUnderPeaksOddball = artUnderPeaks( blockStruct(i).syncSentTTLResamp(3,artUnderPeaks) == 1 ); %Find all peaks where Oddball TTL was high (Synchronised)
                    else
                        artUnderPeaksCoords = artUnderPeaks+floor((1/f1)*resampleFreq*halfWidthTTLCorrection);
                        artUnderPeaksCoords( artUnderPeaksCoords > size(blockStruct(i).syncSentTTLResamp,2) ) = []; artUnderPeaksCoords( artUnderPeaksCoords < 1 ) = []; %Remove impossible values (Note: Second operation will cause crashes if it ever enacts)
                        artUnderPeaksCarrier = artUnderPeaks( blockStruct(i).syncSentTTLResamp(2,artUnderPeaksCoords) == 1 ); %Find all peaks where Carrier TTL was high (Synchronised, half-width added)
                        artUnderPeaksOddball = artUnderPeaks( blockStruct(i).syncSentTTLResamp(3,artUnderPeaksCoords) == 1 ); %Find all peaks where Oddball TTL was high (Synchronised, half-width added)
                            %Note: The half-width correction technique is probably not applicable/necessary for sine data, on account of peak detection occurring at the peak of the stimulus, rather than the onset
                    end
                end
                
                
                %Match detected peaks with OutP, if existing
                if useOutPData == 1 && outPExisting == 1
                    
                    %Check for and delete peaks that are not present in either OutP channel
                    outPAbsentPeaks = blockStruct(i).syncOutP( 1 , artUnderPeaks ) == 1 | blockStruct(i).syncOutP( 2 , artUnderPeaks ) == 1 |  blockStruct(i).syncOutP( 3 , artUnderPeaks ) == 1;
                        %Find elements of artUnderPeaks that correspond to no high state in ch. 1 (carrieronly), ch. 2 (carrier) or ch. 3 (oddball) of OutP
                            %Note: Rather critically relies on virtual, perfect binary nature of OutP
                     %Quick QA
                    if nansum( outPAbsentPeaks == 0 ) > 0.05*size( outPAbsentPeaks , 2 )
                        if suppressDitchOutput ~= 1
                            ['## Alert: More than 5% of peaks apparently abberant (according to OutP); Overdetection may have occurred ##']
                        end
                        %crash = yes
                        if ditchNonMatchingBlocks == 1
                            if suppressDitchOutput ~= 1
                                disp(['-# Block will be ditched #-'])
                            end
                            ditchThisBlock = 1;
                            proceed = 1;
                        else
                            crash = yes
                        end
                    end
                    %QA plot (Activate only for debugging)
                    %{
                    figure
                    if blockStruct(i).sentConditionNum == 1
                        plot( blockStruct(i).syncOutP(1,:) )
                        hold on
                        scatter( artUnderPeaks , blockStruct(i).syncOutP(1,artUnderPeaks) )
                    else
                        plot( blockStruct(i).syncOutP(2,:) )
                        hold on
                        plot( blockStruct(i).syncOutP(3,:) )
                        scatter( artUnderPeaks , ones( 1 , size(artUnderPeaks,2) ) ) %Note usage of carrieronly signal to keep scatter points at high
                        %scatter( artUnderPeaks , blockStruct(i).syncOutP(3,artUnderPeaks) )
                    end
                    %}
                    
                    %Remove peaks
                    if nansum( outPAbsentPeaks == 0 ) > 0
                        if suppressDitchOutput ~= 1
                            disp(['-# Block #',num2str(i),' - ',num2str(nansum( outPAbsentPeaks == 0 )),' element/s of artUnderPeaks could not be matched with OutP data and will be removed #-'])
                        end
                        deletionElements = artUnderPeaks( ~outPAbsentPeaks );
                        for deEl = 1:size(deletionElements,2)
                            artUnderPeaks( artUnderPeaks == deletionElements(deEl) ) = [];
                            artUnderPeaksCarrier( artUnderPeaksCarrier == deletionElements(deEl) ) = [];
                            artUnderPeaksOddball( artUnderPeaksOddball == deletionElements(deEl) ) = [];
                        end
                    end
                    
                    %Calculate identities for OutP-derived peaks
                        %Note: The advantage of doing this after the deletion is that the deletion does not have to be mirrored
                        %The downside is that it may introduce asynchrony possibly
                    thisSyncOutP = blockStruct(i).syncOutP;
                    if postSyncOutP == 1
                        thisSyncOutP = circshift( thisSyncOutP , floor(-0.25*(1/(f1*2))*resampleFreq) , 2 ); %Shift OutP data left by 25% of a full-width
                    end
                    %outPCarrierOnlyPeaks = [];
                    outPCarrierPeaks = [];
                    outPOddballPeaks = [];
                    if blockStruct(i).sentConditionNum == 1 %Hardcoded carrieronly identity
                        %outPCarrierPeaks = artUnderPeaks( blockStruct(i).syncOutP(1,artUnderPeaks) == 1 ); %Find all peaks where carrieronly channel of OutP TTL was high
                        outPCarrierPeaks = artUnderPeaks( thisSyncOutP(1,artUnderPeaks) == 1 ); %Find all peaks where carrieronly channel of OutP TTL was high
                    elseif blockStruct(i).sentConditionNum == 2 %Ditto but oddball
                        %outPCarrierPeaks = artUnderPeaks( blockStruct(i).syncOutP(2,artUnderPeaks) == 1 ); %Find all peaks where carrier channel of OutP TTL was high
                        %outPOddballPeaks = artUnderPeaks( blockStruct(i).syncOutP(3,artUnderPeaks) == 1 ); %Find all peaks where oddball channel of OutP TTL was high
                        outPCarrierPeaks = artUnderPeaks( thisSyncOutP(2,artUnderPeaks) == 1 ); %Find all peaks where carrier channel of OutP TTL was high
                        outPOddballPeaks = artUnderPeaks( thisSyncOutP(3,artUnderPeaks) == 1 ); %Find all peaks where oddball channel of OutP TTL was high
                    end  
                    
                    %Check if all identities matching
                    allMatch = 0;
                    carrierMatch = [];
                    oddballMatch = [];
                    try
                       carrierMatch = outPCarrierPeaks == artUnderPeaksCarrier; %"Enterprisu-san"
                       oddballMatch = outPOddballPeaks == artUnderPeaksOddball;
                    catch
                        if suppressDitchOutput ~= 1
                            disp(['-# Warning: Could not compare artUnderPeaks and OutP identities for Block #',num2str(i),' #-']) %Probably because of dissimilar sizes
                        end
                        %crash = yes %Will probably make non-critical in the future when this is more tested
                        if allowPartialMatches == 1
                            enoughMatch = 0;
                            
                            %Check for phase translocation
                            if checkTranslocation == 1
                                thisSentCycleIdent = blockStruct(i).sentCycleIdent;
                                [sortedOutPeaks,I] = sort([outPCarrierPeaks,outPOddballPeaks]);
                                outPIdent = [ repmat(0,1,size(outPCarrierPeaks,2)) , repmat(1,1,size(outPOddballPeaks,2)) ];
                                outPIdent = outPIdent(I);
                                %Quick size fixing
                                if size(outPIdent,2) > size(thisSentCycleIdent,2) %OutP detected peaks number more than sent (Unlikely)
                                    outPIdent = outPIdent(1:size(thisSentCycleIdent,2));
                                    sortedOutPeaks = sortedOutPeaks(1:size(thisSentCycleIdent,2));
                                    %bias = ???
                                elseif size(outPIdent,2) < size(thisSentCycleIdent,2)
                                    temp = size(thisSentCycleIdent,2) - size(outPIdent,2); %Number of NaNs necessary to include 
                                    outPIdent = [outPIdent, nan(1, temp )]; %Theorectically pans out the end of OutPIdent with the correct number of NaNs
                                    sortedOutPeaks = [sortedOutPeaks, nan(1, temp )];
                                    %bias = ???
                                end
                                %Iterate to check matching at various phases
                                matchScore = [];
                                for phasInd = 0-transLimit:0+transLimit
                                    temp = circshift(outPIdent,phasInd); %Shift OutPIdent
                                    matchScore = [ matchScore, [nansum(temp==thisSentCycleIdent) ; phasInd] ]; %Check the shifted OutPIdent against the original sentCycles
                                end
                                highestScore = nanmax(matchScore(1,:)); %Find the best matching score
                                highestScoreTransInds = matchScore(2, find( matchScore(1,:) == highestScore ) ); %Calculate the distance of the best match from centre
                                [~,I] = nanmin(abs(highestScoreTransInds)); %Find the smallest shift from centre that gave said best score
                                %QA to check for aberrant detection
                                if nansum(  abs(highestScoreTransInds) == nanmin(abs(highestScoreTransInds)) ) > 2 %Not theoretically possible with real numbers, since no group of 3 or more non-identical numbers can be the same size 
                                    ['## Critical error in phase shift checking ##']
                                    crash = yes
                                end
                                bestShift = highestScoreTransInds(I); %In case of 2 results, will select the negative phase shift, but that's probably fine                             
                                if suppressDitchOutput ~= 1
                                    disp(['-# Best OutP match score of ',num2str(highestScore),' achieved with shift of ',num2str(bestShift),' #-'])
                                end
                                %Apply shift
                                outPIdent = circshift(outPIdent,bestShift);
                                %Work backwards to recapitulate outP carriers and oddballs based on shifted data
                                outPCarrierPeaks = [];
                                outPOddballPeaks = [];
                                outPCarrierPeaks = sortedOutPeaks( outPIdent == 0 );
                                outPOddballPeaks = sortedOutPeaks( outPIdent == 1 );
                                outPCarrierPeaks( isnan(outPCarrierPeaks) == 1) = [];
                                outPOddballPeaks( isnan(outPOddballPeaks) == 1) = [];
                                
                                if size(ditchIdentities,2) < 5 %Only do if first 10 or so
                                    figure
                                    plot( thisSentCycleIdent-outPIdent )
                                    title(['OutP vs sentCycles comparison plot (Block ',num2str(i),')'])
                                    set(gcf,'Name', [flies(IIDN).name, ' - OutP vs sentCycles comparison plot'])
                                end
                                
                                
                            end
                            
                            matchingCarrierPeaks = size( intersect(outPCarrierPeaks, artUnderPeaksCarrier) , 2 );
                            matchingOddballPeaks = size( intersect(outPOddballPeaks, artUnderPeaksOddball) , 2 );
                            if suppressDitchOutput ~= 1
                                disp(['-# Partially matching carriers: ',num2str((matchingCarrierPeaks / size( outPCarrierPeaks , 2 ))*100),'%, Oddballs: ',...
                                    num2str((matchingOddballPeaks / size( outPOddballPeaks , 2 ))*100),'% (Threshold: ',num2str(partialMatchThreshold*100),'%) #-'])
                            end
                            if ( matchingCarrierPeaks > partialMatchThreshold*size( outPCarrierPeaks , 2 ) ) && ( matchingOddballPeaks > partialMatchThreshold*size( outPOddballPeaks , 2 ) )
                                %disp(['-# However, enough (>',num2str(partialMatchThreshold*100),'%) of peaks match identity (',num2str((matchingCarrierPeaks / size( outPCarrierPeaks , 2 ))*100),'% & ',num2str((matchingOddballPeaks / size( outPOddballPeaks , 2 ))*100),'%, respectively) #-'])
                                enoughMatch = 1; %"More than the threshold are matching"
                            else
                                if ditchNonMatchingBlocks == 1
                                    if suppressDitchOutput ~= 1
                                        disp(['-# Block will be ditched (Partial matching failed) #-'])
                                    end
                                    ditchThisBlock = 1;
                                end
                            end
                        else
                            if ditchNonMatchingBlocks == 1
                                if suppressDitchOutput ~= 1
                                    disp(['-# Block will be ditched (No partial matching) #-'])
                                end
                                ditchThisBlock = 1;
                            end
                        end
                        %{
                        if ditchNonMatchingBlocks == 1
                            disp(['-# Block will be ditched #-'])
                            ditchThisBlock = 1;
                        end
                        %}
                    end
                    if ( ( isempty( carrierMatch ) ~= 1 && nansum( carrierMatch == 0 ) > 0 ) || ( isempty( oddballMatch ) ~= 1 && nansum( oddballMatch == 0 ) > 0 ) ) || size( carrierMatch , 2 ) == 0
                        %" ( carrierMatch is not empty and more than one items identity does not match OR ditto but oddball ) OR carrierMatch is size 0"
                         if ditchThisBlock == 0 %Don't spam screen if ditching anyway
                             if suppressDitchOutput ~= 1
                                ['#- Caution: Block #',num2str(i),' - One or more carrier and/or oddball cycles do not match identities between artUnderPeaks and OutP -#']
                             end
                         end
                         %crash = yes
                         if ditchNonMatchingBlocks == 1
                             if ditchThisBlock == 0 %Ditto non-spam
                                 if suppressDitchOutput ~= 1
                                    disp(['-# Block will be ditched #-'])
                                 end
                             end
                            ditchThisBlock = 1;
                        end
                    else
                        allMatch = 1; %Indicates that both carrier and oddball (depending on non-emptiness) were perfectly matching
                    end
                    
                    %Figure for seeing OutP synchronisation/peak detection
                        %Note: cannot be hot-swapped to different blocks due to specificity of some variables to processing loop
                    %{
                    figure
                    plot( blockStruct(i).syncArtUnderSignal )
                    hold on
                    %plot( blockStruct(i).syncOutP(2,:) )
                    %plot( blockStruct(i).syncOutP(1,:) )
                    plot( thisSyncOutP(2,:) )
                    plot( thisSyncOutP(3,:) )
                    scatter( artUnderPeaksCarrier , artSignalData( artUnderPeaksCarrier ) , [], 'r' )
                    scatter( artUnderPeaksOddball , artSignalData( artUnderPeaksOddball ) , [], 'g' )
                    scatter( outPCarrierPeaks , artSignalData( outPCarrierPeaks )+0.2 , [], 'r' )
                    scatter( outPOddballPeaks , artSignalData( outPOddballPeaks )+0.2 , [], 'g' )
                    for t = 1:size(sortedOutPeaks,2)
                        if isnan(sortedOutPeaks(t)) ~= 1
                            text(sortedOutPeaks(t),artSignalData( sortedOutPeaks(t) )+0.3, [num2str(t)], 'Color', 'r')
                        end
                    end
                    title(['sync/art plot (Block ',num2str(i),')'])
                    set(gcf,'Name', [flies(IIDN).name, ' - sync/art plot'])
                    %}
                    
                    %Figure for checking OutP/Phot synchronicity (Probably a recapitulation of existing)
                    %{
                    figure
                    hold on
                    thisSyncOutP = blockStruct(i).syncOutP; %Recapitulate for plot (Not saved anywhere, AFAIK)
                    if postSyncOutP == 1
                        thisSyncOutP = circshift( thisSyncOutP , floor(-0.25*(1/(f1*2))*resampleFreq) , 2 ); %Shift OutP data left by 25% of a full-width
                    end
                    thisCoords = [blockStruct(i).range(1) - floor( 0.1*size(blockStruct(i).range,2) ) : blockStruct(i).range(end) + floor( 0.1*size(blockStruct(i).range,2) )];
                    %Old, just block view
                    %plot( thisSyncOutP(2,:) ) 
                    %plot( thisSyncOutP(1,:) )
                    %plot( SplicedOutP(2, blockStruct(i).range )*0.5, 'Color', 'c' )
                    %plot( SplicedOutP(3, blockStruct(i).range )*0.5, 'Color', 'm' )
                    %plot( normalize(SplicedPhot(1, blockStruct(i).range ))*0.5, 'Color', 'r' )
                    %plot( normalize(SplicedData(1, blockStruct(i).range ))*0.5, 'Color', 'k' )
                    %New, windows added
                    plot( [nan(1,floor( 0.1*size(blockStruct(i).range,2) )),thisSyncOutP(2,:),nan(1,floor( 0.1*size(blockStruct(i).range,2) ))] ) 
                    plot( [nan(1,floor( 0.1*size(blockStruct(i).range,2) )),thisSyncOutP(1,:),nan(1,floor( 0.1*size(blockStruct(i).range,2) ))] )
                    plot( SplicedOutP(2, thisCoords )*0.5, 'Color', 'c' )
                    plot( SplicedOutP(3, thisCoords )*0.5, 'Color', 'm' )
                    plot( normalize(SplicedPhot(1, thisCoords ))*0.5, 'Color', 'r' )
                    plot( normalize(SplicedData(1, thisCoords ))*0.5, 'Color', 'k' )
                    title(['OutP/Phot plot (Block ',num2str(i),')'])
                    set(gcf,'Name', [flies(IIDN).name, ' - OutP/Phot plot'])
                    %}
                    
                    %Check against cycleIdent
                        %Note: Currently indecisive as to whether to tie this into actual crashing
                    if checkCycleIdent == 1
                        [~, sortedPeakInds] = sort([artUnderPeaksCarrier,artUnderPeaksOddball]);
                        temp = [ repmat(0,1,size(artUnderPeaksCarrier,2)) , repmat(1,1,size(artUnderPeaksOddball,2)) ];
                        typeNum = [ temp(sortedPeakInds) ];
                        cycleIdent = blockStruct(i).sentCycleIdent;
                        cycIdentMatch = nan( 1 , size(cycleIdent,2) );
                        for e = 1:nanmin( [ size(typeNum,2) , size(cycleIdent,2) ] )
                            if typeNum(e) == cycleIdent(e)
                                cycIdentMatch(e) = 1;
                            else
                                cycIdentMatch(e) = 0;
                            end
                        end
                    end
                    
                end
                
                %QA
                %predictedNumberOfPeaks = floor( ( size(blockStruct(i).syncSentTTLResamp,2) / f1 ) / 2 );
                predictedNumberOfPeaks = floor( ( size(blockStruct(i).syncSentTTLResamp,2) / resampleFreq * f1 ) );
                    %Note: This may be an incredibly simplistic way to predict the number of stimulus events
                actualNumberOfPeaks = ( size(artUnderPeaksCarrier,2) + size(artUnderPeaksOddball,2) );
                if predictedNumberOfPeaks ~= actualNumberOfPeaks
                    if suppressDitchOutput ~= 1
                        disp(['-# Warning: Block #',num2str(i),' Predicted (',num2str(predictedNumberOfPeaks),') and actual (',num2str(actualNumberOfPeaks),') number of peaks  do not match #-'])
                    end
                    if abs( predictedNumberOfPeaks - actualNumberOfPeaks ) == 1 && hasInitiated == 0
                        if suppressDitchOutput ~= 1
                            disp(['(Difference equal to 1 cycle; Engaging end frame TTL flattening)'])
                        end
                        artSignalData(end) = -(artSignalData(end)); %Invert final frame TTL value
                            %Based on testing showing failure for cycle end to be present causing underdetection
                        hasInitiated = 1;
                    else
                        if suppressDitchOutput ~= 1
                            disp(['## Alert: Difference greater than 1 cycle OR loop has failed to fix issue ##'])
                        end
                        if useOutPData == 0
                            %{
                            if ditchNonMatchingBlocks == 0
                                crash = yes
                            else
                                disp(['-# Block will be ditched #-'])
                                ditchThisBlock = 1;
                                proceed = 1;
                            end
                            %}
                            crash = yes %Behaviour not coded
                                %Consider making ditching be a not-outP specific act
                        else
                            if allMatch == 1
                                if suppressDitchOutput ~= 1
                                    disp(['-# However, all cycles match OutP, and so this will be ignored #-'])
                                end
                                proceed = 1;
                            else
                                if suppressDitchOutput ~= 1
                                    disp(['-# And not all cycles match OutP #-'])
                                end
                                if ditchNonMatchingBlocks == 0
                                    crash = yes
                                else
                                    if suppressDitchOutput ~= 1
                                        disp(['-# Block will be ditched #-'])
                                    end
                                    ditchThisBlock = 1;
                                    proceed = 1;
                                end
                            end
                        end
                    end
                else
                    proceed = 1; %Detected expected number of peaks
                    if hasInitiated == 1 %Report success
                        if suppressDitchOutput ~= 1
                            disp(['-# End frame flattening appears to have resolved issue #-'])
                        end
                    end
                end
                
            end
            
            %Check for aberrantly high post-sync value (if applicable)
            if useOutPData == 1 && applyAggressivePostSync == 1              
                if abs(blockStruct(i).OutPPostSyncShift - tempMean(i)) > 2*tempSD(i) &&  abs(blockStruct(i).OutPPostSyncShift - tempMean(i)) > resampleFreq/f1
                    if suppressDitchOutput ~= 1
                        disp(['-# Caution: Aggressive post-sync potentially failed for block #',num2str(i),' (Will be ditched) #-'])
                    end
                    ditchThisBlock = 1;
                end
            end

            %Ditch block instead of doing remaining processing steps
            if ditchThisBlock == 1
                blockStruct(i) = [];
                ditchCount = ditchCount + 1;
                ditchIdentities = [ditchIdentities, i];
                continue
            end
            
            lossCount = lossCount + beyondRangePeaks; %Should be unaffected by while loop now
            %Old, non-while loop system
            %{
            [artSignalPeaksPKS, artSignalPeaksLOCS, W, P] = findpeaksbase( artSignalData , 'MinPeakHeight', artSignalConsistentPeakHeight*0.95 ,...
                    'MinPeakDistance', (1/(f1*2))*resampleFreq ); 
            artUnderPeaks = artSignalPeaksLOCS;
            
            lossCount = lossCount + nansum( artUnderPeaks > size(blockStruct(i).syncSentTTLResamp,2) ); %This occurs when syncSentTTLResamp is shorter than artSignalData (Moved outside while loop)
            artUnderPeaks(artUnderPeaks > size(blockStruct(i).syncSentTTLResamp,2)) = [];

            if blockStruct(i).sentConditionNum == 1 %Carrieronly
                artUnderPeaksCarrier = artUnderPeaks( blockStruct(i).syncSentTTLResamp(1,artUnderPeaks) == 1 ); %Assume that all detected peaks are carrier
                artUnderPeaksOddball = [];
            elseif blockStruct(i).sentConditionNum == 2 %Oddball
                %artUnderPeaksCarrier = artUnderPeaks( blockStruct(i).sentTTLResamp(2,artUnderPeaks) == 1 ); %Find all peaks where Carrier TTL was high (not synchronised)
                %artUnderPeaksOddball = artUnderPeaks( blockStruct(i).sentTTLResamp(3,artUnderPeaks) == 1 ); %Find all peaks where Oddball TTL was high (not synchronised)
                if didSine == 1
                    artUnderPeaksCarrier = artUnderPeaks( blockStruct(i).syncSentTTLResamp(2,artUnderPeaks) == 1 ); %Find all peaks where Carrier TTL was high (Synchronised)
                    artUnderPeaksOddball = artUnderPeaks( blockStruct(i).syncSentTTLResamp(3,artUnderPeaks) == 1 ); %Find all peaks where Oddball TTL was high (Synchronised)
                else
                    artUnderPeaksCoords = artUnderPeaks+floor((1/f1)*resampleFreq*halfWidthTTLCorrection);
                    artUnderPeaksCoords( artUnderPeaksCoords > size(blockStruct(i).syncSentTTLResamp,2) ) = []; artUnderPeaksCoords( artUnderPeaksCoords < 1 ) = []; %Remove impossible values (Note: Second operation will cause crashes if it ever enacts)
                    artUnderPeaksCarrier = artUnderPeaks( blockStruct(i).syncSentTTLResamp(2,artUnderPeaksCoords) == 1 ); %Find all peaks where Carrier TTL was high (Synchronised, half-width added)
                    artUnderPeaksOddball = artUnderPeaks( blockStruct(i).syncSentTTLResamp(3,artUnderPeaksCoords) == 1 ); %Find all peaks where Oddball TTL was high (Synchronised, half-width added)
                        %Note: The half-width correction technique is probably not applicable/necessary for sine data, on account of peak detection occurring at the peak of the stimulus, rather than the onset
                end
            end 
            %}

            %QA to ensure no doubling up
            if isempty(intersect(artUnderPeaksCarrier, artUnderPeaksOddball)) ~= 1
                ['## Alert: Carrier/Oddball detection doubling up detected ##']
                crash = yes
            end

            blockStruct(i).artUnderPeaksCarrier = artUnderPeaksCarrier;
            blockStruct(i).artUnderPeaksOddball = artUnderPeaksOddball;

            %QA about number of cycles
            if size(artUnderPeaksCarrier,2) == 0 && size(artUnderPeaksOddball,2) == 0
                ['## Alert: No carrier or oddball cycles detected for block ',num2str(i),' ##']
                crash = yes
            end

            %QA about detection accuracy
            artSignalPredictedPeaks = (size(artSignalData,2) / resampleFreq) * f1;
            artSignalActualPeaks = (size(artUnderPeaksCarrier,2) + size(artUnderPeaksOddball,2));
            if abs( artSignalPredictedPeaks - artSignalActualPeaks ) > artSignalPredictedPeaks * 0.05
                if suppressDitchOutput ~= 1
                    ['## Alert: Block #',num2str(i),' significant (',num2str( [artSignalPredictedPeaks / artSignalActualPeaks]*100 ),'%) disparity between predicted (',num2str(artSignalPredictedPeaks),') and actual (',num2str(artSignalActualPeaks),') number of detected cycles  ##']
                end
                %Note: If block is overlength due to a TDT crash this can occur
                if overrideErrors ~= 1
                    crash = yes
                end
            end

            %Post-hoc calculate if jittering oddball or not
            if useSaveStruct == 1
                blockStruct(i).jittering = matStruct.sentStimuli(blockStruct(i).sentID).oddballType; %Pull jittering identity from sentStimuli data
            else
                if isempty(blockStruct(i).artUnderPeaksOddball) ~= 1
                    if nanstd( diff(blockStruct(i).artUnderPeaksOddball) ) > 50 %ARBITRARY BASED ON PILOT TESTING OF EXACTLY TWO BLOCKS
                        blockStruct(i).jittering = 3; %Normally jittering
                    else
                        blockStruct(i).jittering = 1; %Assumed phasic
                    end  
                else
                    blockStruct(i).jittering = 0; %Carrieronly
                end
            end

            %Place all peaks into common reference frame
            blockStruct(i).allPeaksList = struct;
            [sortedPeaks, sortedPeakInds] = sort([artUnderPeaksCarrier,artUnderPeaksOddball]);
            pooledPeakTypesNum = [ repmat(0,1,size(artUnderPeaksCarrier,2)) , repmat(1,1,size(artUnderPeaksOddball,2)) ];
            pooledPeakTypes = [ repmat({'carrier'},1,size(artUnderPeaksCarrier,2)) , repmat({'oddball'},1,size(artUnderPeaksOddball,2)) ];
            %blockStruct(i).allPeaksList = [ 1:size(sortedPeaks,2) ; sortedPeaks ; pooledPeakTypesNum(sortedPeakInds) ];
            %blockStruct(i).allPeaksTypes = [ pooledPeakTypes ];
            blockStruct(i).allPeaksList.sortedInd = [ 1:size(sortedPeaks,2) ];
            blockStruct(i).allPeaksList.relPos = [ sortedPeaks ];
            blockStruct(i).allPeaksList.type = [ pooledPeakTypes(sortedPeakInds) ]; 
            blockStruct(i).allPeaksList.typeNum = [ pooledPeakTypesNum(sortedPeakInds) ];

            %QA for comparing against sentStimuli data
            if useSaveStruct == 1
                try
                    sentID = blockStruct(i).sentID;
                    sentDetectDisparity = 0; %If none, this value will not be overwritten
                    if nansum( matStruct.sentStimuli(sentID).cycleIdent == blockStruct(i).allPeaksList.typeNum ) ~= size( matStruct.sentStimuli(sentID).cycleIdent , 2 ) %Perfect match for all
                        %{
                        ['# Warning: Disparity between sent cycles and detected order of cycles #']
                        error = yes %May be overkill to crash here
                        %}
                        sentDetectDisparity = nansum( matStruct.sentStimuli(sentID).cycleIdent == blockStruct(i).allPeaksList.typeNum ) - size( matStruct.sentStimuli(sentID).cycleIdent , 2 );
                        if suppressDitchOutput ~= 1
                            disp(['# Warning: Disparity of ',num2str(sentDetectDisparity),' cycles between sent cycles and detected order of cycles for Block ',num2str(i),' #'])
                        end
                        if overrideErrors ~= 1
                            crash = yes
                        end
                    end
                catch
                    %disp(['-# Failure in performing detected x sent disparity QA #-']) %This is probably because the number of cycles was not matching but it was ignored because OutP was okay for all cycles
                    sentDetectDisparity = NaN;
                end
                blockStruct(i).sentDetectDisparity = sentDetectDisparity;
                    %With current workflow this is only ever 0 or NaN
            end

            %Calculate distance for each peak (in cycles) from last carrier and oddball (if the latter is existing in this block)
            cycleRail = zeros(2,size(artUnderPeaksCarrier,2) + size(artUnderPeaksOddball,2)); %Pre-allocate rail
            cycleRail(1:2,:) = repmat(sortedPeaks,2,1); %Make sorted list containing both carrier and oddball cycle positions, duplicated
            [~, ~, carrInds] = intersect(artUnderPeaksCarrier, cycleRail(1,:));
            [~, ~, oddInds] = intersect(artUnderPeaksOddball, cycleRail(2,:));

            cycleRailBool = zeros(2,size(artUnderPeaksCarrier,2) + size(artUnderPeaksOddball,2)); %Pre-allocate bool rail
            cycleRailBool(1,carrInds) = 1;
            cycleRailBool(2,oddInds) = 1;

            cycleRailProc = zeros(2,size(artUnderPeaksCarrier,2) + size(artUnderPeaksOddball,2)); %Pre-allocate bwlabel rail
            cycleRailProc(1,:) = bwlabel(cycleRailBool(1,:));
            cycleRailProc(2,:) = bwlabel(cycleRailBool(2,:));

            blockStruct(i).allPeaksList.distFromLastCarrier = [];
            blockStruct(i).allPeaksList.distFromLastOddball = [];
            for peakInd = 1:size(blockStruct(i).allPeaksList.sortedInd,2)
                lastCarrier = find(cycleRailBool(1,1:peakInd) == 1, 1, 'last');
                lastOddball = find(cycleRailBool(2,1:peakInd) == 1, 1, 'last');
                if isempty(lastCarrier) ~= 1
                    blockStruct(i).allPeaksList.distFromLastCarrier(peakInd) = peakInd - lastCarrier;
                else
                    blockStruct(i).allPeaksList.distFromLastCarrier(peakInd) = NaN; %-1 might be better here
                end
                if isempty(lastOddball) ~= 1
                    blockStruct(i).allPeaksList.distFromLastOddball(peakInd) = peakInd - lastOddball;
                else
                    blockStruct(i).allPeaksList.distFromLastOddball(peakInd) = NaN; %-1 might be better here
                end
            end    
            
            %Ditch block as last action
                %Note: It probably makes more sense to do this *before* all the late-game processing steps, but that would involve a bit of change to the flow of the loop
                %(This code indeed moved up above)
            %{
            if ditchThisBlock == 1
                blockStruct(i) = [];
                ditchCount = ditchCount + 1;
                ditchIdentities = [ditchIdentities, i];
            end
            %}
        %blockStruct end
        end

        %Report on how many (if any) cycles were 'lost' due to imperfect sentTTL resampling
        if lossCount > 0
            ['## ',num2str(lossCount),' terminal cycles were lost due to imperfect TTL resampling ##']
        end
        %Report on how many blocks were ditched (if applicable)
        if ditchCount > 0 
            ['## ',num2str(ditchCount),' block/s were ditched ##']
            disp([ditchIdentities])
            %QA to report if excessive* number of blocks ditched (*Definitions may vary)
            %if size(ditchIdentities,2) > 0.05*size(sentStruct,2) %Will crash if sentStruct not in use, but when is that ever nowadays
            if size(ditchIdentities,2) > 0.05*nansum( [matStruct.sentStimuli.oddballType] ~= -1 ) %If matStruct cleared aggressively may crash
                ['## Alert: Excessive number of blocks ditched ##']
                %crash = yes
            end
        end

        %------------------------
        %Identify pre-experiment baseline
        try
            baselineDuration = stimDuration; %Probably good to keep this a similar size to actual experiment blocks
        catch
            baselineDuration = 20.01; 
            ['# Could not auto-detect stimulus duration for use with baseline; Using default value #']
        end

        %Determine when good baseline is
        proceed = 0; 
        if useSaveStruct == 1
            if isempty( matStruct.sentStimuli(1).Condition ) == 1 %Empty Condition field = Rest block
                restSentTimeRel = posixtime(datetime(strcat(matStruct.sentStimuli(1).trialSendDatestr),'Format', 'yyyy dd/MM HH:mm:ss:SSS', 'TimeZone', '+10:00')) - eegStartTimePosix;
                restRange = floor([ restSentTimeRel*resampleFreq : restSentTimeRel*resampleFreq + baselineDuration*resampleFreq ]);
                subProceed = 0;
                while subProceed == 0
                   if nanmax(restRange) >= nanmin(blockStruct(1).range) %This relies on the assumption that blockStruct contains only non-rest blocks
                       disp(['# Pre-experiment baseline overlaps first non-rest block by ',num2str( (nanmin(blockStruct(1).range) - nanmax(restRange))/resampleFreq ),'s; Recalculating #'])
                       restRange = restRange - floor(4*resampleFreq); %Subtract 4s of data and try again
                       if nanmin(restRange) < 1
                           ['## Alert: Attempted to pull pre-experiment baseline from before data is existing ##'] %Most likely if baseline is too long or paradigm did not have rest at start
                           crash = yes
                       end
                       subProceed = 0;
                   else
                       disp(['- Pre-experiment baseline precedes first non-rest block by ',num2str( (nanmin(blockStruct(1).range) - nanmax(restRange))/resampleFreq ),'s -'])
                       subProceed = 1;
                       proceed = 1;
                   end
                end
            else
                proceed = 0; %Do following loop
            end
        end
        if useSaveStruct ~= 1 || proceed == 0   
            disp(['- Using arbitrary pre-experiment baseline period -'])
            restRange = floor( [ nanmin(blockStruct(1).range) - 4*resampleFreq - baselineDuration*resampleFreq : nanmin(blockStruct(1).range) - 4*resampleFreq ] ); %"[First block start minus 4 seconds minus baselineDuration : First block start minus 4s]"
            if nanmin(restRange) < 1
               ['## Alert: Attempted to pull pre-experiment baseline from before data is existing ##'] %Most likely if baseline is too long or paradigm did not have rest at start
               crash = yes
           end
        end
        %------------------------

        %QA for cases where panels did not display sent data
        visRespChan = 16; %Arbitrarily selected channel with theoretically strongest visual response
        visRespChanData = SplicedData(visRespChan,:); 

        %Old system for determining visual response baseline
        %{
        if condNum(1) == 0 %"First trial was rest"
            visRespBaseline = visRespChanData(1:20*resampleFreq); %Hardcoded 20s trial and resampleFreqHz fs
                %A method that actually finds a rest trial here would be superior but is currently infeasible
        else
            visRespBaseline = visRespChanData(1:20*resampleFreq); %The same operation, but less confidently
                %Depending on waitMinutes and hardcoded waits in the stimulus script there may not be a full 20s at the start as a baseline
        end
        %}
        %New method, using pre-experiment baseline
        visRespBaseline = visRespChanData(1:restRange);

        visRespBaselineMean = nanmean(visRespBaseline);
        visRespBaselineSD = nanstd(visRespBaseline);
        warnCount = 0;
        warnBlocks = [];
        for i = 1:size(blockStruct,2)
            blockVisRespMean = nanmean( SplicedData(visRespChan,blockStruct(i).range) );
            blockVisRespSD = nanstd( SplicedData(visRespChan,blockStruct(i).range) );
            %disp(['B:',num2str(i),' - ?: ',num2str(blockVisRespMean),' - ?: ',num2str(blockVisRespSD)])
            blockStruct(i).visRespMets = [ blockVisRespMean , blockVisRespSD ]; %"Mean, SD"
            if blockVisRespSD < 2*visRespBaselineSD %Note: This is highly likely to occur naturally during oddCarrier experiments
                if warnCount < 5
                    disp(['# Warning: Stimulus potentially failed to present for Block ',num2str(i), ' based on LFP data #'])
                elseif warnCount == 5
                    disp(['(Future stimulus presentation warnings will be suppressed)'])
                end
                warnCount = warnCount + 1;
                blockStruct(i).stimQA = [ 1 ]; %"Status, Mean, SD"
            else
                blockStruct(i).stimQA = [ 0 ];
            end
        end
        if warnCount > 0
            disp(['# Warning: Stimulus potentially failed to present for ',num2str( nansum( [blockStruct.stimQA] ) ), ' blocks, based on LFP data #'])
        end

        %---------------------------------
        
        %----------------------------------------------------------------

        %Determine fly-unique value for normalising to
            %Perhaps it would be best to normalise groups by themselves?
        disp(['- Calculating fly-specific normalisation value for each channel from amplitude at every single stimulus onset -'])
        %everyPeakOnsetAmp = []; %Will hold the amplitude from literally every detected peak
            %Note: This may suffer adversely in datasets with large numbers of missing oddballs/etc
        figure
        pulledLims = [];
        overOnsetAmpMeans = [];
        overOnsetAmpMaxMins = [];
        overOnsetAmpMedians = [];
        for chanInd = 1:size(SplicedData,1)
            everyPeakOnsetAmp = []; %Will hold the amplitude from literally every detected peak
            everyPeakOnsetAmpMaxMin = [];
            %chanToPlot = chansOfInterest(chanInd);
            for i = 1:size(blockStruct,2)
                everyPeakOnsetAmp = [everyPeakOnsetAmp, SplicedData(chanInd,blockStruct(i).allPeaksList.relPos+blockStruct(i).startEnd(1))];
                    %"Select the value at chanToPlot from the rel. positions + block start absolute coord"
                        %Note: Accuracy of this coord specification is not assured
            end
            everyPeakOnsetAmpMean = nanmean(everyPeakOnsetAmp); 
            everyPeakOnsetAmpMaxMin = [ nanmax(everyPeakOnsetAmp) , nanmin(everyPeakOnsetAmp) ];
            disp(['-- Ch ',num2str(chanInd),' Mean stimulus onset amp: ',num2str(everyPeakOnsetAmpMean),', Max/Min: ',num2str(everyPeakOnsetAmpMaxMin(1)),'/',num2str(everyPeakOnsetAmpMaxMin(2)),' --'])
            overOnsetAmpMeans{chanInd} = everyPeakOnsetAmpMean;
            overOnsetAmpMaxMins{chanInd} = everyPeakOnsetAmpMaxMin;
            overOnsetAmpMedians{chanInd} = nanmedian(everyPeakOnsetAmp);
            %QA if this is a channel of interest to see if there are potential issues
            if nansum(chansOfInterestActive == chanInd) > 0 && abs(everyPeakOnsetAmpMean) < 0+nanstd(everyPeakOnsetAmp)
                ['## Warning: Average amplitude at stimulus onset indistinguishable from 0 ##']
            end
                %This is potentially likely to over-catch on datasets with a large number of missing cycles (i.e. Sparsening exps), but is designed
                %to mitigate the instability associated with using very small values to normalise
            %Plot
            subplot(size(SplicedData,1),1,chanInd)
            hist(everyPeakOnsetAmp,128)
            line([everyPeakOnsetAmpMean,everyPeakOnsetAmpMean],[0,nanmax(get(gca,'YLim'))], 'LineWidth', 2, 'LineStyle', ':', 'Color', 'r')
            line([overOnsetAmpMedians{chanInd},overOnsetAmpMedians{chanInd}],[0,nanmax(get(gca,'YLim'))],'LineWidth', 2, 'LineStyle', ':', 'Color', 'b')
            title(['Ch ',num2str(chanInd)])
            pulledLims = [pulledLims; get(gca,'XLim')];
        end
        %Plot shared axes
        for chanInd = 1:size(SplicedData,1)
            subplot(size(SplicedData,1),1,chanInd)
            xlim([min(pulledLims(:,1)),max(pulledLims(:,2))])
        end
        set(gcf,'Name', ['Every peak onset amps'])

        %Calculate colour-specific values
            %The advantage of this is that it is more resistant to high missing oddball counts
            %It operates by taking a capture window around cycles of each colour and then finding the maximum of that ERP (or just RP, in the case of missing cycles)
            %Theoretically it should provide a better normalisation for different colours than the one provided by just taking the mean of all cycles regardless of colour
        disp(['-- Calculating colour-specific ERP maximum normalisation --'])
        %disp(['(This may take a few seconds)'])
        tic
        overColourMaxMeans = [];
        %for chanInd = 1:size(SplicedData,1)
        for colourInd = 1:size(chanCodecContents,2)
            allColourAmps = []; %Will hold all cycle maxes of this colour
            d = 1; %Iterator
            for i = 1:size(blockStruct,2)
                wantType = []; %Clearing just in case
                if isempty( strfind(blockStruct(i).sentColours,chanCodecContents{colourInd}) ) ~= 1
                    if strfind(blockStruct(i).sentColours,chanCodecContents{colourInd}) == 1 %&& size( blockStruct(i).sentColours,2 ) == size( chanCodecContents{colourInd},2 ) %"Colour is in first position; Must be carrier or carrieronly"
                            %Note: This will technically be defeated by double-ups (i.e. a greengreen trial), but I can't think of a likely situation for those to be used as a paradigm
                        wantType = 0; %"Want carriers/carrieronlys"
                    else
                        wantType = 1; %"Want oddballs"
                    end
                    numOfWanted = nansum(blockStruct(i).allPeaksList.typeNum == wantType); %Calculate how many places will be needed
                    allColourAmps( 1:size(SplicedData,1) , d : d + numOfWanted - 1 ) = nan( size(SplicedData,1) , numOfWanted ); %Pre-fill list (End index may be off by 1, but it's probably not critical)
                    for cycInd = 1:size(blockStruct(i).allPeaksList.typeNum,2)
                        if blockStruct(i).allPeaksList.typeNum(cycInd) == wantType
                            cycCentroid = blockStruct(i).startEnd(1) + blockStruct(i).allPeaksList.relPos(cycInd);
                            %allColourAmps = [allColourAmps, nanmax( SplicedData(:, floor(cycCentroid+captureWindowGeometry(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometry(2)*captureWindowSize) ),[],2 ) ]; %Find max of all channels simultaneously
                                %Original implementation; V. slow with large numbers of cycles
                            allColourAmps( : , d) = nanmax( SplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize) ),[],2 );
                            d = d + 1;
                        end
                    end
                    %QA for doubleup
                    if size( strfind(blockStruct(i).sentColours,chanCodecContents{colourInd}),2 ) > 1
                        ['## Warning: Double-up detected in sentColours ##']
                        crash = yes %Gonna need to disable this if double-ups ever become an actual paradigm
                    end
                end
            end
            overColourMaxMeans{colourInd} = nanmean(allColourAmps,2); %Derive mean of all channels simultaneously
            if isempty(allColourAmps) == 1
                disp(['#- No cycles found for ',chanCodecContents{colourInd},' -#'])
            else
                disp(['- ',num2str(size(allColourAmps,2)),' cycles found for ',chanCodecContents{colourInd},' -'])
            end
        end
        %end
        disp(['-- Colour normalisations calculated in ',num2str(toc),'s --'])

        %----------------------------------------------------------------

        %--------------------------------------------------------------------------------------------------------------------------------------------
        %#############
        %Place data in hyperspace

        %New
        %Assemble (dynamic) 3-dimensional matrices of extracted cycles        
        %Auto-generated variables from targets
        %whiteflag
        %Old method (Mk <=11)
        %{
        disp(['-- Assembling hyperData of ',num2str(size(groupTargets,2)),' groups --'])

        tic
        groupHyper = struct;

        if didSine == 0
            baselineSize = 0.1;
            disp(['-- Using ',num2str(baselineSize*100),'% pre-stimulus (square) as baseline --'])
        end
        
        %If splitting
        if exist('blockSplitNum') == 1
            blockSplits = floor( linspace( 0 , size(blockStruct,2) , blockSplitNum+1 ) ); %Technically floor is not necessary, since booleans being used rather than an application of 'contains' or similar, but eh
        end

        for targInd = 1:size(groupTargets,2)
            groupHyper(targInd).Datas = zeros( size(SplicedData,1) , captureWindowSize, 1 ); %Row - Channel, Column - Relative timepoint, Layer - Cycle
            groupHyper(targInd).Phots = zeros( 1 , captureWindowSize, 1 ); %Column - Relative timepoint, Layer - Cycle
            if doTrapz == 1
                groupHyper(targInd).AUCs = [];
            end
            groupHyper(targInd).As = 1;
            groupHyper(targInd).Lists = [];
            for i = 1:size(blockStruct,2)
                %if blockStruct(i).jittering == groupJitters(targInd) %Old, uses jittering
                if blockStruct(i).jittering == groupJitters(targInd) &&  ( blockStruct(i).sentTDTCrash == 0 || isnan( blockStruct(i).sentTDTCrash ) == 1 ) && blockStruct(i).tdtCrashDetected == 0 %New, uses jittering as well as non-crash state
                    blockStartCoordAbs = blockStruct(i).startEnd(1);
                    blockBaselineAv = blockStruct(i).blockBaselineAv;
                    eval(['thisBlockGroupTargetData = ',groupTargets{targInd},';']); %Eval so that groupOneTarget can be used in string operations
                    %QA
                    if isempty(thisBlockGroupTargetData) == 1
                        disp(['# Warning: No data found for target ',groupTargets{targInd},' in block ',num2str(i),' #'])
                        %crash = yes %No longer really a crashable offense
                    else
                        for groupCyc = 1:size(thisBlockGroupTargetData,2)
                            %Evaluate special
                            eval([ 'thisProceed = ', groupSpecialEval{targInd},';' ]); %Evaluates the special expression to determine if this cycle meets the required constraints
                                %Note: May behave erratically if boolean poorly constructed

                            if thisProceed == 1
                                cycCentroid = thisBlockGroupTargetData(groupCyc) + blockStartCoordAbs; %Not armoured against proximal or terminal overrun
                                cycPhotCentroid = thisBlockGroupTargetData(groupCyc) + nanmin( blockStruct(i).photRange ); %Use (new) phot range
                                cycCollectionRange = floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize);
                                cycPhotCollectionRange = floor(cycPhotCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycPhotCentroid+captureWindowGeometryActive(2)*captureWindowSize);

                                %Old, symmetric system
                                %groupHyper(targInd).Datas(:,:, groupHyper(targInd).As ) = SplicedData(:, floor(cycCentroid-0.5*captureWindowSize)+1:floor(cycCentroid+0.5*captureWindowSize) ); %No correction
                                %%groupHyper(targInd).Phots(1,:, groupHyper(targInd).As ) = SplicedStim(4, floor(cycCentroid-0.5*captureWindowSize)+1:floor(cycCentroid+0.5*captureWindowSize) ); %Store photodiode information from same coords (No baseline correction)
                                %groupHyper(targInd).Phots(1,:, groupHyper(targInd).As ) = SplicedPhot(1, floor(cycCentroid-0.5*captureWindowSize)+1:floor(cycCentroid+0.5*captureWindowSize) ); %Store photodiode information from same coords (No baseline correction)
                                %New, not-necessarily-symmetric system    
                                groupHyper(targInd).Datas(:,:, groupHyper(targInd).As ) = SplicedData(:, cycCollectionRange ); %No correction
                                %groupHyper(targInd).Phots(1,:, groupHyper(targInd).As ) = SplicedStim(4, cycCollectionRange ); %Store photodiode information from same coords (No baseline correction)
                                %groupHyper(targInd).Phots(1,:, groupHyper(targInd).As ) = SplicedPhot(1, cycCollectionRange ); %Store photodiode information from same coords (No baseline correction)
                                groupHyper(targInd).Phots(1,:, groupHyper(targInd).As ) = SplicedPhot(1, cycPhotCollectionRange ); %Store photodiode information from photodiode synchronised coords
                                if doTrapz == 1
                                    groupHyper(targInd).AUCs(:, 1, groupHyper(targInd).As ) = trapz(groupHyper(targInd).Datas(:,:, groupHyper(targInd).As )'); %Calculate integral
                                end
                                if didSine == 1 %Use modified baseline correction if sine
                                    %groupHyper(targInd).DatasCorr(:,:, groupHyper(targInd).As ) = SplicedData(:, floor(cycCentroid-0.5*captureWindowSize)+1:floor(cycCentroid+0.5*captureWindowSize) ) - ...
                                    %     SplicedData(:, floor(cycCentroid-0.5*captureWindowSize)+1); %Corrected to starting value
                                    %    %Note: This single-line system to simultaneously subtract the 16 x 1 average from the 16 x <X> data is a little tenous but does seem to work in testing
                                    groupHyper(targInd).DatasCorr(:,:, groupHyper(targInd).As ) = SplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize)  ) - ...
                                        blockBaselineAv; %Normalised to ~3s preceding start of block
                                    baselineCorrectionMethod = 0; %Override on account of sine
                                elseif didSine == 0 %Use preceding 10% before stimulus was delivered to correct
                                    if baselineCorrectionMethod == 0
                                        groupHyper(targInd).DatasCorr(:,:, groupHyper(targInd).As ) = SplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize)  ) - ...
                                            blockBaselineAv; %Normalised to ~3s preceding start of block
                                    elseif baselineCorrectionMethod == 1
                                        baselineWindow = floor([ (cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)-(baselineSize*captureWindowSize) :  (cycCentroid+captureWindowGeometryActive(1)*captureWindowSize) ]); %"Select baselineWindow % before start of captured window"
                                        groupHyper(targInd).DatasCorr(:,:, groupHyper(targInd).As ) = SplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize) ) - ...
                                             nanmean( SplicedData(:, baselineWindow ) ,2); %Bseline corrected to starting value
                                                %Note: Dimension specification of 2 is critical to correctness (although tbh it'll probs crash if it is muffed up)
                                    end
                                end
                                if doTrapz == 1
                                    groupHyper(targInd).AUCsCorr(:, 1, groupHyper(targInd).As ) = trapz(groupHyper(targInd).DatasCorr(:,:, groupHyper(targInd).As )'); %Calculate integral
                                end
                                groupHyper(targInd).As = groupHyper(targInd).As + 1;
                                groupHyper(targInd).Lists = [groupHyper(targInd).Lists; i, groupCyc, cycCentroid]; %Block, Relative cycle number, Absolute position
                            end
                        end
                        %groupOneList = [groupOneList; i];
                    end
                end
            end
            %Calculate requested colours (if any) from specialEval
            thisGroupColourNum = [];
            thisGroupColours = [];
            if isempty( strfind(groupSpecialEval{targInd},'sentColours') ) ~= 1 && isempty( strfind(groupSpecialEval{targInd},'typeNum') ) ~= 1 %"A colour was specified for this group in the specialEval AND a type of cycle was specified"
                evalColours = groupSpecialEval{targInd}( nanmin(strfind(groupSpecialEval{targInd},'"')) +1 : nanmax(strfind(groupSpecialEval{targInd},'"')) -1 ); %Find what colours were in the specialEval for this group
                    %Note: Requires a colour to have been specified
                evalTypeStr = 'typeNum(groupCyc) == ';
                evalType = groupSpecialEval{targInd}( strfind(groupSpecialEval{targInd},evalTypeStr) + size(evalTypeStr,2) ); %Find what cycle type were in the specialEval for this group
                    %Note: Requires a cycle type to have been specified (although this is usually a given)
                evalTypeNum = str2num(evalType); %Above, but number
                %foundInst = 0; %QA iterator
                for colInd = 1:size(chanCodecContents,2)
                    findColourStatus = strfind(evalColours,chanCodecContents{colInd});
                    if isempty(findColourStatus) ~= 1
                        if evalTypeNum == 1 && findColourStatus > 1 %"Looking for oddball AND colour was not in first (carrier) position" (Will probs crash if doubleup of sentColour)
                            thisGroupColourNum = [thisGroupColourNum,colInd]; %The index in chanCodecContents of the colour that this hyperGroup ended up collecting
                            %foundInst = foundInst + 1;
                            thisGroupColours = [thisGroupColours,chanCodecContents{thisGroupColourNum}];
                        elseif evalTypeNum == 0 && findColourStatus == 1 %"Looking for carrier AND colour was in first (carrier) position"
                            thisGroupColourNum = [thisGroupColourNum,colInd];
                            %foundInst + 1;
                            thisGroupColours = [thisGroupColours,chanCodecContents{thisGroupColourNum}];
                        end                            
                    end
                end
                %QA
                if size(thisGroupColourNum,2) > 1 && normaliseERPs == 3
                    ['## Alert: Too many colours found for colour normalising to be possible ##']
                    crash = yes %This is a pretty simple fix, but I cbf currently
                end

                groupHyper(targInd).cycleColoursNum = thisGroupColourNum;
                groupHyper(targInd).cycleColours = thisGroupColours;
            else
                groupHyper(targInd).cycleColoursNum = NaN; %No specific colours specified
                groupHyper(targInd).cycleColours = NaN; %Or perhaps no specific cycles specified
            end
            
            %Correct groupHyper As
            groupHyper(targInd).As = groupHyper(targInd).As - 1;

        end
        disp(['-- hyperData assembled in ',num2str(toc),' seconds --'])
        disp(['- Normalisation/Correction method used: ',baselineCorrectionDescIndex{baselineCorrectionMethod+1},' -'])
        %}
        %New method (Pre-allocates)
        disp(['-- Assembling hyperData of ',num2str(size(groupTargets,2)),' groups --'])
        
        %Calculate maximum possible group size
        preSize = 0;
        for i = 1:size(blockStruct,2)
            preSize = preSize + size( blockStruct(i).allPeaksList.relPos, 2); %May be very huge for large datasets
        end

        tic
        groupHyper = struct;

        if didSine == 0
            baselineSize = 0.1;
            disp(['-- Using ',num2str(baselineSize*100),'% pre-stimulus (square) as baseline --'])
        end
        
        %If splitting
        if exist('blockSplitNum') == 1
            blockSplits = floor( linspace( 0 , size(blockStruct,2) , blockSplitNum+1 ) ); %Technically floor is not necessary, since booleans being used rather than an application of 'contains' or similar, but eh
        end

        for targInd = 1:size(groupTargets,2)
            %groupHyper(targInd).Datas = zeros( size(SplicedData,1) , captureWindowSize, 1 ); %Row - Channel, Column - Relative timepoint, Layer - Cycle
            %groupHyper(targInd).Phots = zeros( 1 , captureWindowSize, 1 ); %Column - Relative timepoint, Layer - Cycle
            %%groupHyper(targInd).Datas = nan( size(SplicedData,1) , captureWindowSize, preSize ); %Row - Channel, Column - Relative timepoint, Layer - Cycle
            %%groupHyper(targInd).DatasCorr = nan( size(SplicedData,1) , captureWindowSize, preSize ); %Row - Channel, Column - Relative timepoint, Layer - Cycle
            %%groupHyper(targInd).Phots = nan( 1 , captureWindowSize, preSize ); %Column - Relative timepoint, Layer - Cycle
            tempData = nan( size(SplicedData,1) , captureWindowSize, preSize ); %Row - Channel, Column - Relative timepoint, Layer - Cycle
            tempDatasCorr = nan( size(SplicedData,1) , captureWindowSize, preSize ); %Row - Channel, Column - Relative timepoint, Layer - Cycle
            tempPhots = nan( 1 , captureWindowSize, preSize ); %Column - Relative timepoint, Layer - Cycle
            if doTrapz == 1
                %groupHyper(targInd).AUCs = [];
                %%groupHyper(targInd).AUCs = nan( 1 , captureWindowSize, preSize );
                %%groupHyper(targInd).AUCsCorr = nan( 1 , captureWindowSize, preSize );
                tempAUCs = nan( 1 , captureWindowSize, preSize );
                tempAUCsCorr = nan( 1 , captureWindowSize, preSize );
            end
            groupHyper(targInd).As = 1;
            %groupHyper(targInd).Lists = []; %Old, exponentially slow system
            groupHyper(targInd).Lists = nan( preSize , 3 ); %Pre-allocated, cutdown later
            for i = 1:size(blockStruct,2)
                %if blockStruct(i).jittering == groupJitters(targInd) %Old, uses jittering
                if blockStruct(i).jittering == groupJitters(targInd) &&  ( blockStruct(i).sentTDTCrash == 0 || isnan( blockStruct(i).sentTDTCrash ) == 1 ) && blockStruct(i).tdtCrashDetected == 0 %New, uses jittering as well as non-crash state
                    blockStartCoordAbs = blockStruct(i).startEnd(1);
                    blockBaselineAv = blockStruct(i).blockBaselineAv;
                    
                    eval(['thisBlockGroupTargetData = ',groupTargets{targInd},';']); %Eval so that groupOneTarget can be used in string operations
                    
                    %QA
                    if isempty(thisBlockGroupTargetData) == 1
                        disp(['# Warning: No data found for target ',groupTargets{targInd},' in block ',num2str(i),' #'])
                        %crash = yes %No longer really a crashable offense
                    else
                        photRanMin = nanmin( blockStruct(i).photRange );
                        for groupCyc = 1:size(thisBlockGroupTargetData,2)
                            
                            %Evaluate special
                            eval([ 'thisProceed = ', groupSpecialEval{targInd},';' ]); %Evaluates the special expression to determine if this cycle meets the required constraints
                                %Note: May behave erratically if boolean poorly constructed
                            %thisProceed = 1;

                            if thisProceed == 1
                                cycCentroid = thisBlockGroupTargetData(groupCyc) + blockStartCoordAbs; %Not armoured against proximal or terminal overrun
                                %cycPhotCentroid = thisBlockGroupTargetData(groupCyc) + nanmin( blockStruct(i).photRange ); %Use (new) phot range
                                cycPhotCentroid = thisBlockGroupTargetData(groupCyc) + photRanMin; %Use (new) phot range
                                cycCollectionRange = floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize);
                                cycPhotCollectionRange = floor(cycPhotCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycPhotCentroid+captureWindowGeometryActive(2)*captureWindowSize);

                                %New, not-necessarily-symmetric system    
                                %%groupHyper(targInd).Datas(:,:, groupHyper(targInd).As ) = SplicedData(:, cycCollectionRange ); %No correction
                                %%groupHyper(targInd).Phots(1,:, groupHyper(targInd).As ) = SplicedPhot(1, cycPhotCollectionRange ); %Store photodiode information from photodiode synchronised coords
                                tempData(:,:, groupHyper(targInd).As ) = SplicedData(:, cycCollectionRange ); %No correction
                                tempPhot(1,:, groupHyper(targInd).As ) = SplicedPhot(1, cycPhotCollectionRange ); %Store photodiode information from photodiode synchronised coords
                                if doTrapz == 1
                                    %groupHyper(targInd).AUCs(:, 1, groupHyper(targInd).As ) = trapz(groupHyper(targInd).Datas(:,:, groupHyper(targInd).As )'); %Calculate integral
                                    tempAUCs(:, 1, groupHyper(targInd).As ) = trapz( tempData(:,:, groupHyper(targInd).As )'); %Calculate integral
                                end
                                if didSine == 1 %Use modified baseline correction if sine
                                    %groupHyper(targInd).DatasCorr(:,:, groupHyper(targInd).As ) = SplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize)  ) - ...
                                    %    blockBaselineAv; %Normalised to ~3s preceding start of block
                                    tempDatasCorr(:,:, groupHyper(targInd).As ) = SplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize)  ) - ...
                                        blockBaselineAv; %Normalised to ~3s preceding start of block
                                    %%baselineCorrectionMethod = 0; %Override on account of sine; Moved above
                                elseif didSine == 0 %Use preceding 10% before stimulus was delivered to correct
                                    %if baselineCorrectionMethod == 0
                                    if baselineCorrectionMethodActive == 0
                                        %groupHyper(targInd).DatasCorr(:,:, groupHyper(targInd).As ) = SplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize)  ) - ...
                                        %    blockBaselineAv; %Normalised to ~3s preceding start of block
                                        tempDatasCorr(:,:, groupHyper(targInd).As ) = SplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize)  ) - ...
                                            blockBaselineAv; %Normalised to ~3s preceding start of block
                                    %elseif baselineCorrectionMethod == 1
                                     elseif baselineCorrectionMethodActive == 1
                                        baselineWindow = floor([ (cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)-(baselineSize*captureWindowSize) :  (cycCentroid+captureWindowGeometryActive(1)*captureWindowSize) ]); %"Select baselineWindow % before start of captured window"
                                        %groupHyper(targInd).DatasCorr(:,:, groupHyper(targInd).As ) = SplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize) ) - ...
                                        %     nanmean( SplicedData(:, baselineWindow ) ,2); %Bseline corrected to starting value
                                        tempDatasCorr(:,:, groupHyper(targInd).As ) = SplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize) ) - ...
                                             nanmean( SplicedData(:, baselineWindow ) ,2); %Bseline corrected to starting value
                                                %Note: Dimension specification of 2 is critical to correctness (although tbh it'll probs crash if it is muffed up)
                                    end
                                end

                                if doTrapz == 1
                                    %groupHyper(targInd).AUCsCorr(:, 1, groupHyper(targInd).As ) = trapz(groupHyper(targInd).DatasCorr(:,:, groupHyper(targInd).As )'); %Calculate integral
                                    tempAUCsCorr(:, 1, groupHyper(targInd).As ) = trapz( tempDatasCorr(:,:, groupHyper(targInd).As )'); %Calculate integral
                                end
                                
                                groupHyper(targInd).Lists( groupHyper(targInd).As , : ) = [i, groupCyc, cycCentroid]; %Block, Relative cycle number, Absolute position
                                groupHyper(targInd).As = groupHyper(targInd).As + 1;
                                %continue
                                %groupHyper(targInd).Lists = [groupHyper(targInd).Lists; i, groupCyc, cycCentroid]; %Block, Relative cycle number, Absolute position
                                
                                
                            end
                        end
                        %groupOneList = [groupOneList; i];
                    end
                end
            end
            
            %Remove unused preallocated elements
            %%groupHyper(targInd).Datas( : , : , groupHyper(targInd).As:end ) = [];
            %%groupHyper(targInd).DatasCorr( : , : , groupHyper(targInd).As:end ) = [];
            %%groupHyper(targInd).Phots( : , : , groupHyper(targInd).As:end ) = [];
            tempData( : , : , groupHyper(targInd).As:end ) = [];
            tempDatasCorr( : , : , groupHyper(targInd).As:end ) = [];
            tempPhots( : , : , groupHyper(targInd).As:end ) = [];
            groupHyper(targInd).Lists( groupHyper(targInd).As:end , : ) = [];
            %And empty Lists if applicable
            if size( groupHyper(targInd).Lists , 1 ) == 0 || nansum( ~isnan(groupHyper(targInd).Lists(:,1) ) ) == 0
                groupHyper(targInd).Lists = []; %Multiple places later use this as check
            end
            if doTrapz == 1
                tempAUCs( : , : , groupHyper(targInd).As:end ) = [];
                tempAUCsCorr( : , : , groupHyper(targInd).As:end ) = [];
            end
            
            
            %Send data to structure
            groupHyper(targInd).Datas = tempData;
            groupHyper(targInd).DatasCorr = tempDatasCorr;
            groupHyper(targInd).Phots = tempPhots;
            clear('tempData','tempDatasCorr','tempPhots')
            if doTrapz == 1
                groupHyper(targInd).AUCs = tempAUCs;
                groupHyper(targInd).AUCsCorr = tempAUCsCorr;
                clear('tempAUCs','tempAUCsCorr')
            end
            
            %Calculate requested colours (if any) from specialEval
            thisGroupColourNum = [];
            thisGroupColours = [];
            if isempty( strfind(groupSpecialEval{targInd},'sentColours') ) ~= 1 && isempty( strfind(groupSpecialEval{targInd},'typeNum') ) ~= 1 %"A colour was specified for this group in the specialEval AND a type of cycle was specified"
                evalColours = groupSpecialEval{targInd}( nanmin(strfind(groupSpecialEval{targInd},'"')) +1 : nanmax(strfind(groupSpecialEval{targInd},'"')) -1 ); %Find what colours were in the specialEval for this group
                    %Note: Requires a colour to have been specified
                evalTypeStr = 'typeNum(groupCyc) == ';
                evalType = groupSpecialEval{targInd}( strfind(groupSpecialEval{targInd},evalTypeStr) + size(evalTypeStr,2) ); %Find what cycle type were in the specialEval for this group
                    %Note: Requires a cycle type to have been specified (although this is usually a given)
                evalTypeNum = str2num(evalType); %Above, but number
                %foundInst = 0; %QA iterator
                for colInd = 1:size(chanCodecContents,2)
                    findColourStatus = strfind(evalColours,chanCodecContents{colInd});
                    if isempty(findColourStatus) ~= 1
                        if evalTypeNum == 1 && findColourStatus > 1 %"Looking for oddball AND colour was not in first (carrier) position" (Will probs crash if doubleup of sentColour)
                            thisGroupColourNum = [thisGroupColourNum,colInd]; %The index in chanCodecContents of the colour that this hyperGroup ended up collecting
                            %foundInst = foundInst + 1;
                            thisGroupColours = [thisGroupColours,chanCodecContents{thisGroupColourNum}];
                        elseif evalTypeNum == 0 && findColourStatus == 1 %"Looking for carrier AND colour was in first (carrier) position"
                            thisGroupColourNum = [thisGroupColourNum,colInd];
                            %foundInst + 1;
                            thisGroupColours = [thisGroupColours,chanCodecContents{thisGroupColourNum}];
                        end                            
                    end
                end
                %QA
                if size(thisGroupColourNum,2) > 1 && normaliseERPs == 3
                    ['## Alert: Too many colours found for colour normalising to be possible ##']
                    crash = yes %This is a pretty simple fix, but I cbf currently
                end

                groupHyper(targInd).cycleColoursNum = thisGroupColourNum;
                groupHyper(targInd).cycleColours = thisGroupColours;
            else
                groupHyper(targInd).cycleColoursNum = NaN; %No specific colours specified
                groupHyper(targInd).cycleColours = NaN; %Or perhaps no specific cycles specified
            end
            
            %Correct groupHyper As
            groupHyper(targInd).As = groupHyper(targInd).As - 1;

        end
        disp(['-- hyperData assembled in ',num2str(toc),' seconds --'])
        disp(['- Normalisation/Correction method used: ',baselineCorrectionDescIndex{baselineCorrectionMethod+1},' -'])
        %dido

        %QA to see if any groups empty
        anyEmpty = 0;
        for hyperInd = 1:size(groupHyper,2)
            if isempty(groupHyper(hyperInd).Lists) == 1
                ['# Warning: Group ',num2str(hyperInd),' empty #']
                anyEmpty = anyEmpty + 1;
            end
        end
        if anyEmpty == 1
            ['## Warning: One or more hyperGroups returned empty ##']
            %crash = yes %Perhaps not necessary with armouring
        elseif anyEmpty == size(groupHyper,2)
            ['## Alert: All hyperGroups empty ##']
            crash = yes
        end
        %QA to see if all phoodiode data for groups is consistent (EXPERIMENTAL)
            %Warning: Groups that collect cycles with differing photodiode responses (i.e. missing AND coloured oddballs) will probably aberrantly trip this QA
        if exist('allowNullPhot') == 0 || allowNullPhot == 0
            %photNoiseSD = nanstd(SplicedStim(4,restRange)); %(Hopefully) noise level of photodiode during pre-experiment baseline
            if applyAggressivePostSync == 0 
                photNoiseSD = nanstd(SplicedPhot(1,restRange)); %(Hopefully) noise level of photodiode during pre-experiment baseline
            else
                if isnan( blockStruct(1).photPostSyncShift ) == 1 || blockStruct(1).photPostSyncShift == 0
                    photNoiseSD = nanstd(SplicedPhot(1,restRange));
                else
                    photNoiseSD = nanstd(SplicedPhot(1,restRange - blockStruct(1).photPostSyncShift)); %Phot already desync at block one; Shift
                end

            end
            if didSine == 1
                stimMax = floor(-captureWindowGeometryActive(1)*captureWindowSize); %Approximate centre of stimulus cycle (sine)
            else
                stimMax = floor(-captureWindowGeometryActive(1)*captureWindowSize + captureWindowSize*halfWidthTTLCorrection); %Approximate centre of stimulus cycle (square)
            end
            disp(['- Photodiode noise SD: ',num2str(photNoiseSD),' -'])
            for hyperInd = 1:size(groupHyper,2)
                collectedPhotValues = groupHyper(hyperInd).Phots(1,stimMax,:); %Collects all the photodiode values from the determined position within the cycle
                collectedPhotMean = nanmean(collectedPhotValues);
                collectedPhotSD = nanstd(collectedPhotValues); %SD of photodiode values at determined position
                if collectedPhotSD > 2*photNoiseSD %Test whether variance of phot values at determined position exceeds noise level of photodiode
                    ['## Warning: Photodiode variance for group ',num2str(hyperInd), ' exceeds arbitrary noise threshold ##']
                    %{
                    %Make crash figure
                    figure
                    plotData =  reshape(collectedPhotValues,1,size(collectedPhotValues,3));
                    plot(plotData, 'Color', groupColours(targToPlot,:))
                    title(['Phot. variance'])
                    set(gcf,'Name',[flies(IIDN).name, ' - Phot. variance. - G',num2str(hyperInd)]);
                    %Crash
                    if overrideErrors ~= 1
                        crash = yes
                    end
                    %}
                end
                    %Note: This test has reduced effectiveness if the number of aberrant events is quite small
                if nanmax(abs(collectedPhotValues - collectedPhotMean)) > 8*photNoiseSD %Test whether there is a singular phot value that exceeds the noise level
                    [~, singularPhotIdx] = nanmax(abs(collectedPhotValues - collectedPhotMean));
                    ['## Warning: Singular cycle variance for cycle ',num2str(singularPhotIdx),' (and potentially others) in group ',num2str(hyperInd), ' exceeds arbtrary noise threshold ##']
                    if overrideErrors ~= 1
                        crash = yes
                    end
                end
                    %This test is designed to catch singular aberrant events but conversely, if the number of aberrant events is large enough to affect the mean it may not work
                disp(['- Group ',num2str(hyperInd),' - Mid-stim average: ',num2str(collectedPhotMean),' , SD: ', num2str(collectedPhotSD), ' - Max individual variance: ', num2str(nanmax(abs(collectedPhotValues - collectedPhotMean))), ' -'])
            end
        end
            %In the case that this QA procs, using the tack-on plot is probably recommended to diagnose further

        %Third-stage synchronisation, if requested
        if thirdStagePhotoSynchronise == 1
            
            disp([char(10),'-- Engaging third-stage photodiode synchronisation --'])
            %Quick report
            if didSine == 1
                [char(10),'-# Caution: Third-stage photoysynchronisation not tested on sine wave data #-',char(10)]
            end
            superProceed = 0; %Used for synchroniseAll activities
            allMaxInfModes = []; %Prepare (Mostly used for synchroniseAll purposes but useful to have otherwise)
            while superProceed ~= 1
                for targInd = 1:size(groupHyper,2)
                    %First, check to see if group non-empty, based on groupHyper.lists
                    if isempty( groupHyper(targInd).Lists ) ~= 1
                        if didSine == 0
                            %Pre-check to see if photodiode data in this hypergroup usable
                            proceed = [];
                            temp = normalize(nanmean( groupHyper(targInd).Phots(1 , : , :) , 3 )); %Average (and normalise) all phots in this group
                            tempDiff = diff(temp); %Calculate point to point difference
                            %Flatness method (Honestly less effective than just the nanmedian of all tempDiff)
                            %{
                            %%flatlineCoords = find(abs(tempDiff) < abs( nanmedian( tempDiff )*flatnessThreshold ) == 1); %"Flat is Justice"
                                %Finds indices where the instantaneous difference is less than the median difference (which is hopefully around 0) multiplied by an arbitrary flatness factor
                                    %Note that this system will be less effective in cases where only a rise or fall is present (as opposed to one full period)
                            flatlineBoolBW = bwlabel( abs(tempDiff) < abs( nanmedian( tempDiff )*flatnessThreshold ) == 1 ); %Find contiguous regions of flatness
                            if nanmax(flatlineBoolBW) ~= 0
                                tempNoiseData = [];
                                for te = 1:nanmax(flatlineBoolBW) %Find the std of the individual regions of flat
                                    if nansum( flatlineBoolBW == te ) > 1
                                        tempNoiseData = [tempNoiseData, nanstd( tempDiff( flatlineBoolBW == te ) )];
                                    end                 
                                end
                                %QA
                                if size( flatlineCoords,2 ) == size(temp,2)
                                    disp(['-# Group ',num2str(targInd),' apparently completely flat #-'])
                                    proceed = 0;
                                    break
                                end
                            else
                                disp(['-# Group ',num2str(targInd),' no regions of contiguous flat #-'])
                                assex
                                proceed = 0;
                                break
                            end
                            %Newest
                            tempNoise = nanmedian( tempNoiseData ); %May end up being a median of 1 point if only one region of flat
                            %}
                            %Old
                            %tempNoise = 2*nanstd( temp(1, 1:ceil( abs(captureWindowGeometry(1))*0.5*captureWindowSize ) ) ); %Calculate noise level from index 1 to half of first window geometry (e.g. if geometry is [-0.5,0.5] then the first 25% of the capture window will be used)
                                %Note: Will be less effective with sine wave data
                                %Secondary note: Relies heavily on point of maximum inflection being around the 50% mark or later
                            %Less old    
                            %tempNoise = 2*nanstd( temp(1, 1:floor(size(temp,2)/3) ) ); %Calculate noise level from first third of data
                            %New
                            %tempNoise = 2*nanstd( diff( temp(1, flatlineCoords ) ) ); %Needs to be diff???
                            %%Even newest
                            tempNoise = nanmedian( tempDiff );
                            if ( nanmax( temp ) > nanmean( temp ) + 2*tempNoise ) && ( nanmin( temp ) < nanmean( temp ) - 2*tempNoise )
                                    %Note: With currently with normalization the mean will always be effectively 0, not that it changes anything
                                proceed = 1;
                            else
                                disp(['-# Group ',num2str(targInd),' signal level not sufficiently separable from calculated noise level #-'])
                                proceed = 0;
                            end
                        else
                            proceed = 1; %It is not feasible to use flatness finding to determine if groups are operable for sine waves
                        end
                        
                        %Quick QA to make sure blank groups aren't on the list to be synchronised
                        if isequal( groupHyper(targInd).cycleColours , 'blank' ) == 1
                            disp(['-# Group ',num2str(targInd),' is stimulus blank, which cannot be photosynchronised #-'])
                            proceed = 0;
                            %Currently a non-critical failure, but might change later to reduce misunderstandings of synchronisation
                        end

                        %Proceed if valid
                        if proceed == 1
                            %Calculate point of maximum (positive) inflection for each collected phot cycle
                            photMaxInfInds = [];
                            for i = 1:size(groupHyper(targInd).Phots,3)
                                [~ , photMaxInfInds(i)] = nanmax( diff( groupHyper(targInd).Phots(1,:,i) ) );
                            end
                            %Find mode of inds
                            maxInfMode = mode( photMaxInfInds );
                            %Store mode for this hyperGroup
                            if superProceed ~= 0.5 %"Don't store if second loop through"
                                allMaxInfModes = [allMaxInfModes, maxInfMode];
                            end
                            if synchroniseAll == 0 || (synchroniseAll == 1 && superProceed == 0.5) %"Not synchronising all OR yes synchronising and mode accumulation has already occurred"
                                %-----
                                %Synchronise all collected cycles according to this mode (for better or worse)
                                if synchroniseAll == 0
                                    useInfValue = maxInfMode; %Allows code to be shared between both synchroniseAll modes
                                    disp(['-- Synchronising all ',num2str(groupHyper(targInd).As),' cycles of hyperGroup ',num2str(targInd),' to indiv. group mode inflection point of ',num2str(useInfValue),' --'])
                                else
                                    useInfValue = mode( allMaxInfModes );
                                    disp(['-- Synchronising all ',num2str(groupHyper(targInd).As),' cycles of hyperGroup ',num2str(targInd),' to all group mode inflection point of ',num2str(useInfValue),' --'])
                                end
                                for i = 1:size(groupHyper(targInd).Phots,3)
                                    if photMaxInfInds(i) ~= useInfValue %"Cyle max inflection point does not match mode"
                                        cycleSyncValue = photMaxInfInds(i) - useInfValue; %Will be the value that must be subtracted from current position
                                        absCycleSyncValue = abs(cycleSyncValue); %Abs version of above for use in indexing
                                        tempData = nan( size(groupHyper(targInd).Datas,1) , size(groupHyper(targInd).Datas,2), 1 );
                                        tempPhot = nan( size(groupHyper(targInd).Phots,1) , size(groupHyper(targInd).Phots,2), 1 );
                                        tempDataCorr = nan( size(groupHyper(targInd).DatasCorr,1) , size(groupHyper(targInd).DatasCorr,2), 1 );
                                        if cycleSyncValue < 0 %"Shift data right"
                                            tempData(:,absCycleSyncValue+1:end) = groupHyper(targInd).Datas(:,1:end-absCycleSyncValue,i);
                                            tempPhot(:,absCycleSyncValue+1:end) = groupHyper(targInd).Phots(:,1:end-absCycleSyncValue,i);
                                            tempDataCorr(:,absCycleSyncValue+1:end) = groupHyper(targInd).DatasCorr(:,1:end-absCycleSyncValue,i);
                                        else %Shift data left"
                                            tempData(:,1:end-absCycleSyncValue) = groupHyper(targInd).Datas(:,absCycleSyncValue+1:end,i);
                                            tempPhot(:,1:end-absCycleSyncValue) = groupHyper(targInd).Phots(:,absCycleSyncValue+1:end,i);
                                            tempDataCorr(:,1:end-absCycleSyncValue) = groupHyper(targInd).DatasCorr(:,absCycleSyncValue+1:end,i);
                                        end
                                        %Replace existing data and phot with shifted data and phot
                                        groupHyper(targInd).Datas(:,:,i) = tempData;
                                        groupHyper(targInd).Phots(:,:,i) = tempPhot;
                                        groupHyper(targInd).DatasCorr(:,:,i) = tempDataCorr;
                                        if doTrapz == 1
                                            groupHyper(targInd).AUCs(:, 1, i ) = trapz(groupHyper(targInd).Datas(:,:,i)'); %(Re)Calculate integral
                                            groupHyper(targInd).AUCsCorr(:, 1, i ) = trapz(groupHyper(targInd).DatasCorr(:,:,i)'); %Calculate integral
                                        end
                                    end
                                end
                                %-----
                            end
                            
                        end

                    else
                        disp(['-# Group ',num2str(targInd),' is empty and thus cannot be synchronised #-'])
                    end
                    
                    %End if not synchronising all
                    if synchroniseAll ~= 1
                        superProceed = 1; %"Don't loop"
                    end
                    
                    if synchroniseAll == 1 && targInd == size(groupHyper,2) %"Last group"
                        superProceed = superProceed + 0.5; %On first loop this takes the mode to 0.5, then to 1 (and exiting) on the second loop through
                    end
                    
                %targInd end
                end
            %while end
            end
            disp(['-- Third-stage photodiode synchronisation completed --',char(10)])
        %if thirdStage end
        end
            
        
        %Sub-sampling for trend confirmation purposes
        %"Red October"
        if doSubSampling == 1
            groupHyperArk = struct; %Mirror copy of groupHyper that will hold only the cycles set to be preserved
            groupList = [1:size(groupHyper,2)];
            groupList = groupList(groupList ~= subSampleTarget);
            subTargetSize = size(groupHyper(subSampleTarget).Datas,3);
            disp(['-- Subsampling all applicable groups to n = ',num2str(subTargetSize),' cycles (G',num2str(subSampleTarget),' size) --'])
            tic
            %Initialise groupHyperArk
            hyperFields = fieldnames(groupHyper);
            %QA in case new fields have been added
            if size(hyperFields,1) > 7
                ['## Error new fields detected to have been added; Code will need adjusting ##'] %Add new fields to post-hoc section/s
            end
            for fiel = 1:size(hyperFields,1)
                groupHyperArk(subSampleTarget).(hyperFields{fiel}) = groupHyper(subSampleTarget).(hyperFields{fiel}); %Pull all data from original hyperGroup for subSampleGroup
            end
            groupHyperArk(subSampleTarget).subPreserve = NaN;

            if subTargetSize == 0
                ['## Warning: Reference group for subsampling contains 0 cycles ##']
                %crash = yes %There is a strong chance this case will actually come up
                for groupInd = groupList;
                    for fiel = 1:size(hyperFields,1)
                        groupHyperArk(groupInd).(hyperFields{fiel}) = [];
                    end
                end
                    %This means that the response to an empty reference group will be to make the whole structure be effectively empty
                        %This is extremely likely to cause problems upon pooling/etc
            else
                %Select cycles
                for groupInd = groupList
                    if size(groupHyper(groupInd).Datas,3) > subTargetSize
                        groupHyperArk(groupInd).As = 1;
                        %cycList = [1:size(groupHyper(groupInd).Datas,3)]; %List of all cycles
                        subPreserve = randsample( size(groupHyper(groupInd).Datas,3) , subTargetSize ); %List of cycles from this group to preserve ("Ionnnnaaaaaaaa")
                        for i = 1:size(groupHyper(groupInd).Datas,3)
                            if isempty(find(subPreserve == i)) ~= 1
                                groupHyperArk(groupInd).Datas(:,:, groupHyperArk(groupInd).As ) = groupHyper(groupInd).Datas(:,:,i);
                                groupHyperArk(groupInd).Phots(:,:, groupHyperArk(groupInd).As ) = groupHyper(groupInd).Phots(:,:,i);
                                if doTrapz == 1
                                    groupHyperArk(groupInd).AUCs(:,:, groupHyperArk(groupInd).As ) = groupHyper(groupInd).AUCs(:,:,i);
                                end
                                groupHyperArk(groupInd).Lists(groupHyperArk( groupInd).As,: ) = groupHyper(groupInd).Lists(i,:);
                                groupHyperArk(groupInd).DatasCorr(:,:, groupHyperArk(groupInd).As ) = groupHyper(groupInd).DatasCorr(:,:,i);
                                if doTrapz == 1
                                    groupHyperArk(groupInd).AUCsCorr(:,:, groupHyperArk(groupInd).As ) = groupHyper(groupInd).AUCsCorr(:,:,i);
                                end
                                groupHyperArk(groupInd).As = groupHyperArk(groupInd).As + 1;
                            end
                        end
                        groupHyperArk(groupInd).subPreserve = subPreserve;
                        %Correct groupHyperArk As
                        groupHyperArk(groupInd).As = groupHyperArk(groupInd).As - 1;
                        %Post-hoc add in cycle colour determinations
                        groupHyperArk(groupInd).cycleColoursNum = groupHyper(groupInd).cycleColoursNum;
                        groupHyperArk(groupInd).cycleColours = groupHyper(groupInd).cycleColours;
                    else
                        ['-# Cannot subsample Group ',num2str(groupInd),' on account of too few data points of own (',num2str(groupHyper(groupInd).As),') #-']
                        %groupHyperArk(groupInd) = groupHyper(groupInd);
                        for fiel = 1:size(hyperFields,1)
                            groupHyperArk(groupInd).(hyperFields{fiel}) = groupHyper(groupInd).(hyperFields{fiel});
                        end
                        groupHyperArk(groupInd).subPreserve = -1;
                    end
                end
            end
            groupHyper = groupHyperArk;
            disp(['-- Subsampling complete in ',num2str(toc),'s --'])
        end
        
        %--------------------------
        %Check blocks that were actually sent against what was requested to be sent
        if exist('matStruct') == 1 && isfield(matStruct, 'ancillary') == 1 && isfield(matStruct.ancillary, 'flagParamSaveStruct') == 1
            thisChanGroupList = matStruct.ancillary.flagParamSaveStruct.chanGroupList;
            disp(['chanGroupList had ',num2str(size(thisChanGroupList,2)),' requested states:'])
            %Plot predicted
            for i = 1:size(thisChanGroupList,2)
                disp([thisChanGroupList{i}])
            end
            
            %Separate sent according to carrieronly/carrier/oddball
            uniqueSentColoursSplit = [];
            for i = 1:size(uniqueSentColours,2)
                temp = [];
                foundElements = 0; %Used for QA
                for x = 1:size(chanCodecContents,2)
                    if isempty(strfind(uniqueSentColours{i},chanCodecContents{x})) ~= 1
                        if strfind(uniqueSentColours{i},chanCodecContents{x}) == 1 %"This colour first in name/Is carrier"
                            temp{1} = chanCodecContents{x};
                            foundElements = foundElements + 1;
                        else %"This NOT colour first in name/Is oddball"
                            temp{2} = chanCodecContents{x};
                            foundElements = foundElements + 1;
                        end
                            %Note: Rather critically relies on a two-part colour naming system
                    end
                end
                %QA
                if foundElements > 2
                    ['## Alert: More than two elements found in naming; This block results not valid ##']
                    crash = yes
                end
                uniqueSentColoursSplit{ 1 , size(uniqueSentColoursSplit,2)+1 } = temp;
            end
            %Report on colour groups actually sent
            disp([num2str(size(uniqueSentColoursSplit,2)),' colour groupings were sent:'])
            %Plot predicted
            for i = 1:size(uniqueSentColoursSplit,2)
                disp([uniqueSentColoursSplit{i}])
            end
            
        end
        
        
        %--------------------------
        
        disp([char(10),'--------------- Processing complete ---------------'])

        %#############
        %--------------------------------------------------------------------------------------------------------------------------------------------

        %Start here
        % ->

                %Average plot of all groups for one or multiple channels
        %(This section block commented on account of new position up top)
        %{
        %##########################
        chansOfInterest = [1,16];
        targsOfInterest = [1,2];
        %##########################
        %}
        %QA
        if nanmax(targsOfInterest) > size(groupTargets,2)
            ['# Alert: Invalid target group specified #']
            crash = yes
        end
        
        erpStruct = struct;
        %lineStruct = struct; lineStruct.names = [];
        h = [];

        figure

        %postData = struct;
        a = 1;
        for chanInd = 1:size(chansOfInterestActive,2)

            chanToPlot = chansOfInterestActive(chanInd);

            groupPlotDatas = [];
            groupPlotDatasFlat = [];

            groupDataAvs = [];
            groupDataSDs = [];
            groupDataSEMs = [];

            groupPhotAvs = [];
            groupPhotSDs = [];
            maxPhotAv = 0;

            titleStr = [];
            figStr = []; %Similar, but for fig autosaving
            vsStr = [repmat({' vs '},1,size(groupTargets,2)-1),{''}]; %Assembles a correct number of ' vs 's

            %figure
            for targInd = 1:size(targsOfInterest,2)%size(groupTargets,2)
                targToPlot = targsOfInterest(targInd); %Only used for interfaces with hyperData structures (since non-linear)

                %Assemble 3D and 2D matrices
                %groupPlotDatas{targInd} = groupHyperDatas{targToPlot}(chanToPlot,:,:);
                if isempty(groupHyper(targToPlot).Lists) ~= 1
                    if showCorrected == 0
                        groupPlotDatas{targInd} = groupHyper(targToPlot).Datas(chanToPlot,:,:); %Uncorrected
                    else
                        groupPlotDatas{targInd} = groupHyper(targToPlot).DatasCorr(chanToPlot,:,:); %Corrected
                    end
                    groupPlotDatasFlat{targInd} = [];
                    for i = 1:size(groupPlotDatas{targInd},3)
                        groupPlotDatasFlat{targInd}(i,:) = groupPlotDatas{targInd}(:,:,i);
                    end

                    %Means etc
                    groupDataAvs{targInd} = nanmean(groupPlotDatas{targInd}(1,:,:) ,3); %Row index of 1 because channel specification done earlier
                    groupDataSDs{targInd} = nanstd(groupPlotDatas{targInd}(1,:,:), [] ,3);
                    groupDataSEMs{targInd} = nanstd(groupPlotDatas{targInd}(1,:,:), [] ,3) / sqrt( size( groupPlotDatas{targInd} , 3 ) );
                    if doTrapz == 1
                        if showCorrected == 0
                            groupAUCAvs{targInd} = nanmean(groupHyper(targToPlot).AUCs(chanToPlot,:,:) ,3); %Uncorrected; Note targToPlot here
                            groupAUCSDs{targInd} = nanstd(groupHyper(targToPlot).AUCs(chanToPlot,:,:), [] ,3); %Uncorrected; Note targToPlot here
                            groupAUCSEMs{targInd} = nanstd(groupHyper(targToPlot).AUCs(chanToPlot,:,:), [] ,3) / sqrt( size( groupHyper(targToPlot).AUCs ,3 ) ); %Uncorrected; Note targToPlot here
                        else
                            groupAUCAvs{targInd} = nanmean(groupHyper(targToPlot).AUCsCorr(chanToPlot,:,:) ,3); %Corrected
                            groupAUCSDs{targInd} = nanstd(groupHyper(targToPlot).AUCsCorr(chanToPlot,:,:), [] ,3); %Corrected
                            groupAUCSEMs{targInd} = nanstd(groupHyper(targToPlot).AUCsCorr(chanToPlot,:,:), [] ,3) / sqrt( size( groupHyper(targToPlot).AUCsCorr ,3 ) ); %Corrected
                        end
                    end

                    %Plot
                    %plot(groupDataAvs{targInd}, 'Color', groupColours(targToPlot,:))
                    thisLineName = strcat(['line',num2str(chanToPlot),'_',num2str(targToPlot)]);
                    thisDescrip = strcat(['Ch ',num2str(chanToPlot),' - ',groupDescriptors{targToPlot}]);
                    %eval([thisLineName, '= plot(groupDataAvs{targInd}, ''Color'', groupColours(targToPlot,:));' ])
                    h(a) = plot( groupDataAvs{targInd}, 'Color', groupColours(targToPlot,:) , 'DisplayName', thisDescrip );
                    %lineStruct.names{a} = thisLineName;
                    %lineStruct.descrips{a} = thisDescrip;
                    a = a + 1;
                    hold on
                    groupShadeCoordsX = [1:1:size(groupDataAvs{targInd},2),size(groupDataAvs{targInd},2):-1:1];
                    %groupShadeCoordsY = [groupDataAvs{targInd}+0.5*groupDataSDs{targInd},flip(groupDataAvs{targInd}-0.5*groupDataSDs{targInd})];
                    groupShadeCoordsY = [groupDataAvs{targInd}+groupDataSDs{targInd},flip(groupDataAvs{targInd}-groupDataSDs{targInd})];
                    fill(groupShadeCoordsX, groupShadeCoordsY, groupColours(targToPlot,:)) %Error shading
                    alpha(0.15)
                    
                    %SEM dotted line
                    dotCoordsX = [1:1:size(groupDataAvs{targInd},2),size(groupDataAvs{targInd},2):-1:1];
                    dotCoordsY = [groupDataAvs{targInd}+groupDataSEMs{targInd},flip(groupDataAvs{targInd}-groupDataSEMs{targInd})];
                    line( dotCoordsX, dotCoordsY, 'LineStyle', ':', 'Color', groupColours(targToPlot,:) )

                    %Ancillary text
                    safePosS = linspace(0.2*captureWindowSize,0.8*captureWindowSize,size(targsOfInterest,2));
                    %safePos = floor(0.2*size(groupDataAvs{targInd},2));
                    safePos = floor(safePosS(targInd));
                    %text(safePos+targInd,groupDataAvs{targInd}(targInd+safePos), ['G:',num2str(targInd),',C:',num2str(chanToPlot)], 'Color', 'r')
                    %text(safePos,groupDataAvs{targInd}(floor(safePos)), ['G:',num2str(targInd),',C:',num2str(chanToPlot), ',AUC:',num2str(floor(groupAUCAvs{targInd})), '',num2str(floor(groupAUCSDs{targInd}))], 'Color', 'r')
                    text(safePos,groupDataAvs{targInd}(floor(safePos)), ['G:',num2str(targToPlot),'(',num2str(targInd),'),C:',num2str(chanToPlot)], 'Color', 'r')

                    %Strings
                    if chanInd == size(chansOfInterestActive,2) %Only assemble on final loop
                        %titleStr = [titleStr, groupTargets{targToPlot}(end-6:end), ' (n=',num2str(size(groupPlotDatas{targInd},3)),', jit:',num2str(groupJitters(targToPlot)),')', vsStr{targInd}];
                        titleStr = [titleStr, groupDescriptors{targToPlot}, ' (n=',num2str(size(groupPlotDatas{targInd},3)),', jit:',num2str(groupJitters(targToPlot)),')', vsStr{targInd}, char(10)];
                        %figStr = [figStr, groupTargets{targToPlot}(end-6:end), ' N',num2str(size(groupPlotDatas{targInd},3)),' J', num2str(groupJitters(targToPlot)), vsStr{targInd}];
                    end

                else
                    if chanInd == size(chansOfInterestActive,2) %Only assemble on final loop
                        titleStr = [titleStr, groupDescriptors{targToPlot}, ' (n=',num2str(0),', jit:',num2str(groupJitters(targToPlot)),')', vsStr{targInd}, char(10)];
                    end
                    disp(['## Could not plot hyperGroup ',num2str(targToPlot),' on account of emptiness ##'])
                %hyperGroup empty end    
                end

                %pause(1)
            end

            %postData(chanInd).groupDataAvs = groupDataAvs;
            %postData(chanInd).groupDataSDs = groupDataSDs;
            erpStruct.data(chanInd).chanToPlot = chanToPlot;
            erpStruct.data(chanInd).groupPlotDatas = groupPlotDatas;
            erpStruct.data(chanInd).groupDataAvs = groupDataAvs;

        end
        leg = legend(h);
        set(leg,'AutoUpdate', 'off')
        %Photodiode display
        yPull = get(gca,'YLim');
        scaleFactor = abs(yPull(1)-yPull(2)) * 0.2; %Scale to be 1/5th of total Y lim height
        for targInd = 1:size(targsOfInterest,2)
            targToPlot = targsOfInterest(targInd);
            %plotData = groupHyper(targToPlot).Phots(1,:,:);
            %%plotData = normalize( groupHyper(targToPlot).Phots(1,:,:) , 2 , 'range', [-1,1]);
            %plotData = ( groupHyper(targToPlot).Phots(1,:,:) - groupHyper(targToPlot).Phots(1,1,:) ) / ( nanmax(SplicedStim(4,:)) - nanmin(SplicedStim(4,:)) );
            plotData = ( groupHyper(targToPlot).Phots(1,:,:) - groupHyper(targToPlot).Phots(1,1,:) ) / ( nanmax(SplicedPhot(1,:)) - nanmin(SplicedPhot(1,:)) );
            %groupPhotAvs{targInd} = normalize( nanmean(plotData,3) , 2, 'range', [-1,1]) * scaleFactor; %Note non-targInd specifier and manipulated scale
            groupPhotAvs{targInd} = nanmean( plotData ,3) * scaleFactor; %Note non-targInd specifier and manipulated scale
            %normScale = nanmax(nanmean(plotData,3)) - nanmin(nanmean(plotData,3)); %The maximum normalised value corresponds to this original photodiode value
            %groupPhotSDs{targInd} = (nanstd(plotData, [], 3) / normScale) * scaleFactor; %Note non-targInd specifier
            groupPhotSDs{targInd} = nanstd(plotData, [], 3) * scaleFactor; %Note non-targInd specifier
            groupPhotShadeCoordsX = [1:1:size(groupPhotAvs{targInd},2),size(groupPhotAvs{targInd},2):-1:1];
            groupPhotShadeCoordsY = [groupPhotAvs{targInd}+groupPhotSDs{targInd},flip(groupPhotAvs{targInd}-groupPhotSDs{targInd})];
            groupPhotShadeCoordsY = groupPhotShadeCoordsY - groupPhotShadeCoordsY(1); %Offset start
            %plot( nanmean([groupPhotShadeCoordsY(1:size(groupPhotShadeCoordsY,2)/2);groupPhotShadeCoordsY(size(groupPhotShadeCoordsY,2)/2+1:end)],1) , 'Color', [1.0,0.647,0.0])
            fill(groupPhotShadeCoordsX, groupPhotShadeCoordsY, [1.0,0.647,0.0]) %Error shading
                %Note: Scale and shading of photodiode signal is for display purposes only
            alpha(0.15)
            safePos = floor(0.5*size(groupPhotShadeCoordsY,2));
            text(safePos,groupPhotShadeCoordsY(safePos+targInd), ['G:',num2str(targToPlot),'(',num2str(targInd),')'], 'Color', groupColours(targToPlot,:))
        end
        erpStruct.phot.plotData = plotData;
        erpStruct.phot.groupPhotAvs = groupPhotAvs;

        %Further ancillaries
        %line([captureWindowSize/2,captureWindowSize/2],[-300,300], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
        yPull = get(gca,'YLim');
        line([captureWindowSize/2,captureWindowSize/2],[yPull(1),yPull(2)], 'LineStyle', ':', 'Color', 'k')
        %{
        if isempty(fixedPhotodiodeScale) ~= 1
            line([ captureWindowSize*(-captureWindowGeometry(1)),captureWindowSize*(-captureWindowGeometry(1)) ],[-fixedPhotodiodeScale,fixedPhotodiodeScale], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
        else
            line([ captureWindowSize*(-captureWindowGeometry(1)),captureWindowSize*(-captureWindowGeometry(1)) ],[-300,300], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
        end
            %Uses captureWindowGeometry to back-calculate centroid position
        %}
        %{
        if didSine == 0
            line([ (captureWindowSize/2)-(baselineSize*captureWindowSize) , (captureWindowSize/2)-(baselineSize*captureWindowSize) ], [-500,500], 'Color', 'k') %Baseline end
            line([ (captureWindowSize/2) , (captureWindowSize/2) ], [-500,500], 'Color', 'k') %Baseline start
                %Note: Critical assumption of capture window symmetry 
        end
        %}

        xlim([1, captureWindowSize])
        exTicks = cellfun(@str2num, get(gca,'XTickLabel')) - (captureWindowGeometryActive(2) * captureWindowSize);
        xticklabels(exTicks)
        titleStr = [titleStr,' for channel/s ',num2str(chansOfInterestActive)];

        if showCorrected == 1
            titleStr = [titleStr, char(10), ' (',correctedIndex{showCorrected+1},', ' baselineCorrectionDescIndex{baselineCorrectionMethod+1}, ')'];
        else
            titleStr = [titleStr, char(10), ' (',correctedIndex{showCorrected+1},')'];
        end

        %titleStr = [titleStr,' for channel/s ',num2str(chansOfInterest), ' (',correctedIndex{showCorrected+1},')'];
        title(titleStr)
        xlabel(['Time (ms)'])
        pulledYLims = get(gca,'YLim'); %Used for MMN plot
        thisFigName = 'Av ERP';
        set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName]);

        %###########
        %Save figure
        if saveFigs == 1
            try
                savePlot(saveName,thisFigName,figStr)
            catch 
                ['-# Alert: Failure to save plot #-']
            end
        end
        %###########

        %Tack-on plot for displaying data and photodiode in a linear fashion
        if size(tackTargsOfInterest,2) ~= 0
            figure
            tackTitleStr = [];
            tackVsStr = [repmat({' and '},1,size(tackTargsOfInterest,2)-1),{''}]; %Assembles a correct number of ' vs 's
            for chanInd = 1:size(chansOfInterestActive,2)
                chanToPlot = chansOfInterestActive(chanInd);

                for targInd = 1:size(tackTargsOfInterest,2)
                    targToPlot = tackTargsOfInterest(targInd);

                    rollInPos = 0; %Rolling X position to place cycle at
                    for cycInd = 1:size(groupHyper(targToPlot).Datas,3)
                        %Data
                        plot( [rollInPos:rollInPos+size(groupHyper(targToPlot).Datas,2)-1] , groupHyper(targToPlot).Datas(chanToPlot,:,cycInd), 'Color', groupColours(targToPlot,:))
                        if tackLite == 0
                            text(rollInPos,0, ['G:',num2str(targInd)], 'Color', groupColours(targToPlot,:))
                        end
                        hold on

                        %Photodiode
                        if chanInd == size(chansOfInterestActive,2)
                            %plot( [rollInPos:rollInPos+size(groupHyper(targToPlot).Datas,2)-1] , groupHyper(targToPlot).Phots(1,:,cycInd)*0.001 - 200*targInd - 200, 'Color', [1.0,0.647,0.0])
                            %plot( [rollInPos:rollInPos+size(groupHyper(targToPlot).Datas,2)-1] , groupHyper(targToPlot).Phots(1,:,cycInd), 'Color', [1.0,0.647,0.0])
                            plot( [rollInPos:rollInPos+size(groupHyper(targToPlot).Datas,2)-1] , normalize( groupHyper(targToPlot).Phots(1,:,cycInd) , 'range', ...
                                [nanmin( nanmean(groupHyper(targToPlot).Datas(chanToPlot,:,:),3) ),nanmax( nanmean(groupHyper(targToPlot).Datas(chanToPlot,:,:),3) )] )*0.5 , 'Color', [1.0,0.647,0.0])
                            %hold on
                        end

                        %Ancillary
                        line([rollInPos,rollInPos],[-nanmax(groupHyper(targToPlot).Datas(chanToPlot,:,cycInd)),nanmax(groupHyper(targToPlot).Datas(chanToPlot,:,cycInd))], 'LineStyle', ':')
                        if tackLite == 0
                            text(rollInPos,-160 - (targInd*100), [ 'Bl:', num2str(groupHyper(targToPlot).Lists(cycInd,1)) , char(10), 'RInd:', num2str(groupHyper(targToPlot).Lists(cycInd,2)) ,char(10),...
                                'AInd:', num2str(groupHyper(targToPlot).Lists(cycInd,3)), char(10), 'CyIn:',num2str(cycInd)],'Color', groupColours(targToPlot,:))
                        end
                        if chanInd == size(chansOfInterestActive,2) && cycInd == size(groupHyper(targToPlot).Datas,3) %Only assemble on final loop
                            tackTitleStr = [tackTitleStr, groupDescriptors{targToPlot}, ' (n=',num2str(size(groupPlotDatas{targInd},3)),', jit:',num2str(groupJitters(targToPlot)),')', tackVsStr{targInd}];
                        end

                        rollInPos = rollInPos + size(groupHyper(targToPlot).Datas,2);
                    end
                end            
            end
            if doSubSampling == 1
                tackTitleStr = [tackTitleStr,char(10),'(Data subsampled to n=',subTargetSize,')'];
            end
            title(tackTitleStr)
            %xlim([6500,8000])
            %xlim([7.45e4 , 7.65e4])
            %xlim([1.028e5, 1.038e5]) %16/5/21 - For use with 110521, selects region of apparent incorrect capture
            set(gcf,'Name',[flies(IIDN).name,' - TackTarg']);
        end
        
        %---------------
        
        %Onion plot
        if doOnionPlot == 1
            %onionFraction = 1.0; %What fraction of all elements within a target hyperGroup to show (e.g. "0.1" means "Show 10% of elements")
                %Moved up top
            for chanInd = 1:size(chansOfInterestActive,2)
                chanToPlot = chansOfInterestActive(chanInd);
                chanTitle = num2str(chanToPlot);

                figure
                for targInd = 1:size(targsOfInterest,2)
                    targToPlot = targsOfInterest(targInd);

                    subplot( 1, size(targsOfInterest,2), targInd )
                    titleStr = ['Ch ',num2str(chanToPlot),' - ',groupDescriptors{targToPlot},' (T: ',num2str(targToPlot),')'];
                    title(titleStr)
                    set(gcf,'Name',[flies(IIDN).name,' - TargOfInterest Onion (',num2str(onionFraction*100),'%) - Ch ',num2str(chanToPlot)]);
                    try
                        if isempty(groupHyper(targToPlot).Lists) ~= 1
                            onionInds = floor( linspace( 1 , groupHyper(targToPlot).As , groupHyper(targToPlot).As*onionFraction ) );
                            if showCorrected == 0
                                thisPlotData = groupHyper(targToPlot).Datas(chanToPlot,:, onionInds ); %Uncorrected
                            else
                                thisPlotData = groupHyper(targToPlot).DatasCorr(chanToPlot,:, onionInds ); %Corrected
                            end
                        else
                            continue
                        end
                        thisPlotData = squeeze(thisPlotData)'; %Squeeze layers into rows (Only feasible because dealing with single channel/target at a time)
                        thisPlotAv = nanmean( thisPlotData , 1 );
                        thisPlotSDs = nanstd( thisPlotData , [] , 1 );
                        thisPlotSEM = nanstd( thisPlotData , [] , 1 ) / sqrt( size(thisPlotData,1) );

                        %Data
                        plot( thisPlotData', 'Color', groupColours(targToPlot,:) )
                        hold on
                        %Average
                        plot( thisPlotAv , 'Color', 'k' )
                        %Shade
                        groupShadeCoordsX = [1:1:size(thisPlotAv,2),size(thisPlotAv,2):-1:1];
                        groupShadeCoordsY = [thisPlotAv+thisPlotSDs,flip(thisPlotAv-thisPlotSDs)];
                        fill(groupShadeCoordsX, groupShadeCoordsY, 'k') %Error shading
                        alpha(0.15)
                        hold off
                        try
                            xlim([1,size(thisPlotData,2)])
                        catch
                            xlim('auto')
                        end
                    catch
                        disp(['-# Failure to onion plot group ',num2str(targToPlot),' #-'])
                    end
                end

            end
        end
        
        %---------------

        %Testatory single-channel averaged data plot
        %{
        figure
        groupOneDataAv = nanmean(groupOneHyperData(1,:,:),3);
        groupTwoDataAv = nanmean(groupTwoHyperData(1,:,:),3);
        groupOneDataSD = nanstd(groupOneHyperData(1,:,:), [], 3);
        groupTwoDataSD = nanstd(groupTwoHyperData(1,:,:), [], 3);
        %Plot averages
        plot(groupOneDataAv,'b')
        hold on
        plot(groupTwoDataAv,'g')
        %Plot SEM shading
        groupOneShadeCoordsX = [1:1:size(groupOneDataAv,2),size(groupOneDataAv,2):-1:1];
        groupOneShadeCoordsY = [groupOneDataAv+0.5*groupOneDataSD,flip(groupOneDataAv-0.5*groupOneDataSD)];
        fill(groupOneShadeCoordsX, groupOneShadeCoordsY,'b') %Error shading
        alpha(0.25)
        groupTwoShadeCoordsX = [1:1:size(groupTwoDataAv,2),size(groupTwoDataAv,2):-1:1];
        groupTwoShadeCoordsY = [groupTwoDataAv+0.5*groupTwoDataSD,flip(groupTwoDataAv-0.5*groupTwoDataSD)];
        fill(groupTwoShadeCoordsX, groupTwoShadeCoordsY,'g') %Error shading
        alpha(0.25)
        xlabel(['Time (ms)'])
        ylabel(['LFP (?)'])
        %title(['All carrier cycles vs all oddball cycles'])
        title(['Average ',groupOneTarget(end-6:end), ' cycles (b; n = ',num2str(size(groupOneHyperData,3)),', jit: ',num2str(groupOneJittering),') vs ',...
            groupTwoTarget(end-6:end),' cycles (g; n = ',num2str(size(groupTwoHyperData,3)),', jit: ',num2str(groupTwoJittering),')'])


        %Not-fucked testatory plot of hypercubes
        chanInQuestion = 1;
        groupOnePlotData = groupOneHyperData(chanInQuestion,:,:);
        blirg = [];
        for i = 1:size(groupOnePlotData,3)
            blirg(i,:) = groupOnePlotData(:,:,i);
        end
        groupTwoPlotData = groupTwoHyperData(chanInQuestion,:,:);
        blorg = [];
        for i = 1:size(groupTwoPlotData,3)
            blorg(i,:) = groupTwoPlotData(:,:,i);
        end
        figure
        plot(blirg', 'b')
        hold on
        plot(blorg','g')
        %title(['Phasic oddball cycles (b) vs Jittering oddball cycles (g)'])
        title([groupOneTarget(end-6:end), ' cycles (b; n = ',num2str(size(groupOneHyperData,3)),', jit: ',num2str(groupOneJittering),') vs ',...
            groupTwoTarget(end-6:end),' cycles (g; n = ',num2str(size(groupTwoHyperData,3)),', jit: ',num2str(groupTwoJittering),') for channel ',num2str(chanInQuestion)])
        %Add-on, single-group plot
        figure
        plot(blirg')
        title([groupOneTarget(end-6:end), ' cycles (n = ',num2str(size(groupOneHyperData,3)),', jit: ',num2str(groupOneJittering),') for channel ',num2str(chanInQuestion)])
        %Super-niche-three-triplet-trace plot (GroupOne = Jittering oddball cycles) ("The Trintessential Trintuplets")
        figure
        plot(blirg(264,:))
        hold on
        plot(blirg(274,:)) %Very close but not perfect match
        plot(blirg(251,3:end)) %Perfect match with shift of three

        %Multiple channels, single condition average plots
        chansOfInterest = [1,7,15];
        chanColours = jet(size(chansOfInterest,2));
        figure
        for i = 1:size(chansOfInterest,2)
            groupDataAv{i} = nanmean(groupOneHyperData(chansOfInterest(i),:,:),3);

            groupDataSD{i} = nanstd(groupOneHyperData(chansOfInterest(i),:,:), [], 3);

            %Plot averages
            plot(groupDataAv{i}, 'Color', chanColours(i,:))
            hold on

            %Plot SEM shading
            groupShadeCoordsX = [1:1:size(groupDataAv{i},2),size(groupDataAv{i},2):-1:1];
            groupShadeCoordsY = [groupDataAv{i}+0.5*groupDataSD{i},flip(groupDataAv{i}-0.5*groupDataSD{i})];
            fill(groupShadeCoordsX, groupShadeCoordsY, chanColours(i,:)) %Error shading
            alpha(0.15)

            %Ancillary text
            text(5,groupDataAv{i}(5)+groupDataSD{i}(5), [num2str(chansOfInterest(i))], 'Color', chanColours(i,:))

        end
        xlabel(['Time (ms)'])
        ylabel(['LFP (?)'])
        title([groupOneTarget(end-6:end),' (n = ',num2str(size(groupOneHyperData,3)),', jit: ',num2str(groupOneJittering),') cycles at channel/s: ',num2str(chansOfInterest)])
        %}

        %Plot AUCs and SEM of AUCs
        
        figure

        exLabels = [];
        statsP = [];
        if doTrapz == 1
            for chanInd = 1:size(chansOfInterestActive,2)
                chanToPlot = chansOfInterestActive(chanInd);
                chanTitle = num2str(chanToPlot);
                barXPoses = linspace(chanInd-0.15,chanInd+0.15,size(targsOfInterest,2));

                for targInd = 1:size(targsOfInterest,2)
                    targToPlot = targsOfInterest(targInd);
                    targTitle = [groupTargets{targToPlot}(end-6:end), ' J:', groupJitters(targToPlot)];
                    barP = barXPoses(targInd);

                    if isempty(groupHyper(targToPlot).Lists) ~= 1
                        %Calculate mean and SEM
                        if showCorrected == 0
                            thisTargAUCData = groupHyper(targToPlot).AUCs(chanToPlot,:,:);
                        else
                            thisTargAUCData = groupHyper(targToPlot).AUCsCorr(chanToPlot,:,:);                  
                        end
                        thisTargAUCMean = nanmean(thisTargAUCData ,3);
                        thisTargAUCSEM = nanstd(thisTargAUCData, [] ,3) / sqrt(size(thisTargAUCData,3));
                        thisTargAUCSD = nanstd(thisTargAUCData, [] ,3);

                        %Plot bars
                        h = bar(barP,thisTargAUCMean, 0.25);
                        line([barP,barP],[thisTargAUCMean - 0.5*thisTargAUCSEM,thisTargAUCMean + 0.5*thisTargAUCSEM], 'Color', 'k', 'LineWidth', 4)
                        line([barP,barP],[thisTargAUCMean - 0.5*thisTargAUCSD,thisTargAUCMean + 0.5*thisTargAUCSD], 'Color', 'k', 'LineStyle', ':', 'LineWidth', 2)
                                %BOOTLEG CUSTOM ERROR BARS
                        hold on
                        set(h,'FaceColor',groupColours(targToPlot,:));
                        set(h,'FaceAlpha',0.5);
                    end

                end

                %Labels and things
                exLabels{chanInd} = ['Channel ', chanTitle];

                %Stats
                statsP{chanInd} = [nan(size(targsOfInterest,2),size(targsOfInterest,2))]; %Pre-allocate
                bonffCorrection = [];
                for i = 1:size(targsOfInterest,2)
                    for x = 1:size(targsOfInterest,2)
                        if isempty(groupHyper(i).Lists) ~= 1 && isempty(groupHyper(x).Lists) ~= 1
                            if showCorrected == 0
                                iAucData = groupHyper(i).AUCs(chanToPlot,:,:);
                                xAucData = groupHyper(x).AUCs(chanToPlot,:,:);
                            else
                                iAucData = groupHyper(i).AUCsCorr(chanToPlot,:,:);
                                xAucData = groupHyper(x).AUCsCorr(chanToPlot,:,:);    
                            end
                            [~,statsP{chanInd}(i,x)] = ttest2(iAucData,xAucData);
                        end
                    end
                end

            end
        end

        %Axes, etc
        %xlabel(['Raw PE counts'])
        ylabel(['Average AUC'])
        %ylim([0 probInterval])
        ax = gca;
        ax.XTick = [1:size(chansOfInterestActive,2)];
        ax.XTickLabel = exLabels;
        xtickangle( 270 )
        if exist('titleStr') == 1
            figTitle = ['Av AUC (SEM & SD) of ', titleStr];
        else
            figTitle = ['Average AUC for channel/s ',num2str(chansOfInterestActive),' SEM & SD', ' (',correctedIndex{showCorrected+1},')'];
        end
        title(figTitle)
        thisFigName = 'Av AUC';
        if doTrapz ~= 1
            thisFigName = [thisFigName,' (Disabled)'];
        end
        set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName]);

        %###########
        %Save figure
        if saveFigs == 1
            %{
            if useSaveStruct == 0
                saveName = strcat(figPath,'\',foundMATFiles(1).name(1:end-4),'_', thisFigName, '_', figStr ,'.png');
                saveName = strrep(saveName, '_Amplitude_', '_'); %NOTE: HIGHLY POSSIBLE THIS IS NOT ALWAYS TRUE
            else
                saveName = strcat(figPath,'\',saveStructFiles(1).name(1:end-4),'_', thisFigName, '_', figStr ,'.png');
                saveName = strrep(saveName, '_saveStruct_', '_');
            end
            %}
            figSaveName = strcat([saveName, '_', thisFigName, '_', figStr ,'.png']);

            %Plot preparation
            set(gcf, 'Color', 'w');
            set(gcf,'units','normalized','outerposition',[0 0 1 1])
            %Save
            proceed = 0;
            tic
            while proceed == 0 & toc < 30
                try
                    saveas(gcf, figSaveName, 'png');
                    proceed = 1;
                catch
                    ['# Failure to save ',thisFigName,' to file #']
                    pause(5)
                end
            end
        end
        %###########
        if doFilteredPlots == 1
            %Filtered ERP plot
            disp('-- Calculating and plotting filtered data --')
            filterStruct = struct;
            for filtInd = 1:size(filterRanges,1)
                tic
                %Filter data by specified bandpass range
                for channel = 1:size(SplicedData,1)
                    bandSplicedData(channel,:) = bandpass( SplicedData(channel,:) , filterRanges(filtInd,:) , resampleFreq );
                end
                disp(['- Data filtered between ',num2str(filterRanges(filtInd,1)),' and ',num2str(filterRanges(filtInd,2)),'Hz in ',num2str(round(toc,1)),'s -'])
                %bandSplicedPhot = bandpass( SplicedStim(4,:) , filterRanges(filtInd,:) , resampleFreq );
                bandSplicedPhot = bandpass( SplicedPhot(1,:) , filterRanges(filtInd,:) , resampleFreq );
                    %Note: Does not react (seemingly) to null photodiode data
                filterStruct(filtInd).filterRange = filterRanges(filtInd,:);
                %#####
                %Testatory filtered data plot
                figure
                
                plotCoords = [5.4756*10e4 : 5.4894*10e4];
                for chanInd = 1:size(chansOfInterestActive,2)
                    chanToPlot = chansOfInterestActive(chanInd);
                    plot( bandSplicedData(chanToPlot,plotCoords) , 'Color', chanColours(chanInd,:) ) %Only plot a subset of data, to save memory
                    hold on
                end
                yPull = get(gca,'YLim');
                photRange = abs(yPull(1) - yPull(2));
                photData = ( ( bandSplicedPhot(1,plotCoords) / nanmax(bandSplicedPhot(1,plotCoords)) ) * photRange * 0.2 ) - 1*photRange; 
                    %Note: May be out of sync, but there is no easy way to get back in sync short of calculating which block this time period corresponds to 
                plot( photData , 'Color', [1,0.5,0])
                set(gcf,'Name', [num2str(filterRanges(filtInd,1)),'-',num2str(filterRanges(filtInd,2)),'Hz filtered testatory'])
                
                %Image competition rainbow plot
                %Note: Image submission made from 060820-1-2 data ('Post' data range: 5.4756*10e4 : 5.4894*10e4)
                %{
                plotCoords = [5.4756*10e4 : 5.4894*10e4];
                plotCoords = [ nanmin(plotCoords - size(plotCoords,2)) : nanmax(plotCoords + size(plotCoords,2)) ];
                plotData = bandSplicedData(1:12,plotCoords);

                %plotData = zeros(16,128); % Testing
                %plotData(:,1:2:128) = 1; % Testing

                %Process plotData
                for row = 1:size(plotData,1)
                    %plotData(row,:) = plotData(row,:) + abs(nanmin(plotData(row,:))); %Offset
                    %plotData(row,:) = plotData(row,:) / nanmax(plotData(row,:)) ; %Normalise
                    plotData(row,:) = abs (plotData(row,:) / nanmax(plotData(row,:)) ); %Normalise and abs
                end

                rainbowColours = jet(size(plotData,1));

                %Prepare imageData
                imageData = [];
                imageData = zeros(size(plotData,1),size(plotData,2),3); %Prepare

                %Apply plotData to image
                for row = 1:size(plotData,1)
                    imageData(row,:,1) = plotData(row,:) * rainbowColours(row,1);
                    imageData(row,:,2) = plotData(row,:) * rainbowColours(row,2);
                    imageData(row,:,3) = plotData(row,:) * rainbowColours(row,3);
                end
                set(gca,'XTickLabel',[])
                set(gca,'XTick',[])
                set(gca,'YTickLabel',[])
                set(gca,'YTick',[])

                figure
                image(imageData)
                set(gcf,'Name', [num2str(filterRanges(filtInd,1)),'-',num2str(filterRanges(filtInd,2)),'Hz filtered rainbow'])
                
                %And plot original traces to go alongside
                plotData = bandSplicedData(1:12,plotCoords);
                for row = 1:size(plotData,1)
                    plotData(row,:) = plotData(row,:) / nanmax(plotData(row,:)) ; %Normalise
                end
                
                figure
                
                for row = 1:size(plotData,1)
                    plot( plotData(row,:) + (size(plotData,1) - row), 'Color', rainbowColours(row,:) )
                    hold on
                end
                set(gca,'XTickLabel',[])
                set(gca,'XTick',[])
                set(gca,'YTickLabel',[])
                set(gca,'YTick',[])
                %}
                %#####
                
                %Recapitulate hyperGroup formation
                %###
                groupHyperFilter = struct;
                for targInd = 1:size(groupTargets,2)
                    groupHyperFilter(targInd).Datas = zeros( size(bandSplicedData,1) , captureWindowSize, 1 ); %Row - Channel, Column - Relative timepoint, Layer - Cycle
                    groupHyperFilter(targInd).Phots = zeros( 1 , captureWindowSize, 1 ); %Column - Relative timepoint, Layer - Cycle
                    %groupHyper(targInd).AUCs = [];
                    groupHyperFilter(targInd).As = 1;
                    %groupHyper(targInd).Lists = [];
                    for i = 1:size(blockStruct,2)
                        if blockStruct(i).jittering == groupJitters(targInd)
                            blockStartCoordAbs = blockStruct(i).startEnd(1);
                            blockBaselineAv = blockStruct(i).blockBaselineAv;
                            eval(['thisBlockGroupTargetData = ',groupTargets{targInd},';']); %Eval so that groupOneTarget can be used in string operations
                            %QA
                            if isempty(thisBlockGroupTargetData) == 1
                                disp(['# Warning: No data found in bandpassed data for target ',groupTargets{targInd},' in block ',num2str(i),' #'])
                            else
                                for groupCyc = 1:size(thisBlockGroupTargetData,2)
                                    %Evaluate special
                                    eval([ 'thisProceed = ', groupSpecialEval{targInd},';' ]); %Evaluates the special expression to determine if this cycle meets the required constraints
                                        %Note: May behave erratically if boolean poorly constructed

                                    if thisProceed == 1
                                        cycCentroid = thisBlockGroupTargetData(groupCyc) + blockStartCoordAbs; %Not armoured against proximal or terminal overrun

                                        groupHyperFilter(targInd).Datas(:,:, groupHyperFilter(targInd).As ) = bandSplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize) ); %No correction
                                        groupHyperFilter(targInd).Phots(1,:, groupHyperFilter(targInd).As ) = bandSplicedPhot(1, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize) ); %Store photodiode information from same coords (No baseline correction)
                                            %New, not-necessarily-symmetric system
                                        if doTrapz == 1
                                            groupHyperFilter(targInd).AUCs(:, 1, groupHyperFilter(targInd).As ) = trapz(groupHyperFilter(targInd).Datas(:,:, groupHyperFilter(targInd).As )'); %Calculate integral
                                        end
                                        if didSine == 1 %Use modified baseline correction if sine
                                            groupHyperFilter(targInd).DatasCorr(:,:, groupHyperFilter(targInd).As ) = bandSplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize)  ) - ...
                                            blockBaselineAv; %Normalised to ~3s preceding start of block
                                            baselineCorrectionMethod = 0; %Override on account of sine
                                        elseif didSine == 0 %Use preceding 10% before stimulus was delivered to correct
                                            if baselineCorrectionMethod == 0
                                                groupHyperFilter(targInd).DatasCorr(:,:, groupHyperFilter(targInd).As ) = bandSplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize)  ) - ...
                                                    blockBaselineAv; %Normalised to ~3s preceding start of block
                                            elseif baselineCorrectionMethod == 1
                                                baselineWindow = floor([ (cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)-(baselineSize*captureWindowSize) :  (cycCentroid+captureWindowGeometryActive(1)*captureWindowSize) ]); %"Select baselineWindow % before start of captured window"
                                                groupHyperFilter(targInd).DatasCorr(:,:, groupHyperFilter(targInd).As ) = bandSplicedData(:, floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize) ) - ...
                                                     nanmean( bandSplicedData(:, baselineWindow ) ,2); %Bseline corrected to starting value
                                                        %Note: Dimension specification of 2 is critical to correctness (although tbh it'll probs crash if it is muffed up)
                                            end
                                        end

                                        %groupHyper(targInd).AUCsCorr(:, 1, groupHyper(targInd).As ) = trapz(groupHyper(targInd).DatasCorr(:,:, groupHyper(targInd).As )'); %Calculate integral
                                        groupHyperFilter(targInd).As = groupHyperFilter(targInd).As + 1;
                                        %groupHyper(targInd).Lists = [groupHyper(targInd).Lists; i, groupCyc, cycCentroid]; %Block, Relative cycle number, Absolute position
                                    end
                                end
                            end
                        end
                    end
                    %Calculate requested colours (if any) from specialEval
                    %{
                    thisGroupColourNum = [];
                    thisGroupColours = [];
                    if isempty( strfind(groupSpecialEval{targInd},'sentColours') ) ~= 1 && isempty( strfind(groupSpecialEval{targInd},'typeNum') ) ~= 1 %"A colour was specified for this group in the specialEval AND a type of cycle was specified"
                        evalColours = groupSpecialEval{targInd}( nanmin(strfind(groupSpecialEval{targInd},'"')) +1 : nanmax(strfind(groupSpecialEval{targInd},'"')) -1 ); %Find what colours were in the specialEval for this group
                            %Note: Requires a colour to have been specified
                        evalTypeStr = 'typeNum(groupCyc) == ';
                        evalType = groupSpecialEval{targInd}( strfind(groupSpecialEval{targInd},evalTypeStr) + size(evalTypeStr,2) ); %Find what cycle type were in the specialEval for this group
                            %Note: Requires a cycle type to have been specified (although this is usually a given)
                        evalTypeNum = str2num(evalType); %Above, but number
                        %foundInst = 0; %QA iterator
                        for colInd = 1:size(chanCodecContents,2)
                            findColourStatus = strfind(evalColours,chanCodecContents{colInd});
                            if isempty(findColourStatus) ~= 1
                                if evalTypeNum == 1 && findColourStatus > 1 %"Looking for oddball AND colour was not in first (carrier) position" (Will probs crash if doubleup of sentColour)
                                    thisGroupColourNum = [thisGroupColourNum,colInd]; %The index in chanCodecContents of the colour that this hyperGroup ended up collecting
                                    %foundInst = foundInst + 1;
                                    thisGroupColours = [thisGroupColours,chanCodecContents{thisGroupColourNum}];
                                elseif evalTypeNum == 0 && findColourStatus == 1 %"Looking for carrier AND colour was in first (carrier) position"
                                    thisGroupColourNum = [thisGroupColourNum,colInd];
                                    %foundInst + 1;
                                    thisGroupColours = [thisGroupColours,chanCodecContents{thisGroupColourNum}];
                                end                            
                            end
                        end
                        %QA
                        if size(thisGroupColourNum,2) > 1 && normaliseERPs == 3
                            ['## Alert: Too many colours found for colour normalising to be possible ##']
                            crash = yes %This is a pretty simple fix, but I cbf currently
                        end

                        groupHyper(targInd).cycleColoursNum = thisGroupColourNum;
                        groupHyper(targInd).cycleColours = thisGroupColours;
                    else
                        groupHyper(targInd).cycleColoursNum = NaN; %No specific colours specified
                        groupHyper(targInd).cycleColours = NaN; %Or perhaps no specific cycles specified
                    end
                    %}
                    filterStruct(filtInd).hyper(targInd).As = groupHyperFilter(targInd).As; %Note: As applies to all target groups, not just targsOfInterest
                end            

                %###
                
                
                %Calculate hyperGroup averages etc
                figure %1 figure per filter
                
                safePosS = linspace(0.2*captureWindowSize,0.8*captureWindowSize,size(targsOfInterest,2));
                
                for chanInd = 1:size(chansOfInterestActive,2)
                    chanToPlot = chansOfInterestActive(chanInd);
                    
                    subplot( size(chansOfInterestActive,2) , 1 , chanInd ) %1 row per channel, targets overlaid in different colours

                    groupFilterPlotDatas = [];

                    groupFilterDataAvs = [];
                    groupFilterDataSDs = [];

                    %groupFilterPhotAvs = [];
                    %groupFilterPhotSDs = [];
                
                    for targInd = 1:size(targsOfInterest,2)%size(groupTargets,2)
                        targToPlot = targsOfInterest(targInd); %Only used for interfaces with hyperData structures (since non-linear)

                        %Assemble 3D and 2D matrices
                        if groupHyperFilter(targToPlot).As ~= 0
                            if showCorrected == 0
                                groupPlotDatas{targInd} = groupHyperFilter(targToPlot).Datas(chanToPlot,:,:); %Uncorrected
                            else
                                groupPlotDatas{targInd} = groupHyperFilter(targToPlot).DatasCorr(chanToPlot,:,:); %Corrected
                            end

                            %Means etc
                            groupFilterDataAvs{targInd} = nanmean(groupPlotDatas{targInd}(1,:,:) ,3); %Row index of 1 because channel specification done earlier
                            groupFilterDataSDs{targInd} = nanstd(groupPlotDatas{targInd}(1,:,:), [] ,3);

                            %Plot
                            plot(groupFilterDataAvs{targInd}, 'Color', groupColours(targToPlot,:))
                            hold on
                            groupShadeCoordsX = [1:1:size(groupFilterDataAvs{targInd},2),size(groupFilterDataAvs{targInd},2):-1:1];
                            groupShadeCoordsY = [groupFilterDataAvs{targInd}+groupFilterDataSDs{targInd},flip(groupFilterDataAvs{targInd}-groupFilterDataSDs{targInd})];
                            fill(groupShadeCoordsX, groupShadeCoordsY, groupColours(targToPlot,:)) %Error shading
                            alpha(0.15)

                            %Ancillary text
                            safePos = floor(safePosS(targInd));
                            text(safePos,groupFilterDataAvs{targInd}(floor(safePos)), ['G:',num2str(targToPlot)], 'Color', 'r')

                        else
                            disp(['## Could not plot filtered hyperGroup ',num2str(targToPlot),' on account of emptiness ##'])
                        %hyperGroup empty end    
                        end

                        %pause(1)
                    end
                    
                    yPull = get(gca,'YLim');
                    line([abs(captureWindowGeometryActive(1)*captureWindowSize),abs(captureWindowGeometryActive(1)*captureWindowSize)],[yPull(1),yPull(2)], 'LineStyle', ':', 'Color', 'k')
                    yLimData(filtInd,:) = yPull;

                    xlim([0, captureWindowSize])
                    exTicks = cellfun(@str2num, get(gca,'XTickLabel')) - abs(captureWindowGeometryActive(1) * captureWindowSize);
                    xticklabels(exTicks)
                    xlim([1,captureWindowSize])
                    xlabel(['Time (ms)'])

                    title(['Ch. ',num2str(chanToPlot),' - Filter range: ',num2str(filterRanges(filtInd,1)),' - ', num2str(filterRanges(filtInd,2)),'Hz' ])
                    
                    filterStruct(filtInd).data(chanInd).chanToPlot = chanToPlot;
                    filterStruct(filtInd).data(chanInd).groupFilterDataAvs = groupFilterDataAvs;
                    filterStruct(filtInd).data(chanInd).groupFilterDataSDs = groupFilterDataSDs;
                end
                
                thisFigName = ['FilteredERPs - ',num2str(filterRanges(filtInd,1)),' to ', num2str(filterRanges(filtInd,2)),'Hz'];
                set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName]);

                %###########
                %Save figure
                if saveFigs == 1
                    try
                        savePlot(saveName,thisFigName,figStr)
                    catch 
                        ['-# Alert: Failure to save plot #-']
                    end
                end
                %###########

            end

            
        end

        %---------------------------------

        %End here
        % <-

        %MMN
        %(Target section block commented because of new position up top)
        %{
        %##########################
        %mmnTargets = [2,1 ; 4,3]; %"Subtract the first of each row from the second of each row
        mmnTargets = [1,2]; 
        %##########################
        %}

        figure
        figStr = [];
        for chanInd = 1:size(chansOfInterestActive,2)
            chanToPlot = chansOfInterestActive(chanInd);
            %subplot(size(chansOfInterest,2),1,chanInd) %Rows
            subplot(1, size(chansOfInterestActive,2),chanInd) %Cols

            thisTitleStr = [];

            for mmnInd = 1:size(mmnTargets,1)
                firstGroupToPlot = mmnTargets(mmnInd,1);
                secondGroupToPlot = mmnTargets(mmnInd,2);

                if isempty(groupHyper(firstGroupToPlot).Lists) ~= 1 && isempty(groupHyper(secondGroupToPlot).Lists) ~= 1

                    firstGroupMean = nanmean(groupHyper(firstGroupToPlot).Datas(chanToPlot,:,:),3);
                    secondGroupMean = nanmean(groupHyper(secondGroupToPlot).Datas(chanToPlot,:,:),3);

                    mmnData = firstGroupMean - secondGroupMean;

                    %Plot
                    plot(firstGroupMean, 'Color', groupColours(firstGroupToPlot,:)) %Source 1
                    hold on
                    plot(secondGroupMean, 'Color', groupColours(secondGroupToPlot,:)) %Source 2

                    plot(mmnData, ':', 'LineWidth', 2, 'Color', nanmean( [groupColours(firstGroupToPlot,:) ; groupColours(secondGroupToPlot,:) ] , 1 ) ) %Plot MMN in colour that is average of source groups

                    %Text

                    safePosS = linspace(0.2*size(mmnData,2),0.8*size(mmnData,2),size(mmnTargets,1));            
                    safePos = floor(safePosS(mmnInd));
                    %text(safePos+targInd,groupDataAvs{targInd}(targInd+safePos), ['G:',num2str(targInd),',C:',num2str(chanToPlot)], 'Color', 'r')
                    text(safePos,firstGroupMean(safePos), ['First - G:',num2str(firstGroupToPlot)], 'Color', 'r')
                    text(safePos,secondGroupMean(safePos), ['Second - G:',num2str(secondGroupToPlot)], 'Color', 'r')
                    text(safePos,mmnData(safePos), ['MMN - Gs: ',num2str(mmnTargets(mmnInd,:))], 'Color', 'r')

                    %Title support
                    thisTitleStr = [thisTitleStr, '"',groupDescriptors{firstGroupToPlot},'"(G:',num2str(firstGroupToPlot),') - "',groupDescriptors{secondGroupToPlot},'"(G:',num2str(secondGroupToPlot),') , '];
                    if chanInd == size(chansOfInterestActive,2)
                        figStr = [figStr, 'G', num2str(firstGroupToPlot), ' - G',num2str(secondGroupToPlot), ' -- '];
                    end

                end

            end
            ylim(pulledYLims);
            %ylim([-400, 400]);
            %line([ captureWindowSize*(-captureWindowGeometry(1)),captureWindowSize*(-captureWindowGeometry(1)) ],[-300,300], 'LineStyle', ':', 'Color', 'k') %Stimulus onset (more or less)
            if isempty(fixedPhotodiodeScale) ~= 1
                line([ captureWindowSize*(-captureWindowGeometryActive(1)),captureWindowSize*(-captureWindowGeometryActive(1)) ],[-fixedPhotodiodeScale,fixedPhotodiodeScale], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
            else
                line([ captureWindowSize*(-captureWindowGeometryActive(1)),captureWindowSize*(-captureWindowGeometryActive(1)) ],[-300,300], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
            end
            %figTitle = ['MMN of "',groupDescriptors{firstGroupToPlot},'"(G:',num2str(firstGroupToPlot),') subtracted from "',groupDescriptors{secondGroupToPlot},'"(G:',num2str(secondGroupToPlot),') at channel ',num2str(chanToPlot)];
            figTitle = ['MMN of ',thisTitleStr,' at Channel ',num2str(chanToPlot)];
            figTitleProc = [ repmat(' ', chanInd-1, size(figTitle,2)) ; figTitle ; repmat(' ', size(chansOfInterestActive,2)-chanInd, size(figTitle,2)) ];
            title(figTitleProc)

        end
        figStr = [figStr, 'C ', num2str(chansOfInterestActive)]; %Supplement figStr with channel data
        thisFigName = 'MMN';
        set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName]);

        %###########
        %Save figure
        if saveFigs == 1
            try
                savePlot(saveName,thisFigName,figStr)
            catch 
                ['-# Alert: Failure to save plot #-']
            end
        end
        %###########

        %shapesInTheSnow

        %Compute Power Spectrum
        %fprintf('Computing power spectrum.\n');
        %{
        if specMethod == 1
            disp('-- Computing power spectrum (mtspectrumsc) --');
        else
            disp('-- Computing power spectrum (pwelch) --');
        end
        %}
        disp(['-- Computing power spectrum (',specIndex{specMethod},') --'])
        tic

        if specMethod == 1
            %clear freqTrials
            % This first part is from Dror's code "computeTrialSpectrumAndSpectrogram"
            % params.pad=1;
            addpath(genpath([toolPath filesep 'chronux_2_11'])); %Adding the genpath line allows the addition of subfolders to the path
        end

        params.Fs=resampleFreq;
        % params.fpass=[0.5 300];
        %movingwin=[1 0.5];
        params.tapers=[3 5];
        freqTrials = struct;
        %taper = [3 5];
        %try
        %for trialIndx=1:size(LFP, 2)
        for i = 1:size(blockStruct, 2)
            %disp(['trial num: ' num2str(trialIndx)])
            %disp(['Block num: ' num2str(i)])
            %
            %Spectrum
            %         Output:
            %       S       (spectrum in form frequency x channels/trials if trialave=0;
            %               in the form frequency if trialave=1)
            %       f       (frequencies)
            %       Serr    (error bars) only for err(1)>=1

            %[spectruS2, spectruF2]=mtspectrumc(LFP(trialIndx).P1On(:,PreStimPeriod:length(LFP(trialIndx).P1On)-PostStimPeriod)',params); %panel 2 bipolar referenced
            thisBlockData = SplicedData(:, blockStruct(i).range); %Need to check that 'range' is correctly synchronised
            %thisBlockPhot = SplicedStim(4, blockStruct(i).range);
            %thisBlockPhot = SplicedPhot(1, blockStruct(i).range);
            thisBlockPhot = SplicedPhot(1, blockStruct(i).photRange);
            
            spectruS2 = NaN; spectruS3 = NaN; spectruF2 = NaN; spectruF3 = NaN; %Prepare in case of fail
            spectruSPhot = NaN; spectruFPhot = NaN;
            
            try
                if specMethod == 1 %mtspectrumc

                    [spectruS2, spectruF2]=mtspectrumc(thisBlockData',params); %panel 2 bipolar referenced
                    [spectruSPhot, spectruFPhot]=mtspectrumc(thisBlockPhot',params);

                    if isfield(blockStruct(i), 'blockBaseline') == 1
                        thisBlockBaseline =  blockStruct(i).blockBaseline;
                        [spectruS3, spectruF3]=mtspectrumc(thisBlockBaseline',params);
                    else
                        spectruS3 = NaN;
                        spectruF3 = NaN;
                    end

                elseif specMethod == 2 %pwelch

                    ['## PWelch not yet implemented! ##']
                    crash = yes

                elseif specMethod == 3 %Just FFT

                    transpThisBlockData = transpose(thisBlockData);
                    transpThisBlockPhot = transpose(thisBlockPhot);
                    thisBlockDataFFT = fft(transpThisBlockData);
                    thisBlockPhotFFT = fft(transpThisBlockPhot);
                    spectruS2 = 2 * (1/resampleFreq)^2 / blockStruct(i).duration * thisBlockDataFFT.*conj(thisBlockDataFFT);
                    spectruS2 = spectruS2(1:length(transpThisBlockData)/2+1,:); %Note: I am not sure about this step (SEEK MARTYNA CLARIFICATION)
                    spectruSPhot = 2 * (1/resampleFreq)^2 / blockStruct(i).duration * thisBlockPhotFFT.*conj(thisBlockPhotFFT);
                    spectruSPhot = spectruSPhot(1:length(transpThisBlockData)/2+1,:); %Note: I am not sure about this step (SEEK MARTYNA CLARIFICATION)
                    freqRes = 1/max(blockStruct(i).duration);
                    nyqFreq = 1/(1/resampleFreq)/2;
                    spectruF2 = (0:freqRes:nyqFreq); %Note: Different in size to spectruF2 produced by mtspectrumc
                    spectruFPhot = spectruF2;

                    if isfield(blockStruct(i), 'blockBaseline') == 1 && size(blockStruct(i).blockBaseline,2) > 1
                        thisBlockBaseline =  blockStruct(i).blockBaseline;
                        transpThisBlockBaseline = transpose(thisBlockBaseline);
                        baselineDuration = size(thisBlockBaseline,2) / resampleFreq;
                        %[spectruS3, spectruF3]=mtspectrumc(thisBlockBaseline',params);
                        thisBlockBaselineFFT = fft(transpThisBlockBaseline);
                        spectruS3 = 2 * (1/resampleFreq)^2 / baselineDuration * thisBlockBaselineFFT.*conj(thisBlockBaselineFFT);
                        spectruS3 = spectruS3(1:length(thisBlockBaseline)/2+1,:);
                        baseFreqRes = 1/max(baselineDuration);
                        spectruF3 = (0:baseFreqRes:nyqFreq);
                    else
                        spectruS3 = NaN;
                        spectruF3 = NaN;
                        if isfield(blockStruct(i), 'blockBaseline') == 1
                            disp(['-# Block baseline error for block #',num2str(i),' ##'])
                        end
                    end

                    %Plot
                    %{
                    figure
                    plot(spectruF2,spectruS2(:,1), 'r') %Plot channel 1
                    xlim([1 20])
                    %}

                end
            catch
                ['## Alert: Failure to calculate PSD entirely for block #',num2str(i),' ##']
            end

            %if isfield(LFP, 'Baseline')

            %{
            freqTrials(trialIndx).spectruS2=spectruS2; %panel 2
            freqTrials(trialIndx).spectruF2=spectruF2;


            if isfield(LFP, 'Baseline');
                freqTrials(trialIndx).spectruS3=spectruS3; %panel 2
                freqTrials(trialIndx).spectruF3=spectruF3;
            end

            % Baseline correct for every trial
            freqTrials(trialIndx).spectruS2PreBase = 10*log10(freqTrials(trialIndx).spectruS2);
            freqTrials(trialIndx).spectruS2 = 10*log10(freqTrials(trialIndx).spectruS2) - 10*log10(freqTrials(trialIndx).spectruS3); % This Baseline Corrects in the frequency domain
            %}
            blockStruct(i).specS = spectruS2;
            blockStruct(i).specF = spectruF2;

            blockStruct(i).baselineSpecS = spectruS3;
            blockStruct(i).baselineSpecF = spectruF3;

            blockStruct(i).specSLog = 10*log10(spectruS2);

            blockStruct(i).specSPhot = spectruSPhot;
            blockStruct(i).specFPhot = spectruFPhot;

            blockStruct(i).specSPhotLog = 10*log10(spectruSPhot);

            %%blockStruct(i).specSLogCorr = 10*log10(spectruS2) - 10*log10(spectruS3); %CURRENTLY BROKEN

        end
        disp(['-- Power spectrums computed in ',num2str(toc),'s --'])
        %end

        %Plot average PSDs
        %jittGroups = [0,1,3]; %Defines the possible jitter states
        %Programmatically determine the jitter groups that occurred in this data
        jittList = [];
        for i = 1:size(blockStruct,2)
            jittList = [jittList, blockStruct(i).jittering];
        end
        jittGroups = unique(jittList);

        viewWindow = [ 0.5 , 1.5*f1]; %Min and max freqs in Hz to be showed
        %{
        %(This code shifted into loop to allow for more case-specific accuracy)
        %Find viewWindow coords in exemplar F
        [~, viewWindowFloorIndex] = min( abs(blockStruct(1).specF - viewWindow(1)) );
        [~, viewWindowCeilIndex] = min( abs(blockStruct(1).specF - viewWindow(2)) );
        %viewWindowRange = [ find(floor(blockStruct(1).specF) == viewWindow(1),1) : find(floor(blockStruct(1).specF) == viewWindow(2),1) ]; %Coords within specF
            %Note: The use of "floor" here is the lazy man's way to guarantee a direct hit for the find, but a minimisation technique would be superior
        viewWindowRange = [ viewWindowFloorIndex : viewWindowCeilIndex ]; %Coords within specF
        %}

        %QA
        %{
        if isempty(viewWindowRange) == 1
            ['# Alert: Fatal error in viewWindowRange determination #']
            crash = yes
        end
        %}

        jittColours = winter(size(jittGroups,2));

        chanPsData = []; %Will store channel-specific psData
        jittStruct = struct;

        for chanInd = 1:size(chansOfInterestActive,2)
            chanToPlot = chansOfInterestActive(chanInd);
            jittStruct.data(chanInd).chanToPlot = chanToPlot;

            figure

            jittAs = ones(1,size(jittGroups,2)); %See above simpler than complicated size operations

            psData = []; %Will hold the (nominally three) groups in cells
            psList = []; %Keeps track of what blocks went into the structure
            psPhotData = [];
            standardSize = []; %Standard data size for each jitter type
            standardF = []; %Standard frequency range for each jitter type
            standID = []; %ID of aforementioned standards
            standViewWindowRange = []; %Need to clear cos [re]used above

            mismatchedSizeCorrectedCount = 0; %How many blocks had to have their size corrected
            %Collect all relevant data
            for i = 1:size(blockStruct,2)
                thisBlockJittStateInd = find(jittGroups == blockStruct(i).jittering,1); %Note that this is the index in jittGroups, not the actual state
                %%preData = blockStruct(i).specSLog(:,chanToPlot)';
                %%preDataPhot = blockStruct(i).specSPhotLog(:,1)';
                preData = blockStruct(i).specS(:,chanToPlot)';
                preDataPhot = blockStruct(i).specSPhot(:,1)';
                preData = real(preData); preDataPhot = real(preDataPhot); %real-ification in case of complex parts

                if jittAs(thisBlockJittStateInd) == 1
                    standardSize{thisBlockJittStateInd} = size(blockStruct(i).specS,1);
                    standardF{thisBlockJittStateInd} = blockStruct(i).specF;
                    standID{thisBlockJittStateInd} = i;
                    %Find viewWindow coords in exemplar F
                    [~, viewWindowFloorIndex] = min( abs(blockStruct(i).specF - viewWindow(1)) );
                    [~, viewWindowCeilIndex] = min( abs(blockStruct(i).specF - viewWindow(2)) );
                    standViewWindowRange{thisBlockJittStateInd} = [ viewWindowFloorIndex : viewWindowCeilIndex ]; %Coords within specF
                    %QA
                    if isempty(standViewWindowRange{thisBlockJittStateInd}) == 1
                        ['# Alert: Fatal error in viewWindowRange determination #']
                        crash = yes
                    end
                end

                %Quick QA for mismatched size
                %if jittAs(thisBlockJittStateInd) > 1 && size(blockStruct(i).specSLog,1) ~= size(psData{thisBlockJittStateInd},2) %This will crash if no data is existing for a particular jittGroup
                if jittAs(thisBlockJittStateInd) > 1 && size(blockStruct(i).specS,1) ~= standardSize{thisBlockJittStateInd} %This will crash if no data is existing for a particular jittGroup
                    %%['# Alert: Mismatch between current block PSD size and existing block PSD sizes #']
                    %%crash = yes
                    preData = imresize( preData, [1,standardSize{thisBlockJittStateInd}], 'bilinear' ); %Resize S data to be same size as first block's S data
                    preDataPhot = imresize( preDataPhot, [1,standardSize{thisBlockJittStateInd}], 'bilinear' );

                    %QA
                    temp = imresize( blockStruct(i).specF, [1,standardSize{thisBlockJittStateInd}], 'bilinear' );
                    if nansum(abs(temp - standardF{thisBlockJittStateInd})) / ...
                            size(blockStruct(1).specF,2) > 0.05
                            %This essentially calculates the absolute divergence between the resized frequency range and the original frequency range
                        ['## Warning: Attempted to resize PSD for block ',num2str(i),' but resizing error exceeded 5% ##']
                        crash = yes
                            %There is a hardcoded comparison dependency here with block 1, but that is excusable given that the X axis eventually comes from block 1 anyway
                    end
                    mismatchedSizeCorrectedCount = mismatchedSizeCorrectedCount + 1;
                end

                %psData{thisBlockJittStateInd}(jittAs(thisBlockJittStateInd), 1 : size(blockStruct(i).specSLog,1)) = blockStruct(i).specSLog(:,chanToPlot)';
                psData{thisBlockJittStateInd}(jittAs(thisBlockJittStateInd), 1 : size(preData,2)) = preData;
                %psDataPhot{thisBlockJittStateInd}(jittAs(thisBlockJittStateInd), 1 : size(blockStruct(i).specSPhotLog,1)) = blockStruct(i).specSPhotLog(:,1)';
                psDataPhot{thisBlockJittStateInd}(jittAs(thisBlockJittStateInd), 1 : size(preDataPhot,2)) = preDataPhot;
                psList{thisBlockJittStateInd}(jittAs(thisBlockJittStateInd)) = i;

                jittAs(thisBlockJittStateInd) = jittAs(thisBlockJittStateInd) + 1;
            end
            %Report if any size resizing had to be done
            if mismatchedSizeCorrectedCount > 0
                disp(['#- ',num2str(mismatchedSizeCorrectedCount),' block PSDs for channel ',num2str(chanToPlot),' had to be resized to match standard block size -#'])
            end
            
            chanPsData{chanToPlot} = psData;

            %Average and plot
            psDataAv = [];
            psDataSEM = [];
            psPhotDataAv = [];
            psPhotDataSEM = [];
            for jittInd = 1:size(psData,2)
                subplot(size(psData,2),1,jittInd) %Nominally 3 rows
                thisJitt = jittGroups(jittInd);

                %Average
                psDataAv{jittInd} = nanmean(psData{jittInd},1);
                psDataSEM{jittInd} = nanstd(psData{jittInd},1) / sqrt(size(psData{jittInd},1));
                %Ditto photodiode
                psDataPhotAv{jittInd} = nanmean(psDataPhot{jittInd},1);
                psDataPhotSEM{jittInd} = nanstd(psDataPhot{jittInd},1) / sqrt(size(psDataPhot{jittInd},1));

                %Plot
                %plot( blockStruct(1).specF(viewWindowRange)  , psDataAv{jittInd}(viewWindowRange) , 'Color', jittColours(jittInd,:) );
                plot( standardF{jittInd}(standViewWindowRange{jittInd})  , psDataAv{jittInd}(standViewWindowRange{jittInd}) , 'Color', jittColours(jittInd,:) );
                hold on
                psShadeCoordsX = [standardF{jittInd}(standViewWindowRange{jittInd}),flip(standardF{jittInd}(standViewWindowRange{jittInd}))];
                psShadeCoordsY = [psDataAv{jittInd}(standViewWindowRange{jittInd})+psDataSEM{jittInd}(standViewWindowRange{jittInd}),flip(psDataAv{jittInd}(standViewWindowRange{jittInd})-psDataSEM{jittInd}(standViewWindowRange{jittInd}))]; %+- SEM
                fill(psShadeCoordsX, psShadeCoordsY, [jittColours(jittInd,:)]) %Error shading
                alpha(0.15)
                
                %{
                hold on
                psShadeCoordsX = [1:1:size(psDataAv{jittInd}(viewWindowRange),2),size(psDataAv{jittInd}(viewWindowRange),2):-1:1];
                psShadeCoordsY = [psDataAv{jittInd}(viewWindowRange)+0.5*psDataSEM{jittInd}(viewWindowRange),flip(psDataAv{jittInd}(viewWindowRange)-0.5*psDataSEM{jittInd}(viewWindowRange))];
                fill(psShadeCoordsX, psShadeCoordsY, jittColours(jittInd,:)) %Error shading
                alpha(0.15)
                %}
                %Plot photodiode
                hold on
                photPlotData = ( psDataPhotAv{jittInd}(standViewWindowRange{jittInd}) / nanmax(psDataPhotAv{jittInd}(standViewWindowRange{jittInd})) ) * nanmax(psDataAv{jittInd}(standViewWindowRange{jittInd}));
                photFactor = nanmax(photPlotData) / nanmax( psDataPhotAv{jittInd}(standViewWindowRange{jittInd}) ); %Calculate how much photData was deflated by
                photPlotData = photPlotData + nanmax(psDataAv{jittInd}(standViewWindowRange{jittInd}));
                photPlotSEM = psDataPhotSEM{jittInd} * photFactor;
                plot( standardF{jittInd}(standViewWindowRange{jittInd})  , photPlotData , 'Color', [1.0,0.647,0.0] );
                psPhotShadeCoordsX = [standardF{jittInd}(standViewWindowRange{jittInd}),flip(standardF{jittInd}(standViewWindowRange{jittInd}))];
                psPhotShadeCoordsY = [photPlotData+photPlotSEM(standViewWindowRange{jittInd}),flip(photPlotData-photPlotSEM(standViewWindowRange{jittInd}))]; %+- SEM

                fill(psPhotShadeCoordsX, psPhotShadeCoordsY, [1.0,0.647,0.0]) %Error shading
                    %Note: Scale and shading of photodiode signal is for display purposes only
                alpha(0.15)

                xlim(viewWindow)

                title(['Jitter: ',num2str(jittGroups(jittInd)),' (',jittDescriptors{thisJitt+1},'), n=',num2str(size(psData{jittInd},1)),' blocks, Channel: ',num2str(chanToPlot), ' (',specIndex{specMethod},') (Not log corrected)']) %+1 necessary because MATLAB indexing
                xlabel(['Frequency (Hz)'])
                ylabel(['Power (dB)'])
            end
            
            thisFigName = 'JittPSDs';
            set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName, ' (Ch ',num2str(chanToPlot),')']);
            figStr = [];
            
            jittStruct.jittGroups = jittGroups;
            jittStruct.data(chanInd).standardF = standardF;
            jittStruct.data(chanInd).standViewWindowRange = standViewWindowRange;
            jittStruct.data(chanInd).psDataAv = psDataAv;
            jittStruct.data(chanInd).psDataSEM = psDataSEM;
            jittStruct.phot.psDataPhotAv = psDataPhotAv;
            jittStruct.phot.psDataPhotSEM = psDataPhotSEM;
            
            %###########
            %Save figure
            if saveFigs == 1
                try
                    savePlot(saveName,thisFigName,figStr)
                catch 
                    ['-# Alert: Failure to save plot #-']
                end
            end
            %###########

        end

        %------------------------------

        %Chronological PSD plot for sparsening experiment
        if nansum(jittList == 4) > 0 %"Sparsening blocks exist"
            overChron = struct;
            targetPs = find(jittGroups == 4);

            try
                %targetFreq = [f1-0.2*f1,f1+0.2*f1]; %Without the addition of 'floor' here this is liable to cause issues
                targetFreq = floor([f1-0.2*f1,f1+0.2*f1]); %Will define the X limits of both plots

                %LFP data at channels
                for chanInd = 1:size(chansOfInterestActive,2)
                    chanToPlot = chansOfInterestActive(chanInd);

                    figure

                    %joyData = psData{targetPs}(:,viewWindowRange); %Only uses the most recent channel
                    joyData = chanPsData{chanToPlot}{targetPs}(:,standViewWindowRange{4}); %Hardcoded jittInd of 4 for standViewWindowRange
                    joySpace = linspace(viewWindow(1),viewWindow(2),size(joyData,2));
                    joyPlot(joyData', joySpace, 12)
                    xlim(targetFreq)
                    xlabel('Freq. (Hz)')
                    ylabel('Block num.')
                    title(['Channel ',num2str(chanToPlot)])
                    thisFigName = 'ChronRidgePlot';
                    set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName]);

                    overChron.joyPlot(chanInd).joyData = joyData;
                    overChron.joyPlot(chanInd).joySpace = joySpace;     
                end

                %Photodiode
                figure
                
                %{
                %targetWindowRange = [ find(floor(blockStruct(1).specF) == targetFreq(1),1) : find(floor(blockStruct(1).specF) == targetFreq(2),1) ];
                [~,targetWindowStartEnd(1)] = min(abs(blockStruct(1).specF - targetFreq(1)));
                [~,targetWindowStartEnd(2)] = min(abs(blockStruct(1).specF - targetFreq(2)));
                targetWindowRange = [targetWindowStartEnd(1):targetWindowStartEnd(2)]; %Use of min more accurate than floor and find
                %}
                targetWindowRange = standViewWindowRange{4}; %Uses data from previous plot
                %QA
                if isempty(targetWindowRange) == 1
                    ['## Alert: targetWindowRange returned empty ##']
                end

                photPlotData = [];
                photPlotDataNorm = [];
                for i = 1:size(blockStruct,2)
                    photPlotData(i,:) = blockStruct(i).specSPhot(standViewWindowRange{4},1)';
                end
                %photPlotDataNorm = photPlotData / nanmax(nanmax(photPlotData(:,targetWindowRange))); %Double maxing at target range (because start has exceptionally high peaks)
                photPlotDataNorm = ( photPlotData / nanmax(nanmax(photPlotData(:,targetWindowRange))) ) * 100; %Double maxing at target range (because start has exceptionally high peaks)
                    %"Thank christ the photodiode channel values are arbitrary"
                photSpace = linspace(viewWindow(1),viewWindow(2),size(photPlotData,2));
                %joyPlot(photPlotData', photSpace, 12, 'LineColor','r' ) %Log corrected
                joyPlot(photPlotDataNorm', photSpace, 12, 'LineColor','r' ) %Normalised
                xlim(targetFreq)
                xlabel('Freq. (Hz)')
                ylabel('Block num.')
                title(['Photodiode channel'])
                thisFigName = 'ChronRidgePlotPhot';
                set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName]);

                overChron.joyPlotPhot.photPlotDataNorm = photPlotDataNorm;
                overChron.joyPlotPhot.photSpace = photSpace;
            catch
                ['## Could not do joyPlot; Attempting backup ##']
                %Backup, furry carpet plot
                blockColours = parula(size(blockStruct,2));

                for chanInd = 1:size(chansOfInterestActive,2)
                    chanToPlot = chansOfInterestActive(chanInd);

                    figure

                    for i = 1:size(psData{1},1)
                        plotData = chanPsData{chanToPlot}{targetPs}(:,standViewWindowRange{4}); 
                        plot3( [1:size(plotData,2)], [  repmat(i, 1, size(plotData,2)) ] , plotData , 'Color', blockColours(i,:) )
                        hold on
                    end 
                    xlim([f1-0.2*f1,f1+0.2*f1])
                    title(['Channel ',num2str(chanToPlot)])

                end
                thisFigName = 'ChronCarpetPlot';
                set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName]);

                %overChron.carpetPlot()
            end


            %###########
            %Save figure
            if saveFigs == 1
                try
                    savePlot(saveName,thisFigName,figStr)
                catch 
                    ['-# Alert: Failure to save plot #-']
                end
            end
            %###########

            %Line plot of power at selected frequencies over time
            figure

            lineData = [];
            linePhotData = [];
            trueData = [];
            %%targF = [ find(floor(blockStruct(1).specF) == floor(f1),1) ]; %Finds the designated position in specF to pull power from for all blocks
                %Note: Use of floor here will induce minor inaccuracy
            [minVal, targF] = min(abs(blockStruct(1).specF - f1)); %Finds the designated position in specF to pull power from for all blocks
                %Note: Use of floor here will induce minor inaccuracy
            %QA
            if isempty(targF) == 1
                ['## Alert: targF returned empty ##']
                crash = yes
            end
            lineMax = []; %Will store the max values of each line
            for chanInd = 1:size(chansOfInterestActive,2)
                chanToPlot = chansOfInterestActive(chanInd);

                for i = 1:size(blockStruct,2)
                    lineData(chanInd,i) = blockStruct(i).specS(targF,chanToPlot); %Not log or corrected
                end
                if normaliseERPs == 2
                    lineData(chanInd,:) = lineData(chanInd,:) / nanmax(lineData(chanInd,:)); %Normalise by own maximum per channel
                end
                    %Note: It may not be possible to (easily) normalise by own onset amplitudes for this plot
                plot(lineData(chanInd,:), 'LineWidth', 1.25, 'Color', chanColours(chanInd,:))
                hold on
                if normaliseERPs ~= 1
                    text(size(blockStruct,2)*0.5, lineData( chanInd, floor(size(blockStruct,2)*0.5) ) , ['C:',num2str(chanToPlot)], 'Color', 'r')
                else
                    text(size(blockStruct,2)*0.5, lineData( chanInd, floor(size(blockStruct,2)*0.5) ) , ['C:',num2str(chanToPlot),' (Norm.)'], 'Color', 'r')
                end

                lineMax = [lineMax, nanmax(lineData(chanInd,:))];
            end

            for i = 1:size(blockStruct,2)
                linePhotData(i) = blockStruct(i).specSPhot(targF,1); %Techically this will occur as many 
                trueData(i) = size(blockStruct(i).artUnderPeaksCarrier,2);
            end
            %Plot phot and true
            linePhotData = ( linePhotData / nanmax(linePhotData) ) * nanmax(lineMax); %"Normalise by own max, then normalise to lineData max of maxes"
            trueData = ( trueData / nanmax(trueData) ) * nanmax(lineMax); %Normalise by maximum number of carrier cycles (assumption that this corresponds to 100%)
            plot(linePhotData, 'LineStyle', ':', 'LineWidth', 1, 'Color', [1.0,0.647,0.0] ) %Orange
            %plot(linePhotData, 'LineStyle', ':', 'LineWidth', 1, 'Color', 'r' ) %Red
            text(size(blockStruct,2)*0.75, linePhotData( floor(size(blockStruct,2)*0.75) ) , ['Photodiode'], 'Color', [1.0,0.647,0.0] )
            plot(trueData, 'LineStyle', ':', 'LineWidth', 1, 'Color', 'k' )
            text(size(blockStruct,2)*0.65, trueData( floor(size(blockStruct,2)*0.65) ) , ['True'], 'Color', 'k' )

            xlim([1,size(blockStruct,2)])
            xlabel(['Time (block #)'])
            ylabel(['Power'])
            thisFigName = 'ChronLinePlot';
            set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName]);

            overChron.chronLinePlot.lineData = lineData;
            overChron.chronLinePlot.linePhotData = linePhotData;
            overChron.chronLinePlot.trueData = trueData;

            %###########
            %Save figure
            if saveFigs == 1
                try
                    savePlot(saveName,thisFigName,figStr)
                catch 
                    ['-# Alert: Failure to save plot #-']
                end
            end
            %###########
        %Sparsening-specific end    
        end

        %Singular ridgeline plots for baseline data 
        %(Pre-experiment baseline determination moved earlier in script to aid QAs)
        %{
        try
            baselineDuration = stimDuration; %Probably good to keep this a similar size to actual experiment blocks
        catch
            baselineDuration = 20.01; 
            ['# Could not auto-detect stimulus duration for use with baseline; Using default value #']
        end

        %Determine when good baseline is
        proceed = 0; 
        if useSaveStruct == 1
            if isempty( matStruct.sentStimuli(1).Condition ) == 1 %Empty Condition field = Rest block
                restSentTimeRel = posixtime(datetime(strcat(matStruct.sentStimuli(1).trialSendDatestr),'Format', 'yyyy dd/MM HH:mm:ss:SSS')) - eegStartTimePosix;
                restRange = floor([ restSentTimeRel*resampleFreq : restSentTimeRel*resampleFreq + baselineDuration*resampleFreq ]);
                subProceed = 0;
                while subProceed == 0
                   if nanmax(restRange) >= nanmin(blockStruct(1).range) %This relies on the assumption that blockStruct contains only non-rest blocks
                       disp(['# Baseline for PSD data overlaps first non-rest block by ',num2str( (nanmin(blockStruct(1).range) - nanmax(restRange))/resampleFreq ),'s; Recalculating #'])
                       restRange = restRange - floor(4*resampleFreq); %Subtract 4s of data and try again
                       if nanmin(restRange) < 1
                           ['## Alert: Attempted to pull baseline from before data is existing ##'] %Most likely if baseline is too long or paradigm did not have rest at start
                           crash = yes
                       end
                       subProceed = 0;
                   else
                       disp(['- Baseline for PSD data precedes first non-rest block by ',num2str( (nanmin(blockStruct(1).range) - nanmax(restRange))/resampleFreq ),'s -'])
                       subProceed = 1;
                       proceed = 1;
                   end
                end
            else
                proceed = 0; %Do following loop
            end
        end
        if useSaveStruct ~= 1 || proceed == 0   
            disp(['- Using arbitrary baseline period for PSD -'])
            restRange = floor( [ nanmin(blockStruct(1).range) - 4*resampleFreq - baselineDuration*resampleFreq : nanmin(blockStruct(1).range) - 4*resampleFreq ] ); %"[First block start minus 4 seconds minus baselineDuration : First block start minus 4s]"
            if nanmin(restRange) < 1
               ['## Alert: Attempted to pull baseline from before data is existing ##'] %Most likely if baseline is too long or paradigm did not have rest at start
               crash = yes
           end
        end
        %}

        figure
        %customViewWindow = [0 , 175];
        %customViewWindowRange = [ find(floor(blockStruct(1).specF) == customViewWindow(1),1) : find(floor(blockStruct(1).specF) == customViewWindow(2),1) ];
        %Find first non-empty standViewWindowRange
        baseViewWindowRange = [];
        jittInd = 1;
        while isempty(baseViewWindowRange) == 1
            try
               baseViewWindowRange = standViewWindowRange{jittInd}; 
            end
            jittInd = jittInd + 1;
        end

        for chanInd = 1:size(chansOfInterestActive,2)
            chanToPlot = chansOfInterestActive(chanInd);

            subplot(size(chansOfInterestActive,2)+1,1,chanInd)

            thisBaselineData = SplicedData(chanToPlot,restRange); %Collect data
            if specMethod == 1
                [spectruS2, spectruF2]=mtspectrumc(thisBaselineData',params); %Uses same params from initial PSDs
            elseif specMethod == 3
                transpThisBaselineData = transpose(thisBaselineData);
                thisBaselineDataFFT = fft(transpThisBaselineData);
                restDuration = size(restRange,2) / resampleFreq;
                spectruS2 = 2 * (1/resampleFreq)^2 / restDuration * thisBaselineDataFFT.*conj(thisBaselineDataFFT);
                freqRes = 1/max(restDuration);
                nyqFreq = 1/(1/resampleFreq)/2;
                spectruF2 = (0:freqRes:nyqFreq);
            end
            specSLog = 10*log10(spectruS2);

            joyData = spectruS2(baseViewWindowRange,1); 
            %joyDataLog = specSLog(viewWindowRange,1); 
            %%joySpace = linspace(viewWindowRange(1),viewWindowRange(2),size(joyData,1));
            joySpace = linspace(spectruF2(baseViewWindowRange(1)),spectruF2(baseViewWindowRange(end)),size(joyData,1));
            %joyPlot(joyData, joySpace, 12)
            plot(joySpace, joyData')
            
            %{
            %(Can't really do shading since N = 1 baseline per fly)
            joyShadeCoordsX = [joySpace,flip(joySpace)];
            joyShadeCoordsY = [psDataAv{jittInd}(standViewWindowRange{jittInd})+psDataSEM{jittInd}(standViewWindowRange{jittInd}),flip(psDataAv{jittInd}(standViewWindowRange{jittInd})-psDataSEM{jittInd}(standViewWindowRange{jittInd}))]; %+- SEM
            fill(joyShadeCoordsX, joyShadeCoordsY, [0,0,0]) %Error shading
                %Note: Scale and shading of photodiode signal is for display purposes only
            alpha(0.15)
            %}
            
            %xlim(targetFreq)
            %xlim([ viewWindow(1) ,viewWindow(2) ])
            xlim([ viewWindow(1) ,viewWindow(2) ])
            xlabel('Freq. (Hz)')
            ylabel('Baseline')
            title(['Channel ',num2str(chanToPlot), ' (',specIndex{specMethod},')'])
            
            jittStruct.data(chanInd).baseViewWindowRange = baseViewWindowRange;
            jittStruct.data(chanInd).joySpace = joySpace;
            jittStruct.data(chanInd).joyData = joyData;
        end

        %Photodiode
        subplot(size(chansOfInterestActive,2)+1,1,size(chansOfInterestActive,2)+1)

        %thisBaselinePhotData = SplicedStim(4,restRange); %Collect data
        %thisBaselinePhotData = SplicedPhot(1,restRange); %Collect data
        if applyAggressivePostSync == 0 
            thisBaselinePhotData = SplicedPhot(1,restRange);
        else
            if isnan( blockStruct(1).photPostSyncShift ) == 1 || blockStruct(1).photPostSyncShift == 0
                thisBaselinePhotData = SplicedPhot(1,restRange);
            else
                thisBaselinePhotData = SplicedPhot(1,restRange - blockStruct(1).photPostSyncShift);
            end
        end
        if specMethod == 1
            [spectruS2Phot, spectruF2Phot]=mtspectrumc(thisBaselinePhotData',params); %Uses same params from initial PSDs
        elseif specMethod == 3
            transpThisBaselinePhotData = transpose(thisBaselinePhotData);
            thisBaselinePhotDataFFT = fft(transpThisBaselinePhotData);
            %restDuration = size(restRange,2) / resampleFreq;
            spectruS2Phot = 2 * (1/resampleFreq)^2 / restDuration * thisBaselinePhotDataFFT.*conj(thisBaselinePhotDataFFT);
            freqRes = 1/max(restDuration);
            %nyqFreq = 1/(1/resampleFreq)/2;
            spectruF2Phot = (0:freqRes:nyqFreq);    
        end
        specSLogPhot = 10*log10(spectruS2Phot);

        joyDataPhot = spectruS2Phot(baseViewWindowRange,1); 
        %joyDataPhotLog = specSLogPhot(viewWindowRange,1); 
        joySpacePhot = linspace(spectruF2Phot(baseViewWindowRange(1)), spectruF2Phot(baseViewWindowRange(end)), size(joyDataPhot,1));
        plot(joySpacePhot, joyDataPhot, 'Color','r')
        %joyPlot(joyDataPhot, joySpacePhot, 12, 'Color','r')

        %xlim([ viewWindow(1) ,viewWindow(2) ])
        xlim([ viewWindow(1) ,viewWindow(2) ])
        xlabel('Freq. (Hz)')
        ylabel('Baseline')
        title(['Photodiode','(',specIndex{specMethod},')'])
        
        thisFigName = 'BaseRidge';
        set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName]);
        
        %###########
        %Save figure
        if saveFigs == 1
            try
                savePlot(saveName,thisFigName,figStr)
            catch 
                ['-# Alert: Failure to save plot #-']
            end
        end
        %###########
        
        %Add photodiode data to all channels of jittStruct
        %for chanInd = 1:size(jittStruct,2)
        jittStruct.base.joySpacePhot = joySpacePhot;
        jittStruct.base.joyDataPhot = joyDataPhot;
        %end

        %--------------------------------------------------------------------------------------------------------------------------------------------

        %More testatory
            %" Honestly at this point I don't know if it's correct to call perhaps the single most useful plot in this script 'testatory' "
        if useAutoList ~= 1 %Disable this plot during automated operation

            figure
            
            set(gcf, 'RendererMode', 'manual')
            set(gcf,'Renderer', 'opengl') %Attempting to make vector output work
            
            plot(allSignalData)
            hold on
            %Hardcoded channels to plot
            %plot(SplicedData(1,:)*1000,'k')
            %plot(SplicedData(12,:)*1000,'r')
            figStr = [];
            for chanInd = 1:size(chansOfInterestActive,2) %Plot requested channels
                chanToPlot = chansOfInterestActive(chanInd);
                %plot(SplicedData(1,:)*1000, 'Color', chanColours(chanInd,:))   %Channel 1 only 
                plot(SplicedData(chanToPlot,:)*1000, 'Color', chanColours(chanInd,:)) %All targeted channels
                figStr = [figStr,'C',num2str(chanToPlot), ' '];
            end

            %Plot timescale-modified data endpoint
            endPointPosixDur = (eegEndTimePosix - eegStartTimePosix) * resampleFreq;
            line([endPointPosixDur, endPointPosixDur],[-nanmax(allSignalData),nanmax(allSignalData)])
                    %Calculate timescale for conditions
            for i = 1:size(blockStruct,2)
                %Plot block start positions
                detStartTimeRelCoord = blockStruct(i).startTimeRel*resampleFreq;
                line([detStartTimeRelCoord,detStartTimeRelCoord],[-nanmax(allSignalData)*0.5,nanmax(allSignalData)], 'LineStyle', ':')
                text(detStartTimeRelCoord, (nanmax(allSignalData) + 0.05*nanmax(allSignalData)), [char(10), num2str(i)], 'Color', 'r')

                detSentTimeRelCoord = blockStruct(i).sentTimeRel*resampleFreq;
                line([detSentTimeRelCoord,detSentTimeRelCoord],[-nanmax(allSignalData)*0.5,nanmax(allSignalData)], 'LineStyle', '-')
                text(detSentTimeRelCoord, (nanmax(allSignalData) + 0.05*nanmax(allSignalData)), ['',blockStruct(i).sentCondition,' - ',blockStruct(i).sentColours], 'Color', 'r')

                %Plot synchronised TTL
                blockStartCoordAbs = blockStruct(i).startEnd(1);
                if blockStruct(i).sentConditionNum == 1
                    plot([ blockStartCoordAbs : blockStartCoordAbs+size(blockStruct(i).syncSentTTLResamp,2)-1 ] , blockStruct(i).syncSentTTLResamp(1,:)*4.5e5, 'm') %"carrieronly -> plot flat line"
                elseif blockStruct(i).sentConditionNum == 2
                    plot([ blockStartCoordAbs : blockStartCoordAbs+size(blockStruct(i).syncSentTTLResamp,2)-1 ] , blockStruct(i).syncSentTTLResamp(2,:)*4.5e5, 'm') %"oddball -> plot carrier w/ subtraction"
                    plot([ blockStartCoordAbs : blockStartCoordAbs+size(blockStruct(i).syncSentTTLResamp,2)-1 ] , blockStruct(i).syncSentTTLResamp(3,:)*4.85e5, 'g') %"oddball -> plot oddball"
                end

                %Plot artificial underlying sine
                %plot( [blockStruct(i).startEnd(1) : blockStruct(i).startEnd(1)+size(blockStruct(i).artUnderSignal,2)-1] , blockStruct(i).artUnderSignal*3e5 , 'Color', [0.27,0.5,0.63] )
                %Plot synchronised artificial underlying sine
                %%plot( [blockStruct(i).startEnd(1) : blockStruct(i).startEnd(1)+size(blockStruct(i).syncArtUnderSignal,2)-1] , blockStruct(i).syncArtUnderSignal*3e5 , 'Color', [0.27,0.5,0.63] )
                plot( [blockStruct(i).startEnd(1) : blockStruct(i).startEnd(1)+size(blockStruct(i).syncArtUnderSignal,2)-1] , blockStruct(i).syncArtUnderSignal*3e5 , 'Color', 'r' )

                %Scatter of cycle identities
                scatter( [blockStruct(i).artUnderPeaksCarrier+blockStartCoordAbs] , [repmat(4.5e5,1,size(blockStruct(i).artUnderPeaksCarrier,2))], [], 'b' ); %Carrier
                scatter( [blockStruct(i).artUnderPeaksOddball+blockStartCoordAbs] , [repmat(4.85e5,1,size(blockStruct(i).artUnderPeaksOddball,2))], [], 'g' ); %Oddball

                %Scatter of cycle colour
                %(Needs modification to work with this plot)
                %{
                for side = 25:26
                    for colourInd = 1:size(findColour,2)
                        matchingColourCyles = find(dataMat(side,:) == colourInd);
                        if colourInd == 1
                            scatter( matchingColourCyles , [repmat(5.25e5,1,size(matchingColourCyles,2))] , [] , 'g' , 'filled' ) %Green filled
                        elseif colourInd == 2
                            scatter( matchingColourCyles , [repmat(5.25e5,1,size(matchingColourCyles,2))] , [] , 'b' , 'filled' ) %Blue filled
                        elseif colourInd == 3
                            scatter( matchingColourCyles , [repmat(5.25e5,1,size(matchingColourCyles,2))] , [] , 'k' ) %Black hollow
                        end
                    end
                end
                %}

            end
            %Plot hyperData points
            for targInd = 1:size(groupHyper,2)
                if isempty(groupHyper(targInd).Lists) ~= 1
                    %groupColour scatter point
                    scatter( groupHyper(targInd).Lists(:,3) , [repmat(5.25e5,1,size(groupHyper(targInd).Lists(:,3),1))] , [] , groupColours(targInd,:) , 'filled' )
                    %Group identities above each point
                    for cycInd = 1:size(groupHyper(targInd).Lists,1)
                        text( groupHyper(targInd).Lists(cycInd,3) , 6.25e5 , ['G',num2str(targInd)] , 'Color', groupColours(targInd,:) )
                    end
                else
                    disp(['#- Could not plot Group ',num2str(targInd),' due to emptiness -#'])
                end
            end

            %plot((SplicedStim(4,:)*0.5)-6e5, 'Color', [1,0.5,0]) %Plot photodiode (in custom position and scale)
            plot((SplicedPhot(1,:)*0.5)-6e5, 'Color', [1,0.5,0]) %Plot photodiode (in custom position and scale)
            %xlim([2.7532e5, 2.8883e5])
            %xlim([5.8740e5, 5.9043e5])
            %xlim([blockStruct(15).startEnd(1),blockStruct(15).startEnd(2)]) %Will crash if data has less than 15 blocks I suppose
            %xlim([5.4756*10e4  5.4894*10e4]) %Will crash if data has less than 15 blocks I suppose
            try
                xlim([blockStruct(57).startEnd(1),blockStruct(57).startEnd(2)])
            catch
                ['#- Failure to enact custom X limits on testatory plot -#']
            end
            %ylim([-1.1938e6, 1.8183e6])
            title(['LFP data (various colours), Original stim vector (blue), Artificial sine (red), Photodiode (orange)'])
            thisFigName = 'Testatory';
            set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName]);

            %###########
            %Save figure
            if saveFigs == 1
                try
                    savePlot(saveName,thisFigName,figStr)
                catch
                    ['-# Failure to save plot #-']
                end
            end
            %###########

        end

        %--------------------------------------------------------------------------------------------------------------------------------------------


        %nasa


        %---------------------------
        if doMat == 1
            disp(['-- Assembling data matrix --'])

            %Make Bruno-friendly matrix (finally)
            dataMat = nan(16+14,size(SplicedData,2)); %Pre-allocate
            %Rows 1:16 - Real data, channel 1 to 16
            %Row 17 - Left NaN intentionally
            %Row 18 - Photodiode virtual channel
            %Row 19 - Left NaN intentionally
            %Row 20 - Carrier point-ons (0 everywhere except for exact peak of carrier cycles)
            %Row 21 - Oddball point-ons (0 everywhere except for exact peak of oddball cycles)
            %Row 22 - Carrier TTL signal (0 whenever carrier cycles were not occurring, 1 when carrier cycles were occurring)
            %Row 23 - Oddball TTL (0 whenever oddball cycles weren't occurring, 1 when oddball cycles were occurring)
            %Row 24 - Left NaN intentionally
            %Row 25 - Carrier cycle colours (Aligns with row 20 'carrier point-ons'; 1 indicates this carrier cycle was green, 2 -> blue, 3 -> blank (only possible during 'Missing Carrier' experiments))
            %Row 26 - Oddball cycle colours (Ditto row 25, but for oddball cycles (For this row, green is in fact the least likely colour))
            %Row 27 - Left NaN intentionally
            %Row 28 - Carrier cycle jittering state (Similar to row 25, except that the value for each cycle here indicates whether the oddball was jittering; -1 indicates a carrier cycle in a carrieronly block, 
            %0 indicates a carrier cycle in a non-jittering oddball block, 1 indicates a carrier cycle in a jittering block)
            %Row 29 - Oddball cycle jittering state (Ditto row 28, except for oddball cycles; 0 indicates this oddball was not jittering, 1 indicates it was jittering (and -1 should never happen))
            %Row 30 - Left NaN intentionally

            %QA before proceeding
            if size(SplicedData,2) ~= size(SplicedStim,2)
                if abs(size(SplicedData,2) - size(SplicedStim,2)) < (1.0/f1) * resampleFreq * 0.1 %If difference between sizes more than 1/10th of a cycle
                    ['# Warning: Asynchrony of ',num2str( round(abs(size(SplicedData,2) - size(SplicedStim,2)) / resampleFreq,3) ),'s present between real and virtual channels #']
                else
                    ['# Alert: Cannot make data matrix with significant asynchrony present between real and virtual data #']
                    if overrideErrors ~= 1
                        crash = yes
                    elseif overrideErrors == 1 & saveMat == 1
                        saveMat = 0; %Override
                        disp(['# Overriding saveMat (New value: ',num2str(saveMat),') in light of warning #'])
                    end
                end
            end

            %Send real data to matrix
            dataMat(1:size(SplicedData,1),:) = SplicedData;

            %Add in photodiode data
            %dataMat(18,1:size(SplicedStim,2)) = SplicedStim(4,:);
            dataMat(18,1:size(SplicedStim,2)) = SplicedPhot(1,:);

            %Iterate through blockStruct to add various other metrics
            for i = 1:size(blockStruct,2)
                blockStartCoordAbs = blockStruct(i).startEnd(1);

                thisBlockCarrPointOns = blockStruct(i).artUnderPeaksCarrier + blockStartCoordAbs; %Carrier cycle point ons (1 at peak of underlying sine for sine data)
                thisBlockOddPointOns = blockStruct(i).artUnderPeaksOddball + blockStartCoordAbs; %Oddball cycle point ons
                if blockStruct(i).sentConditionNum == 1 %Alter TTL collection depending on whether carrieronly or carrier/oddball
                    thisBlockCarrTTL = blockStruct(i).syncSentTTLResamp(1,:); %Carrieronly TTL
                    thisBlockOddTTL = zeros( 1, size(blockStruct(i).syncSentTTLResamp(3,:),2));
                elseif blockStruct(i).sentConditionNum == 2
                    thisBlockCarrTTL = blockStruct(i).syncSentTTLResamp(2,:); %Carrier TTL (Note: Will need to have coordinates adjusted when applying to matrix)
                    thisBlockOddTTL = blockStruct(i).syncSentTTLResamp(3,:); %Oddball TTL (Will be low during carrieronly blocks)
                end
                    %Note: This is necessary because rows 2 and 3 in the TTL signal for carrieronly blocks are actually from the previous oddball block, or some similar fuckery


                dataMat(20,thisBlockCarrPointOns) = 1;
                dataMat(21,thisBlockOddPointOns) = 1;

                dataMat(22, blockStartCoordAbs:blockStartCoordAbs+size(thisBlockCarrTTL,2)-1 ) = thisBlockCarrTTL;
                dataMat(23, blockStartCoordAbs:blockStartCoordAbs+size(thisBlockOddTTL,2)-1 ) = thisBlockOddTTL;

                %Append colour information
                findColour{1} = strfind(blockStruct(i).sentColours, 'green');
                findColour{2} = strfind(blockStruct(i).sentColours, 'blue');
                findColour{3} = strfind(blockStruct(i).sentColours, 'blank');
                for colourInd = 1:size(findColour,2)
                    if isempty(findColour{colourInd}) ~= 1
                        if findColour{colourInd} == 1 %"Colour was in first/Only position; Write in carrier cycles as colour"
                            dataMat(25,thisBlockCarrPointOns) = colourInd;
                        else %"Colour was NOT in first/Only position; Write in oddball cycles as colour"
                            dataMat(26,thisBlockOddPointOns) = colourInd;
                            %QA to make sure oddball cycles are actually existing
                            if isempty(thisBlockOddPointOns) == 1 && blockStruct(i).jittering ~= 4 %"If no oddballs occurred AND was not a 100Hz sparsening experiment"
                                ['## Alert: Attempted to assign oddball colours where oddball cycles are not existing ##'] 
                                error = yes %Note: May happen if was oddball trial but circumstances meant no oddballs delivered
                            end
                        end                    
                    end
                end

                %Append jitter information
                dataMat(28,thisBlockCarrPointOns) = blockStruct(i).jittering; %Append jittering status to carrier point ons in either case
                if blockStruct(i).jittering == 1 ||  blockStruct(i).jittering == 0 %Oddball
                    dataMat(29,thisBlockOddPointOns) = blockStruct(i).jittering; %Only append jittering status to oddball if existing
                end

            end

            %Zeroify applicable channels
            fullNanList = isnan(dataMat) == 1;
            dataMat(20, fullNanList(20,:) == 1) = 0; %Carrier point-ons
            dataMat(21, fullNanList(21,:) == 1) = 0; %Oddball point ons
            dataMat(22, fullNanList(22,:) == 1) = 0; %Carrier TTL
            dataMat(23, fullNanList(23,:) == 1) = 0;%Oddball TTL

            dataMat(25, fullNanList(25,:) == 1) = 0; %Carrier colour
            dataMat(26, fullNanList(26,:) == 1) = 0; %Oddball colour

            dataMat(28, fullNanList(28,:) == 1) = 0; %Carrier jittering state
            dataMat(29, fullNanList(29,:) == 1) = 0; %Oddball jittering state


            %Testatory plot to confirm correctness
            if useAutoList ~= 1
                figure

                plot(dataMat(1,:)*1000,'b') %Channel 1
                hold on

                plot((dataMat(18,:)*0.5)-6e5, 'Color', [1,0.5,0]) %Photodiode

                plot( dataMat(22,:)*4.5e5, 'm') %Carrier TTL
                plot( dataMat(23,:)*4.75e5, 'c') %Oddball TTL

                plot( dataMat(25,:)*4.5e5, ':', 'Color', 'm') %Carrier point ons
                plot( dataMat(26,:)*1.75e5, ':', 'Color', 'c') %Oddball point ons

                for side = 25:26
                    for colourInd = 1:3%size(findColour,2)
                        matchingColourCyles = find(dataMat(side,:) == colourInd);
                        if colourInd == 1
                            scatter( matchingColourCyles , [repmat(5.25e5,1,size(matchingColourCyles,2))] , [] , 'g' , 'filled' ) %Green filled
                        elseif colourInd == 2
                            scatter( matchingColourCyles , [repmat(5.25e5,1,size(matchingColourCyles,2))] , [] , 'b' , 'filled' ) %Blue filled
                        elseif colourInd == 3
                            scatter( matchingColourCyles , [repmat(5.25e5,1,size(matchingColourCyles,2))] , [] , 'k' ) %Black hollow
                        end
                    end
                end
                %xlim([1.6720e5, 1.7096e5])
                xlim([2.1280e5 , 2.2188e5])
            end
            set(gcf,'Name',flies(IIDN).name);

            %Save matrix
            if saveMat == 1
                disp(['-- Saving data matrix --'])
                %saveName = strcat(matSavePath,'\',saveStructFiles(1).name(1:end-4),'_dataMat.mat');
                %saveName = strrep(saveName, '_saveStruct_', '_');
                thisMatSaveName = strcat([matSaveName, '_dataMat.mat']);
                save(thisMatSaveName, 'dataMat')
                ancSaveName = strrep(thisMatSaveName, '.mat', '_anc.mat');
                save(ancSaveName,'flagParamSaveStruct') %"More like...Ang-c"
                disp(['-- Data matrix (and anc) saved --'])
            end

            disp(['-- Data matrix assembled --'])
        end

        %ether

        %----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

        if doPerm == 1
            %Permutation stats
            %ftPath = 'D:\group_swinderen\Matthew\Scripts\toolboxes\fieldtrip-20151223'; %Now defined up top
            addpath(genpath(ftPath))
            
            %If enforcing size parity, do pre-calculations
            if arbitraryPermSizeParity == 1
                %First, check to see if any perm elements appear more than once
                permUns = unique( permCompGroups );
                if size(permUns,1) < numel( permCompGroups )
                    disp(['-# Caution: Some hyperGroups requested for perm comparison more than once; Arbitrary size will be minima of all partners #-'])
                        %This is not a critical problem, but arbitrary size parity will have to take it into account
                end
                
                %Determine how many blocks of data exist for every hyperGroup, as prelude to minima calculations
                    %(Using "Blocks as subjects")
                hyperSubjects = [];
                for groupInd = 1:size(groupHyper,2)
                    if groupHyper(groupInd).As > 0
                        hyperSubjects(groupInd) = size( unique( groupHyper(groupInd).Lists(:,1) ),1 );
                    else
                        hyperSubjects(groupInd) = 0; %hyperGroup empty
                    end
                end
                
                %Calculate minimum parity N between comp groups
                minParN = []; %Minimum number of groups, arranged same as permCompGroups
                for permInd = 1:size(permCompGroups,1)
                    minParN(permInd, [1,2]) = repmat( nanmin( [hyperSubjects( permCompGroups(permInd,1) ) , hyperSubjects( permCompGroups(permInd,2) )] ), 1 , 2 );
                    %QA
                    if nansum( minParN(permInd, [1,2]) == 0 ) >= 1
                        minParN(permInd, [1,2]) = [NaN,NaN];
                        disp(['-# Caution: Perm comp. ',num2str(permInd),' has one or more empty groups #-'])
                    end
                end
            end

            preCfg = [];
            preCfg.keeptrials = 'yes';

            %Calculate time statistics for individual channel/s and groups 
            %chanToPlot = 16;
            %chanToPlot = chansOfInterest(1);
            %chanToPlotStr = ['Channel ',num2str(chanToPlot)];

            overPerm = struct;
            failedGroups = [];
            for groupInd = 1:size(groupHyper,2)
                permStruct = struct;
                
                for chanInd = 1:size(chansOfInterestActive,2)
                    chanToPlot = chansOfInterestActive(chanInd);
                    chanToPlotStr = ['Channel ',num2str(chanToPlot)];
                
                    dataArray = [];
                    if isempty(groupHyper(groupInd).Lists) ~= 1
                        %"Cycles as subjects"
                        %{
                        for s = 1:size(groupHyper(groupInd).DatasCorr,3) %Originally iterated through 'subject' but this is now individual cycles
                            dataArray{s} = groupHyper(groupInd).DatasCorr(chanToPlot,:,s);
                        end
                        timeSeconds = {1/resampleFreq:1/resampleFreq:size(dataArray{1},2)/resampleFreq}; %Use 1st as exemplar for size
                        %}
                        %"Blocks as subjects"

                        thisGroupBlockList = unique( groupHyper(groupInd).Lists(:,1) ); %Finds what blocks were associated with this group
                            %Note: This method may result in averages from wildly varying numbers of cycles per block, depending on the paradigm
                            
                        if arbitraryPermSizeParity == 1 && isempty( find(permCompGroups == groupInd) ) ~= 1
                            prosActiveParityN = minParN(  find(permCompGroups == groupInd) ); %Pull from minParN each instance of a requested permutation comparison
                                %This uses the indices from permCompGroups and the doubled-up nature of minParN to find the minimum parity Ns for each comp that this hyperGroup is part of
                            activeParityN = nanmin( prosActiveParityN ); %Find the minimum of the minima
                            parityBlocks = thisGroupBlockList( floor( linspace(1, size(thisGroupBlockList,1) , activeParityN) ) ); %Will probably crash if parity misordered or something
                                %Sub-select from thisGroupBlockList based on activeParityN
                                    %i.e. If thisGroupBlockList is size 200 and activeParityN is 100, select 100 blocks (evenly spaced) and go with those
                            %Reporter
                            if chanInd == 1 %Only report on first
                                disp([ '-- hyperGroup #', num2str(groupInd),' adjusted to parity from ', num2str(size(thisGroupBlockList,1)), ' to ',num2str( size(parityBlocks,1) ),' blocks --' ])
                            end
                            thisGroupBlockList = parityBlocks;
                            
                            if size(parityBlocks,1) == 0
                                disp(['(Comparison will not be performed)'])
                                failedGroups = [failedGroups,groupInd];
                                timeSeconds = [];
                                continue
                            end
                        end
                        
                            
                        for s = 1:size(thisGroupBlockList,1)
                            thisBlockNum = thisGroupBlockList(s); %Block in question
                            thisGroupBlockCoords = find( groupHyper(groupInd).Lists(:,1) == thisBlockNum ); %Index within hyperGroups
                            dataArray{s} = nanmean( groupHyper(groupInd).DatasCorr(chanToPlot,:, thisGroupBlockCoords ) ,3); %Only pulls specified cycles (of specified channel)
                            %Normalise, if requested
                            if normaliseERPs == 1
                                dataArray{s} = dataArray{s} / overOnsetAmpMeans{chanToPlot}; %Normalise by mean of every detected peak
                            elseif normaliseERPs == 2
                                dataArray{s} = dataArray{s} / nanmax(dataArray{s}); %Warning: Possibility that this will produce a vector, not a single value
                            elseif normaliseERPs == 3
                                %dataArray{s} = dataArray{s} / overColourMaxMeans{ groupHyper(groupInd).cycleColoursNum }(chanToPlot); %Normalise by mean of peaks of this colour (May crash if called when colours weren't specified)     
                                dataArray{s} = dataArray{s} / abs( overColourMaxMeans{ groupHyper(groupInd).cycleColoursNum }(chanToPlot) ); %9.35 move to abs
                            end
                        end
                        timeSeconds = {1/resampleFreq:1/resampleFreq:size(dataArray{1},2)/resampleFreq}; %Use 1st as exemplar for size
                    else
                        %disp(['# hyperGroup ',num2str(groupInd),' - "',groupDescriptors{groupInd},'" could not be permutation analysed #'])
                        failedGroups = [failedGroups,groupInd];
                        timeSeconds = [];
                    end
                    
                    %{
                    %Pre-channel generalisation
                    permStruct.trial = dataArray;
                    permStruct.label = {chanToPlotStr}; %In original code this was three-rowed, to account for the channel positions, but currently this is one at a time
                    permStruct.fsample = resampleFreq;
                    permStruct.time = repmat(timeSeconds,[1 size(dataArray,2)]);
                    if isempty(groupHyper(groupInd).Lists) ~= 1
                        permStruct.output = ft_timelockanalysis(preCfg, permStruct);
                    else
                        permStruct.output = [];
                    end
                    permStruct.Descriptor = groupDescriptors{groupInd};
                    %}
                    
                    %output = [];
                    permStruct(chanInd).trial = dataArray;
                    permStruct(chanInd).label = {chanToPlotStr}; %In original code this was three-rowed, to account for the channel positions, but currently this is one at a time
                    permStruct(chanInd).fsample = resampleFreq;
                    permStruct(chanInd).time = repmat(timeSeconds,[1 size(dataArray,2)]);
                    if isempty(groupHyper(groupInd).Lists) ~= 1
                        %output = ft_timelockanalysis(preCfg, permStruct);
                        permStruct(chanInd).output = ft_timelockanalysis(preCfg, permStruct(chanInd));
                    else
                        permStruct(chanInd).output = [];
                    end
                    permStruct(chanInd).Descriptor = groupDescriptors{groupInd};
                    permStruct(chanInd).Channel = chanToPlot;
                end

                overPerm(groupInd).permStruct = permStruct; %Save data for overuse
            end

            %Post-hoc reporting of any failures
            if size(failedGroups,2) > 0
                disp(['# hyperGroup/s ',num2str(failedGroups),' could not be permutation analysed #'])
            end


            %%permCompGroups = [1,2 ; 3,4 ; 1,3 ; 2,4]; %Similar to mmnGroups; Defines what hyperGroups to compare with permutation analysis

            %Calculate permutations between groups
            disp([char(10),'-- Calculating permutation statistics between ',num2str(size(permCompGroups,1)),' combinations of groups --',char(10)])
            %Invariant
            cfg                  = [];
            cfg.method           = 'montecarlo'; % use the Monte Carlo Method to calculate the significance probability
            cfg.latency          = 'all';
            cfg.statistic        = 'indepsamplesT'; % use the independent samples T-statistic as a measure to evaluate the effect at the sample level
            %%cfg.statistic        = 'ft_statfun_depsamplesT';
            cfg.correctm         = 'cluster';
            %%cfg.correctm         = 'bonferroni';
            cfg.neighbours       = []; %Empty, to force usage of temporal clusters
            cfg.clusteralpha     = 0.05;       % alpha level of the sample-specific test statistic that will be used for thresholding
            cfg.clusterstatistic = 'maxsum';   % test statistic that will be evaluated under the permutation distribution.
            %%cfg.minnbchan        = 0;          % minimum number of neighborhood channels that is required for a selected sample to be included in the clustering algorithm (default=0).
            % cfg.neighbours     = neighbours; % see below
            cfg.tail             = 0;          % -1, 1 or 0 (default = 0); one-sided or two-sided test
            %%cfg.clustertail      = 0;
            cfg.alpha            = permAlpha;      % alpha level of the permutation test
            cfg.numrandomization = 1000;        % number of draws from the permutation distribution (Note: value of 1000 is arbitrary currently)
            cfg.correcttail      = 'prob';

            statStruct = struct;
            for permInd = 1:size(permCompGroups,1)
                
                cfg.design = [];
                groupOne = permCompGroups(permInd,1);
                groupTwo = permCompGroups(permInd,2);
                
                statStruct(permInd).compGroups = [groupOne , groupTwo];
                statStruct(permInd).compGroupsDesc = [{groupDescriptors{groupOne}} , {groupDescriptors{groupTwo}} ];

                for chanInd = 1:size(chansOfInterestActive,2)
                    chanToPlot = chansOfInterestActive(chanInd);
                    %Variant
                    %n_fc  = size(overPerm(groupOne).permStruct.trial,2);
                    %n_fic = size(overPerm(groupTwo).permStruct.trial,2);
                    if isfield( overPerm(groupOne).permStruct, 'trial' ) == 1 && isfield( overPerm(groupTwo).permStruct, 'trial' ) == 1
                        n_fc  = size(overPerm(groupOne).permStruct(chanInd).trial,2);
                        n_fic = size(overPerm(groupTwo).permStruct(chanInd).trial,2);
                    else
                        n_fc  = 0;
                        n_fic = 0;
                    end
                    if n_fc ~= 0 && n_fic ~= 0
                        cfg.design = [ones(1,n_fic), ones(1,n_fc)*2];

                        %[stat] = ft_timelockstatistics(cfg, overPerm(groupOne).permStruct.output, overPerm(groupTwo).permStruct.output);
                        [stat] = ft_timelockstatistics(cfg, overPerm(groupOne).permStruct(chanInd).output, overPerm(groupTwo).permStruct(chanInd).output); %Now with channels

                        %statStruct(permInd).compGroups = [groupOne , groupTwo];
                        %statStruct(permInd).compGroupsDesc = [{groupDescriptors{groupOne}} , {groupDescriptors{groupTwo}} ];
                        statStruct(permInd).stat{chanInd} = stat; %Switch this to curly braces (for cellification) if fails cos dissimilar presence of clusters
                        disp(['- Perm ',num2str(permInd),' - ',groupDescriptors{groupOne},' (J:',num2str(groupJitters(groupOne)),') vs ',groupDescriptors{groupTwo}, ' (J:',num2str(groupJitters(groupOne)),') calculated (Ch ',num2str(chanToPlot),') -', char(10)])
                    else
                        stat = [];
                        %statStruct(permInd).compGroups = [groupOne , groupTwo];
                        %statStruct(permInd).compGroupsDesc = [{groupDescriptors{groupOne}} , {groupDescriptors{groupTwo}} ];
                        statStruct(permInd).stat(chanInd) = struct;
                        %statStruct(permInd).stat(chanInd) = NaN;
                        disp(['## Perm ',num2str(permInd),' - ',groupDescriptors{groupOne},' (J:',num2str(groupJitters(groupOne)),', n=',num2str(n_fc),') vs ',groupDescriptors{groupTwo}, ' (J:',num2str(groupJitters(groupOne)),', n=',num2str(n_fic),') could NOT be calculated (Ch ',num2str(chanToPlot),')##', char(10)])
                    end
                end
                
            end

            %Plot data and signific.
            for chanInd = 1:size(chansOfInterestActive,2)
                chanToPlot = chansOfInterestActive(chanInd);
                figure

                figStr = [];
                gcaList = []; %Will hold the figs for YLim purposes
                for permInd = 1:size(permCompGroups,1)
                    if size(permCompGroups,1) < 4
                        subplot(1,size(permCompGroups,1),permInd) %1 row, <number of comparison groups> columns
                    else
                        subplot(ceil( size(permCompGroups,1)/4 ) , 4 , permInd) %Variable number of rows, 4 columns
                        %subplot(ceil( size(permCompGroups,1)/3 ) , 3 , permInd) %Variable number of rows, 3 columns
                    end

                    %Source data
                    for i = 1:size(permCompGroups,2)
                        thisPermCompGroup = permCompGroups(permInd,i);
                        for s = 1:size(overPerm(thisPermCompGroup).permStruct(chanInd).trial,2) %size(overPerm(thisPermCompGroup).permStruct.trial,2)
                            if isempty(overPerm(thisPermCompGroup).permStruct(chanInd).trial) ~= 1 %isempty(overPerm(thisPermCompGroup).permStruct.trial) ~= 1
                                %plot( overPerm(thisPermCompGroup).permStruct.trial{s}, 'Color', groupColours(thisPermCompGroup,:) ) %Note: Will probably fail if not cell
                                plot( overPerm(thisPermCompGroup).permStruct(chanInd).trial{s}, 'Color', groupColours(thisPermCompGroup,:) ) %Note: Will probably fail if not cell
                                %xlim([0 , size(overPerm(thisPermCompGroup).permStruct.trial{s},2)]) %Moved here to avoid reliance on sigPlotImage
                                xlim([0 , size(overPerm(thisPermCompGroup).permStruct(chanInd).trial{s},2)]) %Moved here to avoid reliance on sigPlotImage
                            end
                            hold on
                        end
                    end

                    titleStr = [];
                    %Sig
                    %if isempty(statStruct(permInd).stat{chanInd}) ~= 1
                    if isstruct(statStruct(permInd).stat(chanInd)) ~= 1 %Modified to support empty structs for empty datasets
                        %p_binary = double(statStruct(permInd).stat.prob(chanToPlot,:) > statStruct(permInd).stat.cfg.alpha);
                        p_binary = double(statStruct(permInd).stat{chanInd}.prob > statStruct(permInd).stat{chanInd}.cfg.alpha); %Removed probably erroneous chanToPlot specification
                        p_binary = p_binary*255; %Manual scaling to ensure correct orientation
                        currYLims = get(gca,'YLim');
                        imHeight = ceil(abs(currYLims(1)-currYLims(2))*0.1);
                        sigPlotImage = repmat(p_binary,imHeight,1);
                        hImage = image(sigPlotImage , 'XData', [0 , size(sigPlotImage,2)] , 'YData', ...
                            [nanmax(get(gca,'YLim')) + imHeight*0.25 , nanmax(get(gca,'YLim')) + imHeight*0.25] ); 
                        colormap gray;
                        set(hImage,'AlphaData', 0.25)
                        %{
                        titleStr = ...
                        [ groupDescriptors{permCompGroups(permInd,1)},' (J:', num2str(groupJitters(permCompGroups(permInd,1))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,1)).permStruct.trial,2)),')', char(10), ...
                        ' vs ', char(10), ...
                        groupDescriptors{permCompGroups(permInd,2)},' (J:', num2str(groupJitters(permCompGroups(permInd,2))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,2)).permStruct.trial,2)),')', char(10), ...
                        '[p < ', num2str(statStruct(permInd).stat.cfg.alpha),']'];
                        %}
                        titleStr = ...
                        [ groupDescriptors{permCompGroups(permInd,1)},' (J:', num2str(groupJitters(permCompGroups(permInd,1))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,1)).permStruct(chanInd).trial,2)),')', char(10), ...
                        ' vs ', char(10), ...
                        groupDescriptors{permCompGroups(permInd,2)},' (J:', num2str(groupJitters(permCompGroups(permInd,2))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,2)).permStruct(chanInd).trial,2)),')', char(10), ...
                        '[p < ', num2str(statStruct(permInd).stat{chanInd}.cfg.alpha),']'];
                    else
                        %{
                        titleStr = ...
                        [ groupDescriptors{permCompGroups(permInd,1)},' (J:', num2str(groupJitters(permCompGroups(permInd,1))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,1)).permStruct.trial,2)),')', char(10), ...
                        ' vs ', char(10), ...
                        groupDescriptors{permCompGroups(permInd,2)},' (J:', num2str(groupJitters(permCompGroups(permInd,2))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,2)).permStruct.trial,2)),')', char(10), ...
                        '[Insufficient data]' ];
                        %}
                        titleStr = ...
                        [ groupDescriptors{permCompGroups(permInd,1)},' (J:', num2str(groupJitters(permCompGroups(permInd,1))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,1)).permStruct(chanInd).trial,2)),')', char(10), ...
                        ' vs ', char(10), ...
                        groupDescriptors{permCompGroups(permInd,2)},' (J:', num2str(groupJitters(permCompGroups(permInd,2))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,2)).permStruct(chanInd).trial,2)),')', char(10), ...
                        '[Insufficient data]' ];
                    end
                    if normaliseERPs ~= 0
                        titleStr = [titleStr, char(10), normaliseIndex{normaliseERPs}];
                    else
                        titleStr = [titleStr, char(10), '(Not normalised)'];
                    end
                    if doSubSampling == 1
                        titleStr = [titleStr,char(10),'(Data subsampled to n=',subTargetSize,')'];
                    end
                    if arbitraryPermSizeParity == 1
                        titleStr = [titleStr,char(10),'Arbitrary N parity enforced'];
                    end
                    title(titleStr)

                    %Lims and things
                    %xlim([0 , size(sigPlotImage,2)])
                    %title([ groupDescriptors{permCompGroups(permInd,1)},' (J:', num2str(groupJitters(permCompGroups(permInd,1))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,1)).permStruct.trial,2)),')', char(10), ...
                    %    ' vs ', char(10), ...
                    %    groupDescriptors{permCompGroups(permInd,2)},' (J:', num2str(groupJitters(permCompGroups(permInd,2))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,2)).permStruct.trial,2)),')', char(10), ...
                    %    '[p < ', num2str(statStruct(permInd).stat.cfg.alpha),']' ])
                    %line([ captureWindowSize*(-captureWindowGeometry(1)),captureWindowSize*(-captureWindowGeometry(1)) ],[-300,300], 'LineStyle', ':', 'Color', 'k') %Stimulus onset (more or less)
                    %{
                    if isempty(fixedPhotodiodeScale) ~= 1
                        line([ captureWindowSize*(-captureWindowGeometry(1)),captureWindowSize*(-captureWindowGeometry(1)) ],[-fixedPhotodiodeScale,fixedPhotodiodeScale], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
                    else
                        line([ captureWindowSize*(-captureWindowGeometry(1)),captureWindowSize*(-captureWindowGeometry(1)) ],[-300,300], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
                    end
                    %}
                    line([ captureWindowSize*(-captureWindowGeometryActive(1)),captureWindowSize*(-captureWindowGeometryActive(1)) ],[nanmin(get(gca,'YLim')) , nanmax(get(gca,'YLim'))], 'LineStyle', ':', 'Color', 'k')

                    gcaList(permInd) = gca;
                    figStr = [figStr, 'G',num2str(permCompGroups(permInd,1)),'vsG',num2str(permCompGroups(permInd,2)),'--'];
                end
                figStr = [figStr, 'C', num2str(chanToPlot), ' ', num2str( size(permCompGroups,1) ), ' comparisons'];
                %Pull max lims
                %try
                if size(permCompGroups,1) > 1
                    yl = cell2mat(get(gcaList, 'Ylim'));
                    ylnew = [min(yl(:,1)) max(yl(:,2))];
                    set(gcaList, 'YLim', ylnew)
                else
                    ylim('auto')
                end
                %catch
                %    ['## Unspecified error while attempting to apply uniform Y-limit to permutation statistics plot ##']
                %end
                thisFigName = ['PermComps - Ch ',num2str(chanToPlot)];
                set(gcf,'Name',[flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum), ' - ', thisFigName]);

                %###########
                %Save figure
                if saveFigs == 1
                    try
                        savePlot(saveName,thisFigName,figStr)
                    catch 
                        ['-# Alert: Failure to save plot #-']
                    end
                end
                %###########
            end
                        
            rmpath(genpath(ftPath)) 

        else
            disp(['#- Not calculating permutation statistics by request -#'])
        end

        %----------------------------------------------------------------

        %necrodancer
        
        %Special spectral plots
        if doSpectralPlots == 1
            for spec = 1:size(spectralGroups,2)
                thisSpec = spectralGroups(spec);
                if thisSpec <= size(groupHyper,2) %Note: This is not a check for existence RE: Groups that might have been removed for various reasons
                    
                    %Ligate all data of this specific hyperGroup
                    allSpecData = [];
                    hyperWindowSize = size(groupHyper(thisSpec).DatasCorr,2);
                    allSpecData = nan( 1 , hyperWindowSize*groupHyper(thisSpec).As );
                    
                    for ev = 1:groupHyper(thisSpec).As
                        thisCoords = [ev*hyperWindowSize - hyperWindowSize + 1 : ev*hyperWindowSize]; %No check for overlength
                        allSpecData(1 , thisCoords ) = groupHyper(thisSpec).DatasCorr(1,:,ev);
                    end
                    allSpecData( isnan(allSpecData) == 1 ) = nanmedian(allSpecData);
                    
                    figure
                    %thisData = groupHyper(thisSpec).DatasCorr(1,:,1);
                    %spectrogram(probData,winSize,winOverlap,probF,Fs,'yaxis');
                    %spectrogram(thisData,winSize*resampleFreq,winOverlap*resampleFreq,probF,resampleFreq,'yaxis');
                    spectrogram(allSpecData,5*resampleFreq,[],[0.1:1:41],resampleFreq,'yaxis');
                    title(['Special spectral plot - ',groupDescriptors{thisSpec}])
                else
                    ['-# Warning: Requested spectral plot group ',num2str(thisSpec),' does not exist in groupHyper']                        
                end
            end
            
            %Sleep and wake
            stateIndex = [{'wake'},{'sleep'}];
            
            for state = 0:1
                figure
                temp = SplicedData( 1 , behavInterp(:,1) == state );
                spectrogram(temp,5*resampleFreq,[],[0.1:1:41],resampleFreq,'yaxis');
                title(['Special spectral plot - All ',stateIndex{state+1}])
            end
            
            %Binned sleep and wake
            specialEval = [{'behavInterp(:,1) == 1 & behavInterp(:,9) <= 300'},{'behavInterp(:,1) == 1 & behavInterp(:,9) > 300 & behavInterp(:,9) <= 600'},{'behavInterp(:,1) == 0 & behavInterp(:,10) > -300'}];
            specialDescriptors = [{'During first 5 mins of sleep'},{'During minutes 5 to 10 of sleep'},{'Last 5 mins of wake'}];
            
            %Ligated
            for spec = 1:size(specialEval,2)
                temp = [];
                eval(['temp = SplicedData(1,',specialEval{spec},');'])
                figure
                spectrogram(temp,5*resampleFreq,[],[0.1:1:41],resampleFreq,'yaxis');
                title([specialDescriptors{spec}])
            end
            
            %Separated
            specBoutFreqAmps = [];
            for spec = 1:size(specialEval,2)
                temp = [];
                eval(['temp = behavInterp(',specialEval{spec},', [9,11]);']) %USe special evals to pull behavInterp bout duration data (and LFP-matched indices)
                tempOnsets = find(diff(temp(:,1)) < 0); %Find points of negative inflection to identify bout boundaries
                tempOnsetsActive = [1;tempOnsets;size(temp,1)]; %Same as tempOnsets, but with 1 and the end added, to simplify loops
                boutData = [];
                for bout = 2:size(tempOnsetsActive,1)
                    boutData{bout-1} = SplicedData(1, tempOnsetsActive(bout-1) : tempOnsetsActive(bout) );
                end
                specBoutFreqAmps{spec} = []; %Prepare
                figure
                for bout = 1:size(boutData,2)
                    specBoutFreqAmps{spec}(bout,1:2) = [NaN,NaN]; %Initialise
                    subplot( ceil(size(boutData,2)/4),4, bout )

                    try
                        if plotMode == 1
                            %Spectrogram
                            spectrogram(boutData{bout},5*resampleFreq,[],[0.1:1:41],resampleFreq,'yaxis');
                        else
                            %Matt/yna FFT
                            %{
                            boutDataFFT = fft(boutData{bout}); %FFT

                            boutS2 = 2 * (1/resampleFreq)^2 / (size(boutData{bout},2)/resampleFreq ) * boutDataFFT.*conj(boutDataFFT);
                            boutS2 = boutS2(1,1:length(boutData{bout})/2+1); %Hardcoded 1 row
                            freqRes = 1/max(size(boutData{bout},2)/resampleFreq );
                            nyqFreq = 1/(1/resampleFreq)/2;
                            boutF2 = (0:freqRes:nyqFreq); %Note: Different in size to spectruF2 produced by mtspectrumc
                            %}

                            %Bruno FFT
                            %y = fft(processData,floor(dataFS{evInd}*10));
                            y = fft(boutData{bout},floor(resampleFreq*brunoExpansionFactor));
                            z = y.*conj(y);
                            plotX = [1:size(z,2)];
                            plotY = z;
                            %plotColour = colourList{evInd};

                            %stimFreqFFTAmps = [abs(y(floor(f1*10))),abs(y(floor(f2*10)))];
                            freqCoords = [ round(f1*10-leakSize*brunoExpansionFactor) : round(f1*10+leakSize*brunoExpansionFactor) ;...
                                round(f2*10-leakSize*brunoExpansionFactor) : round(f2*10+leakSize*brunoExpansionFactor)];
                            %stimFreqFFTAmps = [ nanmax(abs( y( freqCoords(1,:) ) )) , nanmax(abs( y( freqCoords(2,:) ) )) ];
                            [stimFreqFFTAmps(1),stimFreqFFTLOCS(1)] = nanmax(abs( plotY( freqCoords(1,:) ) ));
                            stimFreqFFTLOCS(1) = freqCoords(1,stimFreqFFTLOCS(1));
                            [stimFreqFFTAmps(2),stimFreqFFTLOCS(2)] = nanmax(abs( plotY( freqCoords(2,:) ) ));
                            stimFreqFFTLOCS(2) = freqCoords(2,stimFreqFFTLOCS(2));
                            specBoutFreqAmps{spec}(bout,1:2) = stimFreqFFTAmps;

                            plot(plotX,plotY)
                            hold on
                            %scatter( [f1*10,f2*10] , [plotY(f1*10),plotY(f2*10)] ) %Note: Critical assumption of perfect correlation between plotX index and actual value
                            scatter( [stimFreqFFTLOCS] , [stimFreqFFTAmps] ) %Note: Critical assumption of perfect correlation between plotX index and actual value
                            xlim([0,size(plotX,2)/2])
                        end
                        
                    catch
                        disp(['-# Spectrogram failed for bout ',num2str(bout),' of spec ',num2str(spec),' #-'])
                    end
                    if plotMode == 1  %Not FFT
                        title(['#',num2str(bout)])
                    else
                        title(['#',num2str(bout),' - f1: ',num2str(stimFreqFFTAmps(1)),', f2: ',num2str(stimFreqFFTAmps(2))])
                    end
                end
                %set(gcf,'Name',['Separated spectrograms - ',specialDescriptors{spec}])
                if plotMode == 1  %Not FFT
                    set(gcf,'Name',['Separated spectrograms - ',specialDescriptors{spec}])
                else
                    set(gcf,'Name',['Separated FFTs - ',specialDescriptors{spec},' (f1 - ',num2str(freqCoords(1,:)),', f2 - ',num2str(freqCoords(2,:)) ])
                end
            end
            %Summary scatter plot of FFT freq amps
            specStruct = struct;
            figure
            hold on
            specStruct.meds = [];
            specStruct.SEMs = [];
            titleStr = [];
            a = 1;
            for spec = 1:size(specialEval,2)
                thisSpecXCoords = [spec-0.125,spec+0.125];
                for ef = 1:size(specBoutFreqAmps{spec},2)
                    specStruct.meds(spec,ef) = nanmedian(specBoutFreqAmps{spec}(:,ef));
                    specStruct.SEMs(spec,ef) = nanstd(specBoutFreqAmps{spec}(:,ef)) / sqrt(size(specBoutFreqAmps{spec},1));
                    
                    bar([thisSpecXCoords(ef)],[specStruct.meds(spec,ef)],[0.25])
                    
                    scatter([ repmat(thisSpecXCoords(ef),size(specBoutFreqAmps{spec},1),1) ]' , [ specBoutFreqAmps{spec}(:,ef) ]')
                    line( [thisSpecXCoords(ef)-0.075 , thisSpecXCoords(ef)+0.075] , [ nanmedian(specBoutFreqAmps{spec}(:,ef)),nanmedian(specBoutFreqAmps{spec}(:,ef)) ] ,'Color', 'k')
                    
                    %line([ thisSpecXCoords(ef),thisSpecXCoords(ef) ], [ specStruct.meds(spec,ef)+specStruct.SEMs(spec,ef),specStruct.meds(spec,ef)-specStruct.SEMs(spec,ef) ], 'Color', 'k', 'LineStyle', ':')
                    
                    errorbar([thisSpecXCoords(ef)],[specStruct.meds(spec,ef)],[specStruct.SEMs(spec,ef)])
                end
                
                
                %{
                scatter([ repmat(thisSpecXCoords(1),size(specBoutFreqAmps{spec},1),1) ; repmat(thisSpecXCoords(2),size(specBoutFreqAmps{spec},1),1) ]' , [ specBoutFreqAmps{spec}(:,1) ; specBoutFreqAmps{spec}(:,2)  ]')
                line( [thisSpecXCoords(1)-0.075 , thisSpecXCoords(1)+0.075] , [ nanmedian(specBoutFreqAmps{spec}(:,1)),nanmedian(specBoutFreqAmps{spec}(:,1)) ] ,'Color', 'k')
                line( [thisSpecXCoords(2)-0.075 , thisSpecXCoords(2)+0.075] , [ nanmedian(specBoutFreqAmps{spec}(:,2)),nanmedian(specBoutFreqAmps{spec}(:,2)) ] ,'Color', 'k')
                thisSEMs = [ nanstd(specBoutFreqAmps{spec}(:,1)) / sqrt(size(specBoutFreqAmps{spec},1)) , nanstd(specBoutFreqAmps{spec}(:,2)) / sqrt(size(specBoutFreqAmps{spec},1)) ];
                line([ thisSpecXCoords(1),thisSpecXCoords(1) ], [ nanmedian(specBoutFreqAmps{spec}(:,1))+thisSEMs(1),nanmedian(specBoutFreqAmps{spec}(:,1))-thisSEMs(1) ], 'Color', 'k', 'LineStyle', ':')
                line([ thisSpecXCoords(2),thisSpecXCoords(2) ], [ nanmedian(specBoutFreqAmps{spec}(:,2))+thisSEMs(2),nanmedian(specBoutFreqAmps{spec}(:,2))-thisSEMs(2) ], 'Color', 'k', 'LineStyle', ':')
                %}
                titleStr = [titleStr, specialDescriptors{spec},', '];
            end
            ylabel(['FFT amplitude for f1/2'])
            title(titleStr)
            set(gcf,'Name', ['Averaged FFT amp. scatter/bar for f1 (',num2str(f1),'Hz) and f2 (',num2str(f2),'Hz)'])
        
        %doSpecialPlots end
        end
        
        %Sequential dependencies plot        
        if doSeqDep == 1
            seqStruct = struct;
            for colour = uniqueSentColours
                activeColour = colour{1};
                disp(['Current colour for seqdep analysis: ',activeColour])
                thisColours = [];
                for col = 1:size( chanCodecContents,2 )
                    if isempty( strfind( activeColour , chanCodecContents{col} ) ) ~= 1
                        if strfind( activeColour , chanCodecContents{col} ) == 1
                            thisColours{1} = chanCodecContents{col};
                        else
                            thisColours{2} = chanCodecContents{col};
                        end                        
                    end
                end
                %QA
                if size(thisColours,2) > 2
                    ['## Error overfind in colour groups ##']
                    crash = yes
                elseif size(thisColours,2) == 1
                    disp(['-- Monotonic colour grouping detected --'])
                    continue
                end
                
                %Calculate 32 possible sequential dependencies
                seqPatts = [];
                for d = 0:31
                    seqPatts = [seqPatts ; dec2bin(d,5)]; %Note: 0s and 1s are repetitions and alternations respectively, not stimulus identities
                end
                for i = 1:size(blockStruct,2)
                    a = zeros( size(seqPatts,1) , 1 ); %New position
                    if isequal( blockStruct(i).sentColours , activeColour ) == 1 %Only collect from blocks where the colour scheme matches
                        blockStartCoordAbs = blockStruct(i).startEnd(1);
                        blockStruct(i).seqDep.(activeColour).allPeaksSeqDepOrder = [];
                        temp = [1, abs(diff( blockStruct(i).allPeaksList.typeNum ))];
                        tempStr = num2str(temp);
                        tempStr = strrep(tempStr,' ','');
                        blockStruct(i).seqDep.(activeColour).allPeaksSeqDepOrder = tempStr;
                        %blockStruct(i).seqDep.pattsData{ 1:size(seqPatts,1) , 1 } = [];
                        %a = zeros( size(seqPatts,1) , 1 );
                        for x = size(seqPatts,2):size( temp, 2 ) %Ind it
                            thisOrd = tempStr( x-size(seqPatts,2)+1:x );
                            for s = 1:size(seqPatts,1) 
                                if isequal( thisOrd , seqPatts(s,:) ) == 1
                                    cycCentroid = blockStruct(i).allPeaksList.relPos(x) + blockStartCoordAbs;
                                    cycCollectionRange = floor(cycCentroid+captureWindowGeometryActive(1)*captureWindowSize)+1:...
                                        floor(cycCentroid+captureWindowGeometryActive(2)*captureWindowSize); %May potentially overrun
                                    blockStruct(i).seqDep.(activeColour).pattsData{ s , a(s) + 1 } = SplicedData(:, cycCollectionRange );
                                    a(s) = a(s) + 1;
                                    continue
                                end
                            end
                        end
                    end
                    blockStruct(i).seqDep.(activeColour).As = a;
                end

                %Pool seq data
                seqData = [];
                %seqDataMean = [];
                %seqDataSD = [];
                %sheperdess = [];
                b = zeros( size(seqPatts,1) , 1 );
                for s = 1:size( seqPatts,1 )
                    for i = 1:size(blockStruct,2)
                        if blockStruct(i).seqDep.(activeColour).As(s) > 0
                            %Old
                            %{
                            %plotData( s , b(s) + 1 : b(s) +  blockStruct(i).seqDep.As(s) ) = ...
                            %    blockStruct(i).seqDep.pattsData( s , 1:blockStruct(i).seqDep.As(s) );
                            plotData{s}( : , : , b(s) + 1 : b(s) +  blockStruct(i).seqDep.As(s) ) = ...
                                reshape([blockStruct(i).seqDep.pattsData{ s , 1:blockStruct(i).seqDep.As(s) }]',...
                                [size(blockStruct(i).seqDep.pattsData{s,1},1),size(cycCollectionRange,2),blockStruct(i).seqDep.As(s)]);
                                %I really should have an exemplar size variable by now...

                            sheperdess = [sheperdess; reshape([blockStruct(i).seqDep.pattsData{ s , 1:blockStruct(i).seqDep.As(s) }]',...
                                [size(blockStruct(i).seqDep.pattsData{s,1},1),size(cycCollectionRange,2),blockStruct(i).seqDep.As(s)]) ]; 
                            %}
                            %New
                            for m = 1:blockStruct(i).seqDep.(activeColour).As(s)
                                seqData{s}( :,:,b(s)+1 ) = blockStruct(i).seqDep.(activeColour).pattsData{ s , m };
                                %sheperdess = [sheperdess; blockStruct(i).seqDep.pattsData{ s , m }(1,:)];
                                b(s) = b(s) + 1;
                            end


                            %b(s) = b(s) + blockStruct(i).seqDep.As(s);
                        end
                    end
                    %{
                    if size( seqData,2 ) >= s && isempty( seqData{s} ) ~= 1
                        seqDataMean{s} = nanmean( seqData{s},3 );
                        seqDataSD{s} = nanstd( seqData{s},[],3 );
                    else
                        seqDataMean{s} = [];
                        seqDataSD{s} = [];
                    end
                    %}
                end

                %Meld (if applicable)
                if seqMeld > 0
                    for x = seqMeld %"Get the MELD"

                        meldList = [];
                        %meldListActive = [];
                        disp( ['Meld ',num2str(x)] )
                        for s = 1:size(seqPatts,1)
                            for st = 1:size(seqPatts,1)
                                if st ~= s && isequal( seqPatts(s,2:end) , seqPatts(st,2:end) ) %&& isempty(meldList) ~= 1 && isempty( find( meldList == sort( [s,st] ) ) ) == 1
                                    %Check if pair already existing
                                    proceed = 0;
                                    if isempty(meldList) == 1
                                        proceed = 1;
                                    elseif isempty(meldList) ~= 1 && isempty( find( meldList == sort( [s,st] ) ) ) == 1
                                        proceed = 1;
                                    end
                                    %Add to list if not
                                    if proceed == 1
                                        disp([seqPatts(s,:),' (',num2str(s),') matches ',seqPatts(st,:), ' (',num2str(st),')'])
                                        meldList = [meldList; s, st];
                                    end
                                end
                            end
                        end

                        temp = seqData(meldList(:,1));
                        for mInd = 1:size(meldList,1)
                            y = meldList( mInd , 1 );
                            if meldList(y,2) <= size( seqData,2 ) && isempty( seqData{ meldList(y,2) } ) ~= 1
                                temp{y}(:,:, size(temp{y},3) + 1 : size(temp{y},3) + size(seqData{ meldList(y,2) }(:,:,:),3) ) = seqData{ meldList(y,2) }(:,:,:);
                            end
                        end
                        seqData = temp;
                        seqPatts = seqPatts( meldList(:,1) , 2:end );

                        disp(['-- ',num2str( s ),' sequences melded into ',num2str( size(seqData,2) ),' --'])
                        disp([seqPatts])

                    end
                end

                seqPattsStr = seqPatts;
                seqPattsStr(seqPattsStr == '0') = 'R';
                seqPattsStr(seqPattsStr == '1') = 'A';

                %Average/SD/etc
                seqDataMean = [];
                seqDataSD = [];
                seqDataPTT = [];
                for s = 1:size( seqPatts,1 )
                    if size( seqData,2 ) >= s && isempty( seqData{s} ) ~= 1
                        seqDataMean{s} = nanmean( seqData{s},3 );
                        seqDataSD{s} = nanstd( seqData{s},[],3 );

                        seqDataPTT{s} = [];
                        for z = 1:size( seqData{s},3 )
                            seqDataPTT{s}(:,1,z) = abs( nanmax( seqData{s}(:,:,z) , [], 2 ) - nanmin( seqData{s}(:,:,z) , [], 2 ) );
                        end

                    else
                        seqDataMean{s} = [];
                        seqDataSD{s} = [];
                        seqDataPTT{s} = [];
                    end
                end

                %{
                figure
                plot( plotDataMean{1}(1,:) )
                title('seq patt 1 ch1 mean')
                %}
                figure
                for i = 1:size(seqPatts,1)
                    subplot( ceil(sqrt(size(seqPatts,1))) , ceil(sqrt(size(seqPatts,1))) , i )
                    if size( seqData,2 ) >= i && isempty( seqData{i} ) ~= 1
                        thisDataMean = seqDataMean{i}(1,:);
                        thisDataSD = seqDataSD{i}(1,:);

                        plot(thisDataMean)
                    end

                    %title([num2str(i),'-',seqPattsStr(i,:),'(n:',num2str(size(seqData{i},3)),')'])
                    title([num2str(i),'-',seqPattsStr(i,:),'(n:',num2str(size(seqData{i},3)),')'])
                end
                set(gcf,'Name',['Av. ERPs Ch 1 for seq dep - ',activeColour])

                %Ordered plot
                figure
                for i = seqOrder
                    subplot( 1 , size(seqOrder,2) , i )
                    if size( seqData,2 ) >= i && isempty( seqData{i} ) ~= 1
                        thisDataMean = seqDataMean{i}(1,:);
                        thisDataSD = seqDataSD{i}(1,:);

                        plot(thisDataMean)
                    end
                    title([num2str(i),'-',seqPattsStr(i,:),'(n:',num2str(size(seqData{i},3)),')'])
                end
                set(gcf,'Name',['Ordered av. ERPs Ch 1 for seq dep - ',activeColour])

                %PTT plot
                figure
                thisDataMean = [];
                thisDataSD = [];
                thisDataSEM = [];
                for i = seqOrder
                    if size( seqData,2 ) >= i && isempty( seqData{i} ) ~= 1
                        thisDataMean(1,i) = nanmean( seqDataPTT{i}(1,:,:) , 3 );
                        thisDataSD(1,i) = nanstd( seqDataPTT{i}(1,:,:) , [], 3 );
                        thisDataSEM(1,i) = thisDataSD(1,i) / sqrt( size(seqDataPTT{i},3) );
                    else
                        thisDataMean(1,i) = NaN;
                        thisDataSD(1,i) = NaN;
                        thisDataSEM(1,i) = NaN;
                    end
                end
                scatter( [1:size(thisDataMean,2)], thisDataMean )
                plot( [1:size(thisDataMean,2)], thisDataMean )
                hold on
                %Bootleg error bars
                for i = seqOrder
                    %line( [i,i] , [thisDataMean(1,i) - 0.5*thisDataSD(1,i) , thisDataMean(1,i) + 0.5*thisDataSD(1,i)] , 'Color', [0.2,0.2,0.2] )
                    line( [i,i] , [thisDataMean(1,i) - 0.5*thisDataSEM(1,i) , thisDataMean(1,i) + 0.5*thisDataSEM(1,i)] , 'Color', 'r' )
                end
                title(['Seq data PTTs for Ch1 - ',activeColour])
                xticks([1:size(seqOrder,2)])
                xticklabels( seqPattsStr(seqOrder,:) )
                xtickangle(270)
                
                %Save
                seqStruct.(activeColour).seqPatts = seqPatts;
                seqStruct.(activeColour).seqPattsStr = seqPattsStr;
                seqStruct.(activeColour).seqData = seqData;
                seqStruct.(activeColour).seqMean = seqDataMean;
                seqStruct.(activeColour).seqSD = seqDataSD;
            end
        end
                
        %----------------------------------------------------------------
        
        %Calculate actual numbers of flies, not just datasets
        %for i = 1:size(flyData,1)
        if useAutoList == 1
            thisFlyUniqueNumber = [];
            for fly = 1:size(uniqueFlies,1)
                if nansum(uniqueFlies{fly} == [dataListStruct.flyName(IIDN,:),'-',num2str(dataListStruct.flyNum(IIDN,:))]) == size(uniqueFlies{fly},2)
                    %BOOTLEG STRING MATCHING CODE
                    thisFlyUniqueNumber = fly; %The unique number of the fly within the data list (*not* the actual fly number of the day)
                end
            end
        else
            thisFlyUniqueNumber = 1; %May not be true if the initial dir specification finds more than one fly
        end
        %end

        %Save structures that need to be carried forward for fly-averaging
        overVar(IIDN).FolderName = FolderName;
        overVar(IIDN).groupHyper = groupHyper; %hyperData
        overVar(IIDN).blockStruct = blockStruct; %Warning: This risks making an already giant structure even more giant
        if doPerm == 1
            overVar(IIDN).overPerm = overPerm; %Permutation statistics
        end
        overVar(IIDN).jittStruct = jittStruct;
        if nansum(jittList == 4) > 0
            overVar(IIDN).overChron = overChron;
        end
        if doFilteredPlots == 1
            overVar(IIDN).filterStruct = filterStruct;
        end
        if useSaveStruct == 1
            overVar(IIDN).overSaveStruct = overSaveStruct; %Mostly just a precaution
        end
        if doSeqDep == 1
            overVar(IIDN).overSeq = seqStruct;
        end
        overVar(IIDN).ancillary.resampleFreq = resampleFreq; 
        overVar(IIDN).ancillary.f1 = f1; 
        overVar(IIDN).ancillary.f2 = f2;
        %overVar(IIDN).ancillary.captureWindowSize = floor(1/f1 * resampleFreq * 0.95); %Hardcoded 1 perio  assumption
        overVar(IIDN).ancillary.captureWindowSize = captureWindowSize; %Is there a reason this wasn't done initially?
        overVar(IIDN).ancillary.thisFlyUniqueNumber = thisFlyUniqueNumber;
        overVar(IIDN).ancillary.didSine = didSine;
        overVar(IIDN).ancillary.captureWindowGeometryActive = captureWindowGeometryActive;
        overVar(IIDN).ancillary.uniqueSentColours = uniqueSentColours;
        overVar(IIDN).ancillary.polReversalChan = polReversalChan;
        overVar(IIDN).ancillary.modernData = modernData;
        overVar(IIDN).descriptive.overOnsetAmpMeans = overOnsetAmpMeans; 
        overVar(IIDN).descriptive.overOnsetAmpMaxMins = overOnsetAmpMaxMins;
        overVar(IIDN).descriptive.overColourMaxMeans = overColourMaxMeans;

        if memoryEfficient ~= 1
            overSplice(IIDN).SplicedData = SplicedData; %"High Guardian overSplice"
            overSplice(IIDN).SplicedPhot = SplicedPhot;
            overSplice(IIDN).SplicedStim = SplicedStim;
            overSplice(IIDN).splicedEpoch = splicedEpoch;
        end

        %surrender
        
    end %loop for flies
%if shortcutSuccess end    
end

%%

disp(['--------------------------------------------------------------------------------------------------------------------------'])
disp(['--------------------------------------------------------------------------------------------------------------------------'])

%Text if auto
if useAutoList == 1
    disp(['-- All datasets analysed --'])
end

%##################
if ( saveOverVar == 1 && shortcutSuccess == 0 )
    %"Only run if saveOverVar enabled and wouldn't be just resaving data"
    disp(['-- Saving overVar (and ancillary) to file --'])
    tic
    if useAutoList == 1
        %saveName = [overVarPath, filesep, listToUse, '_', rerefIndex{rerefMode}, '.mat'] %Old
        %saveName = [overVarPath, filesep, listToUse, '_', rerefIndex{rerefMode}, '.mat'] %New with rereference information
        saveName = [overVarPath, filesep, listToUse, '_', rerefIndex{rerefMode}, customSaveComment, '.mat'] %Newer, with custom comment
    else
        %saveName = [overVarPath, filesep, validAndApplicableMATs{1}, '.mat'] %NEED TO CHECK, Old
        % = [overVarPath, filesep, validAndApplicableMATs{1}, '_', rerefIndex{rerefMode}, '.mat'] %NEED TO CHECK
        saveName = [overVarPath, filesep, validAndApplicableMATs{1}, '_', rerefIndex{rerefMode}, customSaveComment, '.mat'] %NEED TO CHECK (New with custom comment)
    end
    
    %overVarSaveStruct = [];
    save(saveName, 'flagParamSaveStruct', 'overVar', '-v7.3')
    disp(['-- overVar saved in ',num2str(toc),'s --'])
end
%##################
%##################
if ( saveIntegrationVariables == 1 && shortcutSuccess == 0 )
    disp(['-- Saving integration variables (and ancillary) to file --'])
    tic
    if useAutoList == 1
        saveName = [integPath, filesep, listToUse, '.mat'] %Newer, with custom comment
    else
        saveName = [integPath, filesep, validAndApplicableMATs{1}, '.mat'] %NEED TO CHECK (New with custom comment)
    end
    %{
    save(saveName, 'flagParamSaveStruct', 'overVar', '-v7.3')
    disp(['-- overVar saved in ',num2str(toc),'s --'])
    %}
    packStruct = struct;
    %{
    if automatedSaveWorkspace == 1
        for i = 1:size(flagList,1) 
            eval(['packStruct.flags.',flagList{i},' = ', flagList{i},';']); %Save flags as well, if applicable
        end
    end
    %}
    %packStruct.ancillary = flagParamSaveStruct;
    
    for i = 1:size(integVariablesList,2)
        if isempty(strfind(integVariablesList{i}, 'IIDN')) == 1 %Check if it is necessary to do an IIDN loop
            eval(['packStruct.',integVariablesList{i},' = ', integVariablesList{i},';']);
        else
            for IIDN = 1:size(overVar,2) %Note: It's possible some variables would differ in size, but unlikely
                eval(['packStruct.',integVariablesList{i},' = ', integVariablesList{i},';']);
            end
        end
    end

    %Save
    save(saveName, '-struct', 'packStruct', '-v7.3'); 
    disp(['-- Integration variables saved in ',num2str(toc),'s --'])
end

%##################
codeStartTime = posixtime(currentDateTime);
codeEndTime = posixtime(datetime('now'));
MET = codeEndTime - codeStartTime;
if useAutoList ~= 1
    disp(['-- Total elapsed time to aish: ',num2str(MET/60),' mins --'])   
    aishittei
    %Halt here because everything after is for multiple flies
else
    disp(['-- Time to process individual datasets: ',num2str(MET/60),' mins --'])
end

%%

clearvars('-except', flagParamSaveList{:})

%########
%Code for running from a loaded file, not a proper run
%{
    %Note: This will separate the plots that follow from whatever may be specified up above
['#- Caution: Using saved parameters from loaded file -#']
excludeList = [{'overVar'}];
for i = 1:size(excludeList,2)
   try
       flagParamSaveStruct = rmfield(flagParamSaveStruct,excludeList{i});
   catch
       disp(['# Could not remove field ',excludeList{i},' from flagParamSaveStruct #'])            
   end
end
flagFields = fieldnames(flagParamSaveStruct);
for i = 1:size(flagFields,1)
    eval([flagFields{i},' = flagParamSaveStruct.',flagFields{i},';']);   
end
%}
%########

flyColours = parula(size(overVar,2));

%Assemble structure of general parameters
generalStruct = struct;

%Iterate over ancillary
ancFields = fieldnames(overVar(1).ancillary);
for ancFiel = 1:size(ancFields,1)
    ancFielName = ancFields{ancFiel};
    temp = overVar(1).ancillary.(ancFielName); %Pull first fly's data and compare against all others
    for IIDN = 1:size(overVar,2)
        if isempty(strfind(ancFielExcludeList,['-',ancFielName,'-'])) == 1 && isequal(temp, overVar(IIDN).ancillary.(ancFielName)) ~= 1
            ['## Alert: Inconsistency in ',ancFielName,' between flies detected ##']
            crash = yes
        else
            generalStruct.(ancFielName) = temp;
        end
    end
    %{
    if nansum(isnan(temp)) == size(temp,1) || isempty(strfind(ancFielExcludeList,['-',ancFielName,'-'])) ~= 1 || size(unique(temp),1) == 1
        generalStruct.(ancFielName) = temp(1);
    else
        ['## Alert: Inconsistency in ',ancFielName,' between flies detected ##']
        crash = yes
    end
    %}
end
%Remove exclusionary fields
fieldsToRemove = strsplit(ancFielExcludeList,'-');
for i = 1:size(fieldsToRemove,2)
    if isempty(fieldsToRemove{i}) ~= 1
        try
            generalStruct = rmfield(generalStruct,fieldsToRemove{i});
        catch
            ['## Error in attempting to remove field ',fieldsToRemove{i}, ' from generalStruct ##']
        end
    end
end

captureWindowSize = generalStruct.captureWindowSize;
captureWindowGeometryActive = generalStruct.captureWindowGeometryActive;

%And some paths/path associated variables
if useAutoList == 1
    saveName = strcat(figPath,'\',listToUse);
else
    saveName = strcat(figPath,'\',flies(1).name);
end

%Fly-averaged plots

%--------------
        
%Calculate (dynamic) chans of interest (again)
overChansOfInterestActive = [];
for IIDN = 1:size(overVar,2)
    %Attempt to derive pol reversal chan
        %This is done here because current channel evals rely on the PR channe, but if different criteria are used then more derivation may be needed
    polReversalChan = [];
    if isfield(overVar(IIDN).ancillary, 'polReversalChan') == 1
        polReversalChan = overVar(IIDN).ancillary.polReversalChan;
    else
        disp(['-# Caution: No polarity reversal data available for dataset number ',num2str(overVar(IIDN).flyUniqueNumber),'; Attempting to derive from NaN presence #-'])
        %Pre QA
        if memoryEfficient == 1
            ['-# Alert: Cannot (currently) find polarity reversal in memory-efficient mode #-']
            crash = yes
        end
        prosPolReversals = find( isnan( overSplice(IIDN).SplicedData(:,1) ) == 1 );
        %QA
        if size(prosPolReversals,1) > 1
            ['-# Caution: Multiple apparent NaN channels detected #-']
        elseif isempty(prosPolReversals) == 1
            ['-# Caution: No apparent NaN channels found #-']
        elseif size(prosPolReversals,1) == 1
            disp(['-# Prospective pol. reversal channel identified in channel ',num2str(prosPolReversals),' #-'])
            polReversalChan = prosPolReversals;
        end
    end
    %Use default as last resort "(ft. Kinoko)"
    if isempty(polReversalChan) == 1
        disp(['-# Using default pol. reversal chan of 12 #-'])
        polReversalChan = 12;
    end
    for chan = 1:size( chansOfInterest,2 )
        %eval([ 'chansOfInterestActive(',num2str(chan),') = ', chansOfInterest{chan},';' ]);
        eval([ 'overChansOfInterestActive(',num2str(IIDN),',',num2str(chan),') = ', chansOfInterest{chan},';' ]);
        %QA
        %Old, relies on overSplice
        %{
        if overChansOfInterestActive(IIDN,chan) > size(overSplice(1).SplicedData,1)
            ['-# Caution: Channel request "',chansOfInterest{chan},'" exceeds data channels by ',num2str(overChansOfInterestActive(IIDN,chan) - size(overSplice(1).SplicedData,1)),'; Forcing size correctness #-']
            overChansOfInterestActive(IIDN,chan) = size(overSplice(1).SplicedData,1);
        elseif overChansOfInterestActive(IIDN,chan) < 1
            ['-# Caution: Channel request "',chansOfInterest{chan},'" is sub 1st channel by ',num2str( overChansOfInterestActive(IIDN,chan) ),'; Forcing to 1 #-']
            overChansOfInterestActive(IIDN,chan) = 1;
        end
        %}
        %New
        numChans = size(overVar(IIDN).descriptive.overOnsetAmpMeans,2);
        if overChansOfInterestActive(IIDN,chan) > numChans
            ['-# Caution: Channel request "',chansOfInterest{chan},'" exceeds data channels by ',num2str(overChansOfInterestActive(IIDN,chan) - numChans),'; Forcing size correctness #-']
            overChansOfInterestActive(IIDN,chan) = numChans;
        elseif overChansOfInterestActive(IIDN,chan) < 1
            ['-# Caution: Channel request "',chansOfInterest{chan},'" is sub 1st channel by ',num2str( overChansOfInterestActive(IIDN,chan) ),'; Forcing to 1 #-']
            overChansOfInterestActive(IIDN,chan) = 1;
        end
    end
end
clear chansOfInterestActive
%%
%--------------

%Some quick integ plots, if applicable
if integMode == 1
    %blockWindow = [1415:1425]; %Based on fly 5 (210721)
    %timeWindow = [48690:48920]; %Derived from ac/inac timescale seconds plot
    
    if memoryEfficient ~= 1
	    for IIDN = 1:size(overVar,2)
            %Plot ac/inac
            figure
            %QA to make sure that correct field is being pulled
            if isfield(overVar(IIDN),'behavCorrectedLabels') == 1 && isequal(overVar(IIDN).behavCorrectedLabels{13},'rawActivity') ~= 1
                ['-# Caution: Incorrect activity field potentially used #-']
            end
            %%plot(overVar(IIDN).behavInterp(:,6),overVar(IIDN).behavInterp(:,13),'Color','k')
            [timeStamps,unCoords,~] = unique( overVar(IIDN).behavInterp(:,6) );
            plot( timeStamps ,overVar(IIDN).behavInterp(unCoords,13),'Color','k') %Save a bit of memory by only plotting unique timepoints
            yLim = get(gca,'YLim');
            %Plot ac/inac data as a factor of time since 5PM
            acAlt = nanmax(yLim);
            temp = [];
            %temp = bwlabel(overVar(IIDN).behavInterp(:,1));
            temp = bwlabel(overVar(IIDN).behavInterp(unCoords,1));
            for bout = 1:nanmax(temp)
                thisBoutCoords = find(temp == bout);
                %line([overVar(IIDN).behavInterp(nanmin(thisBoutCoords),6),overVar(IIDN).behavInterp(nanmax(thisBoutCoords),6)],[acAlt,acAlt],...
                %    'LineWidth',2,'Color','k')
                line([timeStamps(nanmin(thisBoutCoords)),timeStamps(nanmax(thisBoutCoords))],[acAlt,acAlt],...
                    'LineWidth',2,'Color','k')
            end
            %Plot data
            offset = nanmax( overVar(IIDN).behavInterp(unCoords,13) );
            hold on
            plot(timeStamps,(overSplice(IIDN).SplicedStim(1,unCoords )*0.0004)+offset*0.9)
            plot(timeStamps,(overSplice(IIDN).SplicedData(6, unCoords )*0.4)+offset*1.25)
            hold off
            %ylim([nanmin(yLim),nanmax(yLim)*1.1])
            ylim('auto')
            
            xlabel('Time since 5PM (sec)')
            ylabel('Behavioural activity')
            title(['Ac/Inac - ',flies(IIDN).name,'(IIDN: ',num2str(IIDN),')'])
            
            %Plot combined LFP/activity
            figure
            %window = [ overVar(IIDN).blockStruct(nanmin(blockWindow)).startEnd(1):overVar(IIDN).blockStruct(nanmax(blockWindow)).startEnd(2) ];
            %window = [ find(overVar(5).behavInterp(:,6) > nanmin(timeWindow), 1) : find(overVar(5).behavInterp(:,6) > nanmax(timeWindow), 1) ];
            %timescale = overVar(IIDN).behavInterp(window,6)/60;
            plotDownsampleValue = 5000; %Arbitrary number of points to downsample all data (including timescale) to (-1 for all)
            for bout = 1:nanmax(temp)
                subplot(ceil(sqrt(nanmax(temp))),ceil(sqrt(nanmax(temp))),bout)
                thisBoutCoords = find(temp == bout);
                window = [ floor(thisBoutCoords(1)-0.05*length(thisBoutCoords)) : ceil(thisBoutCoords(end)+0.05*length(thisBoutCoords)) ];
                %
                %%window = [ thisBoutCoords(1)+(7*overVar(IIDN).ancillary.resampleFreq) : thisBoutCoords(1)+(9*overVar(IIDN).ancillary.resampleFreq) ]; 
                %
                %window( window < 1 ) = []; window( window > size(overVar(IIDN).behavInterp,1) ) = []; %Note: Is in temp reference frame
                window( window < 1 ) = []; window( window > size(timeStamps,1) ) = []; %Note: Is in temp reference frame
                %timescale = overVar(IIDN).behavInterp(window,6)/60;
                windowLengthPre = length(window);
                if plotDownsampleValue ~= -1 && length(window) > plotDownsampleValue
                    window = [window(1):ceil(length(window)/plotDownsampleValue):window(end)];
                end
                %timescale = overVar(IIDN).behavInterp(window,6)/60;
                timescale = timeStamps(window)/60;
                if length(unique(timescale)) / length(timescale) < 0.75
                    timescale = linspace(timescale(1),timescale(end),length(timescale)); %Interpolate timescale to reduce X double-ups, at risk of ignoring time discontinuities
                end
                %shepard
                %thisStim = overSplice(IIDN).SplicedStim(1,window);
                %thisData = overSplice(IIDN).SplicedData(6,window);
                thisStim = overSplice(IIDN).SplicedStim(1,unCoords(window));
                thisData = overSplice(IIDN).SplicedData(6,unCoords(window));
    
                %plot(timescale,overVar(IIDN).behavInterp(window,13),'Color','k')
                plot(timescale,overVar(IIDN).behavInterp(unCoords(window),13),'Color','k')
                hold on
                %plot(timescale,(overSplice(IIDN).SplicedStim(1,window)*0.0001)+nanmax(overVar(IIDN).behavInterp(window,13)))
                %plot(timescale,(overSplice(IIDN).SplicedData(6,window)*0.1)+nanmax(overVar(IIDN).behavInterp(window,13)*1.5))
                %%offset = nanmax(overVar(IIDN).behavInterp(window,13));
                %offset = nanmax(overVar(IIDN).behavInterp(thisBoutCoords,13));
                offset = nanmax(overVar(IIDN).behavInterp(unCoords(thisBoutCoords) ,13));
                plot(timescale,(thisStim*0.0001)+offset)
                plot(timescale,(thisData*0.1)+offset*1.5)
                %title(['Ac/Inac, LFP, Stim - ',flies(IIDN).name,'(IIDN: ',num2str(IIDN),'), ind ',num2str(window(1)),':',num2str(window(end))])
                %title(['Ac/Inac, LFP, Stim, IIDN:',num2str(IIDN),', Bout ',num2str(bout)])
                titleStr = ['Ac/Inac, LFP, Stim, IIDN:',num2str(IIDN),', Bout ',num2str(bout)];
                title(titleStr)
                nameStr = ['AcInacAndLFPandStim-',flies(IIDN).name];
                if plotDownsampleValue ~= -1
                    nameStr = [nameStr,'-WindowedTo',num2str( nanmin([length(window),windowLengthPre]) )];
                end
                set(gcf,'Name',nameStr)
            end
            
        end
    else
        disp(['(Cannot do integ LFP visualisation plot in memory-efficient mode)'])
    end
    
    
    %And some acd/inac bout hists because why not
    histStates = {['Sleep'],['Wake']};
    histColours = {['b'],['r']};
    figure
    allDurs = [];
    for IIDN = 1:size(overVar,2)
        subplot( ceil(sqrt(size(overVar,2))),ceil(sqrt(size(overVar,2))),IIDN )
        hold on
        try
            preTemp = overVar(IIDN).behavInterp(:,1);
            preTemp(isnan(preTemp)) = []; %Will be problematic if NaNs scattered throughout, rather than being contiguous blocks
            temp = [];
            temp{1} = bwlabel( preTemp );
            temp{2} = bwlabel( ~preTemp );
            tempDurs = [];
            titleStr = ['Dataset #',num2str(IIDN),'-'];
            for ti = 1:length(temp)
                tempDurs{ti} = [];
                for bout = 1:nanmax(temp{ti})
                    tempDurs{ti}( length(tempDurs{ti})+1 ) = nansum( temp{ti} == bout ) / overVar(IIDN).ancillary.resampleFreq / 60; %Convert to minutes
                end
                if IIDN == 1
                    allDurs{ti} = tempDurs{ti};
                else
                    allDurs{ti} = [allDurs{ti},tempDurs{ti}];
                end
                histogram( tempDurs{ti} , 'BinEdges', [0:5:60], 'FaceColor', histColours{ti} )
                titleStr = [titleStr, histStates{ti},' (', histColours{ti},'), '];
            end
            title([titleStr,' dur. hist/s'])
        catch
            disp(['-# Failure to process ac/inac for dataset #',num2str(IIDN),'#-'])
        end
    end
    %Pooled hist
    figure
    %hold on
    titleStr = ['All durs pooled (N=',num2str(size(overVar,2)),') '];
    for ti = 1:size(allDurs,2)
        subplot(1,size(allDurs,2),ti)
        histogram( allDurs{ti} , 'BinEdges', [2.5:5:62.5], 'FaceColor', histColours{ti} )
        %titleStr = [titleStr, histStates{ti},' (', histColours{ti},'), '];
        title([titleStr, histStates{ti},' (', histColours{ti},'), '])
        xlabel(['Time bin'])
        ylabel(['Count'])
        xticks([5:5:60])
    end
    %title(titleStr)
    %xlabel(['Time bin'])
    %ylabel(['Count'])
    %xticks([5:5:60])
    
    
end

%--------------
%%
%#######
if memoryEfficient ~= 1
    showBehav = 1;
    %QA
    if integMode == 0
        showBehav = 0; %Override
    end
    targetBlock = 9;
    %A quick calib-style plot of the first(?) block
    for IIDN = 1:size(overVar,2)
        try
            flyName = [flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum)];
            colMap = jet(size(overSplice(IIDN).SplicedData,1));

            thisCoords = overVar(IIDN).blockStruct(targetBlock).range;
            thisCoords = floor( thisCoords - 0.1*size(thisCoords,2) );
            relPMod = 0.1*size(thisCoords,2);

            figure
            %plot( EEG.Wave.data(1,:) )
            hold on
            for chan = 1:size(overSplice(IIDN).SplicedData,1)
                plot( overSplice(IIDN).SplicedData(chan,thisCoords)-(chan*500), 'Color', colMap(chan,:) )    
            end
            plot( normalize(overSplice(IIDN).SplicedStim(1,thisCoords),'range', [500,2500] ) )
            if showBehav == 1 && any( ismember( overVar(IIDN).behavCorrectedLabels, 'probMetric' ) )
                probMetricCol = find( ismember( overVar(IIDN).behavCorrectedLabels, 'probMetric' ) );
                plot( normalize(overVar(IIDN).behavInterp(thisCoords,probMetricCol),'range', [500,2500] ) )
            end
            scatter( overVar(IIDN).blockStruct(targetBlock).allPeaksList.relPos+relPMod, overVar(IIDN).blockStruct(targetBlock).allPeaksList.typeNum*250 )
                %Scatters run for longer than data due to pre-window (if applicable)
            %xlim([2500,3500])
            %xlim([300,600])
            %xlim([405,520]) %Paper figure LFP exemplar
            %title(['LFP + Stim for ch. 1 - ',num2str(size(overSplice(IIDN).SplicedData,1))])
            title([flyName,' - LFP + Stim for ch. 1 - ',num2str(size(overSplice(IIDN).SplicedData,1)),...
                char(10),' (Block ',num2str(targetBlock),' - Range ',num2str(thisCoords(1)),' : ',num2str(thisCoords(end)),...
                ' - ',overVar(IIDN).blockStruct(targetBlock).sentCondition,' - ',overVar(IIDN).blockStruct(targetBlock).sentColours,')'])
            set(gcf,'Name', [flyName,' LFP and stim'])
        catch
            disp(['-# Failure to plot combined LFP and stim for fly #',num2str(IIDN),' #-'])
        end
    end
else
    disp(['(Cannot do calib-style first block plot in memory-efficient mode)'])
end

%%

%#######
%Grand Av ERPs
figure
%Account for new plotting subselection
if exist('chanIndsOfPlotInterest') == 1
    theseChans = chanIndsOfPlotInterest;
else
    theseChans = 1:size(overChansOfInterestActive,2);
end
if overrideGroupColours == 1 && exist('targsOfPlotInterest') == 1
   overrideColours =  jet(size(targsOfPlotInterest,2));
end
for chanInd = theseChans
    if exist('grandAvERPSubplotMode') && grandAvERPSubplotMode == 1 %Do channels as subplots
        subplot( size(theseChans,2), 1, chanInd )
    end
    hasWarned = 0;

    groupPhotData = [];
    maxPhotAv = 0;

    titleStr = [];
    figStr = []; %Similar, but for fig autosaving
    vsStr = [repmat({' vs '},1,size(groupTargets,2)-1),{''}]; %Assembles a correct number of ' vs 's
    
    legList = [];
    legNameList = [];

    %figure
    %Account for new plotting subselection
    if exist('targsOfPlotInterest') == 1
        theseTargs = targsOfPlotInterest;
    else
        theseTargs = 1:size(targsOfInterest,2);
    end
    for targInd = 1:size(theseTargs,2)%size(groupTargets,2)
        %targToPlot = targsOfInterest(targInd); %Only used for interfaces with hyperData structures (since non-linear)
        targToPlot = theseTargs(targInd); %Only used for interfaces with hyperData structures (since non-linear)
        
        flyData = [];
        for fly = 1:size(overVar,2)
            chanToPlot = overChansOfInterestActive(fly,chanInd); %New
            plotData = [];
            groupAvData = [];
            if isempty(overVar(fly).groupHyper(targToPlot).Lists) ~= 1
                %Assemble 3D and 2D matrices
                if showCorrected == 0
                    plotData = overVar(fly).groupHyper(targToPlot).Datas(chanToPlot,:,:); %Uncorrected
                else
                    plotData = overVar(fly).groupHyper(targToPlot).DatasCorr(chanToPlot,:,:); %Corrected
                end
                %{
                plotDataFlat = [];
                for i = 1:size(plotData,3)
                    plotDataFlat(i,:) = plotData(:,:,i);
                end
                %}
                %Apply post-hoc subsampling if requested
                if doPostHocSubSampling == 1
                    if size(overVar(fly).groupHyper(targToPlot).Datas(chanToPlot,:,:),3) >=  size(overVar(fly).groupHyper(postHocSubSampleTarget).Datas(chanToPlot,:,:),3)
                        plotData = plotData(:,:, [randsample( size(overVar(fly).groupHyper(targToPlot).Datas(chanToPlot,:,:),3) ,  size(overVar(fly).groupHyper(postHocSubSampleTarget).Datas(chanToPlot,:,:),3) )] );
                            %Subsample according to size of postHocSubSampleTarget
                    else
                        if hasWarned ~= 1 %Simple console spam protection
                            disp(['#- One or more groups contained less data than the postHocSubSampleTarget (G',num2str(postHocSubSampleTarget),' -#'])
                            hasWarned = 1;
                        end
                    end
                end
                
                %Means etc
                groupAvData = nanmean(plotData(1,:,:) ,3); %Row index of 1 because channel specification done earlier
                %groupDataSDs{targInd} = nanstd(groupPlotDatas{targInd}(1,:,:), [] ,3);

                %Normalise if requested
                if normaliseERPs == 1
                    groupAvData = groupAvData / overVar(fly).descriptive.overOnsetAmpMeans{chanToPlot}; %Normalise by mean of every detected peak (Now from correct channel)
                elseif normaliseERPs == 2
                    groupAvData = groupAvData / nanmax(abs(groupAvData)); %Normalise by own max of plot
                elseif normaliseERPs == 3
                    if ~isnan(overVar(fly).groupHyper(targToPlot).cycleColoursNum)
                        %groupAvData = groupAvData / overVar(fly).descriptive.overColourMaxMeans{ overVar(fly).groupHyper(targToPlot).cycleColoursNum }(chanToPlot); %Normalise by mean of peaks of this colour (May crash if called when colours weren't specified)
                        groupAvData = groupAvData / abs( overVar(fly).descriptive.overColourMaxMeans{ overVar(fly).groupHyper(targToPlot).cycleColoursNum }(chanToPlot) ); %Normalise by mean of peaks of this colour (Switch to abs to preserve sign of original data)
                    else %NaN detected sentColours, probably because not specified in specialEvals
                        groupAvData = groupAvData;
                        disp(['-# Cannot colour normalise fly #',num2str(fly),' target group ',num2str(targToPlot),' #-'])
                    end
                end

                flyData(fly,:) = groupAvData; %Will only work as long as groupAvData has 1 row
                flyData( flyData == 0 ) = NaN; %Remove zeroes that may have cropped up because of reasons 
                    %Note: In theory this may lead to true zeroes being deleted, but that seems an unlikely case

                %Photodiode display
                %if chanInd == size(overChansOfInterestActive,2) 
                %if chanInd == theseChans(end) || grandAvERPSubplotMode == 1
                if chanInd == theseChans(1) || grandAvERPSubplotMode == 1 %Mirror below
                    groupPhotData(fly,:) = nanmean(overVar(fly).groupHyper(targToPlot).Phots(1,:,:),3)*0.001; %Note non-targInd specifier and manipulated scale
                    groupPhotData( groupPhotData == 0 ) = NaN;
                    %Normalise phot (if requested)
                    if normaliseERPs ~= 0
                        groupPhotData(fly,:) = groupPhotData(fly,:) / nanmean(groupPhotData(fly,:)); %Normalise by mean of self
                    end
                end
            else
                if fly ~= 1
                    flyData(fly,:) = NaN;
                    groupPhotData(fly,:) = NaN;
                else
                    flyData(fly,1:captureWindowSize) = NaN;
                    groupPhotData(fly,1:captureWindowSize) = NaN;
                    ['#- Warning: Failure in first fly data; Array size guessed -#']
                end
            end
        end
        
        %Average/SD across flies
        flyDataAv = nanmean(flyData,1);
        %flyDataSEM = nanstd(flyData,1) / sqrt(size(flyData,1)); %Note: Not accurate if significant numbers of flies lack data for this group
        flyDataSEM = nanstd(flyData,1) / sqrt(nansum(isnan(flyData(:,1)) ~= 1)); %Note: Not accurate if significant numbers of flies lack data for this group

        if overrideGroupColours == 1
            thisGroupColour = overrideColours(targInd,:);
        else
            thisGroupColour = groupColours(targToPlot,:);
        end
        %Plot
        %plot(flyDataAv, 'Color', groupColours(targToPlot,:))
        %plot(flyDataAv, 'Color', thisGroupColour)
        plot(flyDataAv, 'Color', thisGroupColour,'LineWidth',2)
        hold on
        groupShadeCoordsX = [1:1:size(flyDataAv,2),size(flyDataAv,2):-1:1];
        groupShadeCoordsY = [flyDataAv+flyDataSEM,flip(flyDataAv-flyDataSEM)];
        %fill(groupShadeCoordsX, groupShadeCoordsY, groupColours(targToPlot,:)) %Error shading
        %h = fill(groupShadeCoordsX, groupShadeCoordsY, groupColours(targToPlot,:)); %Error shading (and sent to object)
        %h = fill(groupShadeCoordsX, groupShadeCoordsY, thisGroupColour); %Error shading (and sent to object)
        h = fill(groupShadeCoordsX, groupShadeCoordsY, thisGroupColour, 'LineStyle', 'none'); %Error shading (and sent to object)
        legList(1,size(legList,2)+1) = h;
        legNameList{1,size(legNameList,2)+1} = ['Group ',num2str(targToPlot)];
        alpha(0.15)
        
        if doIndivLines == 1
            %Plot individual flies
            for i = 1:size(flyData,1)
                %{
                thisFlyUniqueNumber = [];
                for fly = 1:size(uniqueFlies,1)
                    if nansum(uniqueFlies{fly} == [num2str(dataList(i,1)),'-',num2str(dataList(i,2))]) == size(uniqueFlies{fly},2)
                        %BOOTLEG STRING MATCHING CODE
                        thisFlyUniqueNumber = fly;
                    end
                end
                %}
                thisFlyUniqueNumber = overVar(i).ancillary.thisFlyUniqueNumber;
                %plot(flyData(i,:), ':', 'LineWidth', 2, 'Color', groupColours(targToPlot,:)) %Colours consistent with group
                plot(flyData(i,:), ':', 'LineWidth', 2, 'Color', thisGroupColour) %Colours consistent with group
                plot(flyData(i,:), '--', 'LineWidth', 2, 'Color', flyColours(thisFlyUniqueNumber,:))
                %hold on
                %pause(1)
            end
        end

        %Ancillary text
        %safePosS = linspace(0.2*captureWindowSize,0.8*captureWindowSize,size(targsOfInterest,2));
        safePosS = linspace(0.2*captureWindowSize,0.8*captureWindowSize,size(theseTargs,2));
        safePos = floor(safePosS(targInd));
        %text(safePos,flyDataAv(floor(safePos)), ['G:',num2str(targToPlot),'(',num2str(targInd),')',',C:',num2str(chanToPlot)], 'Color', 'r')
        %text(safePos,flyDataAv(floor(safePos)), ['-G:',num2str(targToPlot),'(',num2str(targInd),')',',C:',num2str( unique(overChansOfInterestActive(:,chanInd))' )], 'Color', 'r')
        if numel(theseChans) > 1 %Don't bother with this text if only one channel
            text(safePos,flyDataAv(floor(safePos)), ['-G:',num2str(targToPlot),'(',num2str(targInd),')',',C:',chansOfInterestStr{chanInd}], 'Color', 'r')
        end
        %Strings
        %if chanInd == size(overChansOfInterestActive,2) %Only assemble on final loop
        if chanInd == theseChans(end) || grandAvERPSubplotMode == 1 %Only assemble on final loop*    
            titleStr = [titleStr, groupDescriptors{targToPlot}, '(J:',num2str(groupJitters(targToPlot)),')', vsStr{targInd}, char(10)];
        end
        
        
        %Photodiode
        %if chanInd == size(overChansOfInterestActive,2)
        if chanInd == theseChans(1) || grandAvERPSubplotMode == 1
            if chanInd == theseChans(1)
            %photScale = abs(nanmax(flyDataAv)-nanmin(flyDataAv)) * 0.2; %Scale photodiode to be 20% of max group amplitudes
            plotData = normalize(groupPhotData, 2, 'range', [-1 1]);
            %plotData = normalize(groupPhotData, 2, 'range', [nanmin(groupShadeCoordsY) nanmax(groupShadeCoordsY)]);
            if normaliseERPs == 0
                plotData = plotData * ( abs(nanmax(flyDataAv)-nanmin(flyDataAv)) * 0.2 );
            end
            %plotData = plotData ./ nanmax(plotData,[],2);
            flyPhotAv = nanmean(plotData,1);
            flyPhotSEM = nanstd(plotData,1) / sqrt(size(plotData,1));
            groupPhotShadeCoordsX = [1:1:size(flyPhotAv,2),size(flyPhotAv,2):-1:1];
            %groupPhotShadeCoordsY = [flyPhotAv+0.5*flyPhotSEM,flip(flyPhotAv-0.5*flyPhotSEM)]; %Evidence has indicated that halving SEM may not be correct
            groupPhotShadeCoordsY = [flyPhotAv+flyPhotSEM,flip(flyPhotAv-flyPhotSEM)]; %+- SEM
            groupPhotShadeCoordsY = groupPhotShadeCoordsY - groupPhotShadeCoordsY(1); %Offset start
            end
            fill(groupPhotShadeCoordsX, groupPhotShadeCoordsY, [1.0,0.647,0.0]) %Error shading
                %Note: Scale and shading of photodiode signal is for display purposes only
            alpha(0.15)
            safePos = floor(0.5*size(groupPhotShadeCoordsY,2));
            try
            text(safePos,groupPhotShadeCoordsY(safePos+targInd), ['-G:',num2str(targToPlot),'(',num2str(targInd),')'], 'Color', groupColours(targToPlot,:))
            catch
            ['-# Failure in text for G',num2str(targToPlot),' #-']    
            end
        end
                
    end
    
    %Legend (if first chan)
    %if chanInd == 1
    if chanInd == theseChans(1) || grandAvERPSubplotMode == 1
        leg = legend(legList,legNameList);
        set(leg,'AutoUpdate', 'off')
    end
    
    %Further ancillaries
    if ( grandAvERPSubplotMode == 1 ) || ( grandAvERPSubplotMode == 0 && chanInd == theseChans(end) )
        line([ captureWindowSize*(-captureWindowGeometryActive(1)),captureWindowSize*(-captureWindowGeometryActive(1)) ],[-nanmax(flyPhotAv),nanmax(flyPhotAv)], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
            %Uses captureWindowGeometryActive to back-calculate centroid position
        xlim([1, captureWindowSize])
        %titleStr = [titleStr,' for channel/s ',chansOfInterest{theseChans}];
        %titleStr = [titleStr,' for channel/s ',chansOfInterest{theseChans(chanInd)}];
        titleStr = [titleStr,' for channel/s ',chansOfInterest{chanInd}];
        if showCorrected == 1
            titleStr = [titleStr, char(10), ' (',correctedIndex{showCorrected+1},', ' baselineCorrectionDescIndex{baselineCorrectionMethod+1}, ')'];
        else
            titleStr = [titleStr, char(10), ' (',correctedIndex{showCorrected+1},')'];
        end
        if normaliseERPs ~= 0
            titleStr = [titleStr, normaliseIndex{normaliseERPs}];
        else
            titleStr = [titleStr, '(Not normalised)'];
        end
        titleStr = [titleStr, char(10), 'Grand fly average (N=',num2str(size(flyData,1)),')'];
        if useAutoList == 1
            titleStr = [titleStr, char(10), 'List: ',listToUse];
        end
        titleStr = [titleStr, char(10), 'Rereference mode: ', rerefIndex{rerefMode}];
        figStr = [figStr,rerefIndex{rerefMode}]; %Add reref info to filename
        if doSubSampling == 1
            titleStr = [titleStr,char(10),'(Data subsampled)'];
        end
         if doPostHocSubSampling == 1
             titleStr = [titleStr,char(10),'(Data post-hoc subsampled)'];
        end
        title(titleStr)
        xlabel(['Time (frames)'])
        pulledYLims = get(gca,'YLim'); %Used for MMN plot
    end


end

%%

%Further ancillaries
    %Moved above to support subplots
%{    
%line([captureWindowSize/2,captureWindowSize/2],[-300,300], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
line([ captureWindowSize*(-captureWindowGeometry(1)),captureWindowSize*(-captureWindowGeometry(1)) ],[-nanmax(flyPhotAv),nanmax(flyPhotAv)], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
    %Uses captureWindowGeometry to back-calculate centroid position

xlim([1, captureWindowSize])
%titleStr = [titleStr,' for channel/s ',num2str(chansOfInterestActive)];
%titleStr = [titleStr,' for channel/s ',chansOfInterest{:}];
titleStr = [titleStr,' for channel/s ',chansOfInterest{theseChans}];

if showCorrected == 1
    titleStr = [titleStr, char(10), ' (',correctedIndex{showCorrected+1},', ' baselineCorrectionDescIndex{baselineCorrectionMethod+1}, ')'];
else
    titleStr = [titleStr, char(10), ' (',correctedIndex{showCorrected+1},')'];
end
if normaliseERPs ~= 0
    titleStr = [titleStr, normaliseIndex{normaliseERPs}];
else
    titleStr = [titleStr, '(Not normalised)'];
end

titleStr = [titleStr, char(10), 'Grand fly average (N=',num2str(size(flyData,1)),')'];
if useAutoList == 1
    titleStr = [titleStr, char(10), 'List: ',listToUse];
end
titleStr = [titleStr, char(10), 'Rereference mode: ', rerefIndex{rerefMode}];
figStr = [figStr,rerefIndex{rerefMode}]; %Add reref info to filename
if doSubSampling == 1
    titleStr = [titleStr,char(10),'(Data subsampled)'];
end
 if doPostHocSubSampling == 1
     titleStr = [titleStr,char(10),'(Data post-hoc subsampled)'];
end
%titleStr = [titleStr,' for channel/s ',num2str(chansOfInterest), ' (',correctedIndex{showCorrected+1},')'];
title(titleStr)
%xlabel(['Time (ms)']) %Only true when resampleFreq = 1000
xlabel(['Time (frames)'])
pulledYLims = get(gca,'YLim'); %Used for MMN plot
%}
thisFigName = 'GrandAvERP';
set(gcf,'Name',[thisFigName]);

%###########
%Save figure
if saveFigs == 1
    try
        savePlot(saveName,thisFigName,figStr)
    catch 
        ['-# Alert: Failure to save plot #-']
    end
end
%###########
%%
%---------------------

% Individual hyperGroup perm-style plot
forcedYLims = 1;
for IIDN = 1:size(overVar,2)
    groupHyper = overVar(IIDN).groupHyper;
    overColourMaxMeans = overVar(IIDN).descriptive.overColourMaxMeans; %Will probably crash in non-colour-normalised situations
    resampleFreq = overVar(IIDN).ancillary.resampleFreq;
    flyName = [flies(IIDN).name, '-', num2str(flies(IIDN).flyNum), '-', num2str(flies(IIDN).blockNum)];
    
    %Prepare some phot stuff if requested
    %if doPerm == 1 && plotPermPhots == 1
        %Establish axis limits
        temp = [];
        for groupInd = 1:size(groupHyper,2)
            temp(1,groupInd) = nanmean( nanmax( groupHyper(groupInd).Phots ) );
            temp(2,groupInd) = nanmean( nanmin( groupHyper(groupInd).Phots ) );
        end
        temp(temp == 0) = NaN;
        %Put each phot into range
        thisGroupPhot = [];
        for groupInd = 1:size(groupHyper,2)
            if groupHyper(groupInd).As > 0
                thisGroupPhot{groupInd}(1,:) = nanmean( groupHyper(groupInd).Phots , 3 ); %Mean
                thisGroupPhot{groupInd}(2,:) = nanstd( groupHyper(groupInd).Phots , [], 3 ); %SD
                bounds = [-overVar(IIDN).ancillary.photodiodeSignalSign*nanmin( thisGroupPhot{groupInd}(1,:) ) / nanmin( temp(1,:) )...
                    overVar(IIDN).ancillary.photodiodeSignalSign*nanmax( thisGroupPhot{groupInd}(1,:) ) / nanmax( temp(1,:) )];
                thisGroupPhot{groupInd}(3,:) = nanmean( normalize(groupHyper(groupInd).Phots, 2, 'range', ...
                    [nanmin(bounds) nanmax(bounds)]) , 3); %Norm-mean (Note: Sign may be inverted due to bounds use)
                    %[-nanmin( thisGroupPhot{groupInd}(1,:) ) / nanmin( temp(1,:) ) nanmax( thisGroupPhot{groupInd}(1,:) ) / nanmax( temp(1,:) )]) , 3); %Norm-mean
                %In theory should normalise to the fraction of the all-group min/max this group reached
                thisGroupPhot{groupInd}(4,:) = nanstd( normalize(groupHyper(groupInd).Phots, 2, 'range', ...
                    [nanmin(bounds) nanmax(bounds)]) , [], 3); %Norm-SD
            end
        end
    %end

    for chanInd = 1:size(overChansOfInterestActive,2)
        
        %chanToPlot = chansOfInterestActive(chanInd);
        chanToPlot = overChansOfInterestActive(IIDN,chanInd); %New
        chanToPlotStr = ['Channel ',num2str(chanToPlot)];

        numFiguresNecessary = ceil( size(groupHyper,2) / 12 ); %Assumption of 3 rows of 4 columns

        h = [];
        for i = 1:numFiguresNecessary
            h(i) = figure;
        end

        a = 0;
        b = 1;
        figure( h(b) )
        for groupInd = 1:size(groupHyper,2)
            %subplot(ceil( size(groupHyper,2)/4 ) , 4 , groupInd) %Variable number of rows, 4 columns
            if a == 12
                %set(gcf,'Name', [chanToPlotStr, ' - hyperGroup/s ',num2str( groupInd - a ), ' : ', num2str(groupInd-1) ])
                set(gcf,'Name', [flyName, ' - ', chanToPlotStr, ' - hyperGroup/s ',num2str( groupInd - (a) ), ' : ', num2str(groupInd-1) ])
                a = 1;
                b = b + 1;
                figure( h(b) )
            else
                a = a + 1;
            end
            %figure( h(b) )
            subplot( 3 , 4 , a )

            hold on
            titleStr = [];

            %Collect
            plotData = [];
            if isempty(groupHyper(groupInd).Lists) ~= 1
                %"Cycles as subjects"
                %{
                for s = 1:size(groupHyper(groupInd).DatasCorr,3) %Originally iterated through 'subject' but this is now individual cycles
                    dataArray{s} = groupHyper(groupInd).DatasCorr(chanToPlot,:,s);
                end
                timeSeconds = {1/resampleFreq:1/resampleFreq:size(dataArray{1},2)/resampleFreq}; %Use 1st as exemplar for size
                %}
                %"Blocks as subjects"

                thisGroupBlockList = unique( groupHyper(groupInd).Lists(:,1) ); %Finds what blocks were associated with this group
                    %Note: This method may result in averages from wildly varying numbers of cycles per block, depending on the paradigm
                forcedMeanNormalisation = 0; 
                for s = 1:size(thisGroupBlockList,1) %where s is block
                    thisBlockNum = thisGroupBlockList(s); %Block in question
                    thisGroupBlockCoords = find( groupHyper(groupInd).Lists(:,1) == thisBlockNum ); %Index within hyperGroups
                    plotData{s} = nanmean( groupHyper(groupInd).DatasCorr(chanToPlot,:, thisGroupBlockCoords ) ,3); %Only pulls specified cycles (of specified channel)
                    %Normalise, if requested
                    if normaliseERPs == 1 || (normaliseERPs == 3 && isnan(groupHyper(groupInd).cycleColoursNum) == 1) %Added case for colour normalisation with multiple colours
                        plotData{s} = plotData{s} / overVar(IIDN).descriptive.overOnsetAmpMeans{chanToPlot}; 
                            %Normalise by mean of every detected peak
                        if normaliseERPs == 3
                            forcedMeanNormalisation = 1;
                        end
                    elseif normaliseERPs == 2
                        plotData{s} = plotData{s} / nanmax(plotData{s}); 
                            %Warning: Possibility that this will produce a vector, not a single value
                    elseif normaliseERPs == 3
                        %plotData{s} = plotData{s} / overColourMaxMeans{ groupHyper(groupInd).cycleColoursNum }(chanToPlot);
                        plotData{s} = plotData{s} / abs( overVar(IIDN).descriptive.overColourMaxMeans{ groupHyper(groupInd).cycleColoursNum }(chanToPlot) ); %Modified 9.35 to be abs
                            %Normalise by mean of peaks of this colour (May crash if called when colours weren't specified)     
                    end
                end
                timeSeconds = {1/resampleFreq:1/resampleFreq:size(plotData{1},2)/resampleFreq}; %Use 1st as exemplar for size
            %else
            %    %disp(['# hyperGroup ',num2str(groupInd),' - "',groupDescriptors{groupInd},'" could not be permutation analysed #'])
            %    failedGroups = [failedGroups,groupInd];
            %    timeSeconds = [];
            
                %Plot
                for s = 1:size( plotData,2 )
                    plot( plotData{s}, 'Color', groupColours(groupInd,:) )
                end
                xlim( [ 1 , size(plotData{1},2) ] ) %Will fail on empty
                if forcedYLims == 1 && normaliseERPs == 3 %Only supported for colour-normalisation currently
                    ylim([-2,2])
                end
                
                %if doPerm == 1 && plotPermPhots == 1
                    yLims = get(gca,'YLim');
                    temp = [];
                    temp(1,:) = thisGroupPhot{groupInd}(3,:)*(yLims(2)*0.25); %Mean
                    temp(2,:) = thisGroupPhot{groupInd}(4,:)*(yLims(2)*0.25); %SD
                    plot( temp(1,:) )
                    groupPhotShadeCoordsX = [1:1:size(thisGroupPhot{groupInd},2),size(thisGroupPhot{groupInd},2):-1:1];
                    groupPhotShadeCoordsY = [temp(1,:)+temp(2,:),flip(temp(1,:)-temp(2,:))]; %+- SEM
                    %groupPhotShadeCoordsY = groupPhotShadeCoordsY - groupPhotShadeCoordsY(1); %Offset start
                    fill(groupPhotShadeCoordsX, groupPhotShadeCoordsY, [1.0,0.647,0.0]) %Error shading
                        %Note: Scale and shading of photodiode signal is for display purposes only
                    alpha(0.15)
                %end

            end
            %titleStr = [ groupDescriptors{groupInd},' (J:', num2str(groupJitters(groupInd)),';n=', num2str(size(plotData,2)),' blocks)'];
            titleStr = [ groupDescriptors{groupInd},char(10),'(J:', num2str(groupJitters(groupInd)),'; n=', num2str(size(plotData,2)),' blocks, ',num2str(groupHyper(groupInd).As),' total cycles)'];
            if forcedMeanNormalisation == 1
                titleStr = [titleStr,char(10),'(Forced mean norm.)'];
            end
            title( titleStr )


            hold off
        end
        %set(gcf,'Name', [chanToPlotStr, ' - hyperGroup/s ',num2str( groupInd - (a-1) ), ' : ', num2str(groupInd) ])
        set(gcf,'Name', [flyName, ' - ', chanToPlotStr, ' - hyperGroup/s ',num2str( groupInd - (a-1) ), ' : ', num2str(groupInd) ])

    end
end
clear groupHyper %Prevent cross-contamination
%---------------------
%%
%#######

%Average MMNs
figure
figStr = [];
for chanInd = 1:size(overChansOfInterestActive,2)
    %%chanToPlot = chansOfInterestActive(chanInd); %Old
    %subplot(size(chansOfInterest,2),1,chanInd) %Rows
    subplot(1, size(overChansOfInterestActive,2),chanInd) %Cols

    thisTitleStr = [];

    for mmnInd = 1:size(mmnTargets,1)
        firstGroupToPlot = mmnTargets(mmnInd,1);
        secondGroupToPlot = mmnTargets(mmnInd,2);
        
        %Calculate for fly
        flyFirstGroupMeanData = [];
        flySecondGroupMeanData = [];
        flyMMNData = [];
        for fly = 1:size(overVar,2)
            chanToPlot = overChansOfInterestActive(fly,chanInd); %New
            if isempty(overVar(fly).groupHyper(firstGroupToPlot).Lists) ~= 1 && isempty(overVar(fly).groupHyper(secondGroupToPlot).Lists) ~= 1
                firstGroupMean = nanmean(overVar(fly).groupHyper(firstGroupToPlot).Datas(chanToPlot,:,:),3);
                secondGroupMean = nanmean(overVar(fly).groupHyper(secondGroupToPlot).Datas(chanToPlot,:,:),3);
                flyFirstGroupMeanData(fly,:) = firstGroupMean;
                flySecondGroupMeanData(fly,:) = secondGroupMean;

                mmnData = firstGroupMean - secondGroupMean;
                flyMMNData(fly,:) = mmnData;
            else
                if fly ~= 1
                    firstGroupMean = [];
                    secondGroupMean = [];
                    mmnData = [];
                    flyFirstGroupMeanData(fly,:) = NaN;
                    flySecondGroupMeanData(fly,:) = NaN;
                    flyMMNData(fly,:) = NaN;
                else
                    firstGroupMean = [];
                    secondGroupMean = [];
                    mmnData = [];
                    flyFirstGroupMeanData(fly,1:captureWindowSize) = NaN;
                    flySecondGroupMeanData(fly,1:captureWindowSize) = NaN;
                    flyMMNData(fly,1:captureWindowSize) = NaN;
                    ['#- Warning: Failure in first fly data; Array size guessed -#']
                end
            end
            firstGroupMean=[];secondGroupMean=[];mmnData=[];
        end
        
        %Average (and SEM) over fly
        flyFirstGroupMeanDataGrandAv = nanmean(flyFirstGroupMeanData,1);
        flyFirstGroupMeanDataGrandSEM = nanstd(flyFirstGroupMeanData,1) / sqrt(size(flyFirstGroupMeanData,1));
        flySecondGroupMeanDataGrandAv = nanmean(flySecondGroupMeanData,1);
        flySecondGroupMeanDataGrandSEM = nanstd(flySecondGroupMeanData,1) / sqrt(size(flySecondGroupMeanData,1));
        flyMMNDataGrandAv = nanmean(flyMMNData,1);
        %flyMMNDataGrandSEM = nanstd(flyMMNData,1) / sqrt(size(flyMMNData,1));
        flyMMNDataGrandSEM = nanstd(flyMMNData,1) / sqrt( nansum( isnan(flyMMNData(:,1)) ~= 1 ) );

        %Plot
        plot(flyFirstGroupMeanDataGrandAv, 'Color', groupColours(firstGroupToPlot,:)) %Source 1
        hold on
        plot(flySecondGroupMeanDataGrandAv, 'Color', groupColours(secondGroupToPlot,:)) %Source 2

        plot(flyMMNDataGrandAv, ':', 'LineWidth', 2, 'Color', nanmean( [groupColours(firstGroupToPlot,:) ; groupColours(secondGroupToPlot,:) ] , 1 ) ) %Plot MMN in colour that is average of source groups

        %Text

        safePosS = linspace(0.2*size(flyMMNDataGrandAv,2),0.8*size(flyMMNDataGrandAv,2),size(mmnTargets,1));            
        safePos = floor(safePosS(mmnInd));
        %text(safePos+targInd,groupDataAvs{targInd}(targInd+safePos), ['G:',num2str(targInd),',C:',num2str(chanToPlot)], 'Color', 'r')
        text(safePos,flyFirstGroupMeanDataGrandAv(safePos), ['First - G:',num2str(firstGroupToPlot)], 'Color', 'r')
        text(safePos,flySecondGroupMeanDataGrandAv(safePos), ['Second - G:',num2str(secondGroupToPlot)], 'Color', 'r')
        text(safePos,flyMMNDataGrandAv(safePos), ['MMN - Gs: ',num2str(mmnTargets(mmnInd,:))], 'Color', 'r')

        %Title support
        thisTitleStr = [thisTitleStr, '"',groupDescriptors{firstGroupToPlot},'"(G:',num2str(firstGroupToPlot),')',char(10),' - ',char(10),'"',groupDescriptors{secondGroupToPlot},'"(G:',num2str(secondGroupToPlot),') , '];
        if chanInd == size(overChansOfInterestActive,2)
            figStr = [figStr, 'G', num2str(firstGroupToPlot), ' - G',num2str(secondGroupToPlot), ' -- '];
        end
        
        %Shadings
        for i = 1:3
            if i == 1
                thisShadDataAv = flyFirstGroupMeanDataGrandAv; thisShadDataSEM = flyFirstGroupMeanDataGrandSEM; thisShadColour = groupColours(firstGroupToPlot,:); thisAlpha = 0.05;
            elseif i == 2
                thisShadDataAv = flySecondGroupMeanDataGrandAv; thisShadDataSEM = flySecondGroupMeanDataGrandSEM; thisShadColour = groupColours(secondGroupToPlot,:); thisAlpha = 0.05;
            elseif i == 3
                thisShadDataAv = flyMMNDataGrandAv; thisShadDataSEM = flyMMNDataGrandSEM; thisShadColour = nanmean( [groupColours(firstGroupToPlot,:) ; groupColours(secondGroupToPlot,:) ] , 1 ); thisAlpha = 0.15;
            end
            groupPhotShadeCoordsX = [1:1:size(thisShadDataAv,2),size(thisShadDataAv,2):-1:1];
            groupPhotShadeCoordsY = [thisShadDataAv+thisShadDataSEM,flip(thisShadDataAv-thisShadDataSEM)]; %+- SEM
            %%groupPhotShadeCoordsY = groupPhotShadeCoordsY - groupPhotShadeCoordsY(1); %Offset start
            fill(groupPhotShadeCoordsX, groupPhotShadeCoordsY, [thisShadColour]) %Error shading
                %Note: Scale and shading of photodiode signal is for display purposes only
            alpha(thisAlpha)
        end
        
        %Individual flies (just for the MMN itself)
        for i = 1:size(flyMMNData,1)
            thisFlyUniqueNumber = [];
            for fly = 1:size(uniqueFlies,1)
                if nansum(uniqueFlies{fly} == [dataListStruct.flyName(i,:),'-',num2str(dataListStruct.flyNum(i,:))]) == size(uniqueFlies{fly},2)
                    %BOOTLEG STRING MATCHING CODE
                    thisFlyUniqueNumber = fly;
                end
            end
            plot(flyMMNData(i,:), ':', 'LineWidth', 2, 'Color', nanmean( [groupColours(firstGroupToPlot,:) ; groupColours(secondGroupToPlot,:) ] , 1 )) %Colours consistent with group
            plot(flyMMNData(i,:), '--', 'LineWidth', 2, 'Color', flyColours(thisFlyUniqueNumber,:))
        end

    end
    %%ylim(pulledYLims); %Currently disabled
    %ylim([-400, 400]);
    %line([ captureWindowSize*(-captureWindowGeometry(1)),captureWindowSize*(-captureWindowGeometry(1)) ],[-300,300], 'LineStyle', ':', 'Color', 'k') %Stimulus onset (more or less)
    if isempty(fixedPhotodiodeScale) ~= 1
        line([ captureWindowSize*(-captureWindowGeometryActive(1)),captureWindowSize*(-captureWindowGeometryActive(1)) ],[-fixedPhotodiodeScale,fixedPhotodiodeScale], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
    else
        line([ captureWindowSize*(-captureWindowGeometryActive(1)),captureWindowSize*(-captureWindowGeometryActive(1)) ],[-300,300], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
    end
    %figTitle = ['MMN of "',groupDescriptors{firstGroupToPlot},'"(G:',num2str(firstGroupToPlot),') subtracted from "',groupDescriptors{secondGroupToPlot},'"(G:',num2str(secondGroupToPlot),') at channel ',num2str(chanToPlot)];
    %figTitle = ['MMN of ',thisTitleStr,' at Channel ',num2str(chanToPlot)];
    figTitle = ['MMN of ',thisTitleStr, char(10),'Ch: ',chansOfInterestStr{chanInd}];
    %figTitleProc = [ repmat(' ', chanInd-1, size(figTitle,2)) ; figTitle ; repmat(' ', size(overChansOfInterestActive,2)-chanInd, size(figTitle,2)) ];
    %title(figTitleProc)
    title(figTitle)

end
%figStr = [figStr, 'C ', num2str(chansOfInterestActive)]; %Supplement figStr with channel data
%figStr = [figStr, 'C ', num2str( unique(overChansOfInterestActive(:,1))' ), ' vs ',num2str( unique(overChansOfInterestActive(:,2))' )]; %Not valid in cases of more than two channels of interest

figStr = [figStr,'_',rerefIndex{rerefMode}]; %Add reref info to filename
thisFigName = 'GrandAvMMN';
set(gcf,'Name',[thisFigName]);

%###########
%Save figure
if saveFigs == 1
    try
        savePlot(saveName,thisFigName,figStr)
    catch 
        ['-# Alert: Failure to save plot #-']
    end
end
%###########

%#######

%Permutation statistics

if doPerm == 1
    addpath(genpath(ftPath))
    
    %{
    (Removed this separate normalisation system)
    if normalisePerms == 2
        %Pre-calculate some normalisation values if normalising perms
        flyNormValues = []; %Will hold the fly-specific values to normalise to
        for s = 1:size(overVar,2)
            maxList = [];
            for groupInd = 1:size(overVar(s).overPerm,2)
                temp = [];
                for i = 1:size(overVar(s).overPerm(groupInd).permStruct.trial,2)
                    temp(i,:) = overVar(s).overPerm(groupInd).permStruct.trial{i};
                end
                %Apply post-hoc forced correction if so requested
                if postHocCorrectPerms == 1
                    temp(i,:) = temp(i,:) - temp(i,1);
                elseif postHocCorrectPerms == 2
                    temp(i,:) = temp(i,:) - temp(i,floor(captureWindowSize*(-captureWindowGeometry(1)))); 
                end
                maxList = [maxList, nanmax(nanmean(temp,1))]; %Append the max of the mean ERP to the list
                    %This list will be the same size as the number of hyperGroups
            end
            flyNormValues = [flyNormValues, nanmean(maxList)]; %"Normalise flies by the mean of their max mean response to each group"
                %Optimally this will preserve relative positions, such that a group that consistently elicits a smaller ERP will be closer to 0 and a group that elicits a large response will be larger than 1, etc
        end
    end
    %}

    preCfg = [];
    preCfg.keeptrials = 'yes';
    
    %Calculate time statistics for individual channel/s and groups 
    %chanToPlot = 16;
    %chanToPlot = chansOfInterest(1);
    %chanToPlotStr = ['Channel ',num2str(chanToPlot)];
    
    flyOverPerm = struct; %Will collate permStruct data from individual flies
        %In the individual section, this is permStruct
    failedGroups = [];
    for groupInd = 1:size(overVar(1).overPerm,2) %Use first dataset as exemplar for how many perms were calculated
        flyPermStruct = [];
        
        for chanInd = 1:size(overChansOfInterestActive,2)
            %%chanToPlot = chansOfInterestActive(chanInd); %Old
            %%chanToPlotStr = ['Channel ',num2str(chanToPlot)]; %Old

            dataArray = [];
            %if isempty(groupHyper(groupInd).Lists) ~= 1
            if grandSubjectType == 1
                %"Blocks as subjects"
                a = 1;
                for IIDN = 1:size(overVar,2)
                    if isempty( overVar(IIDN).groupHyper(groupInd).Lists ) ~= 1
                        %groupHyper = overVar(IIDN).groupHyper;
                        chanToPlot = overChansOfInterestActive(IIDN,chanInd);
                        %thisGroupBlockList = unique( groupHyper(groupInd).Lists(:,1) ); %Finds what blocks were associated with this group
                        thisGroupBlockList = unique( overVar(IIDN).groupHyper(groupInd).Lists(:,1) ); %Finds what blocks were associated with this group
                            %Note: This method may result in averages from wildly varying numbers of cycles per block, depending on the paradigm
                        for s = 1:size(thisGroupBlockList,1)
                            thisBlockNum = thisGroupBlockList(s); %Block in question
                            thisGroupBlockCoords = find( overVar(IIDN).groupHyper(groupInd).Lists(:,1) == thisBlockNum ); %Index within hyperGroups
                            %dataArray{s} = nanmean( groupHyper(groupInd).DatasCorr(chanToPlot,:, thisGroupBlockCoords ) ,3); %Only pulls specified cycles
                            dataArray{a} = nanmean( overVar(IIDN).groupHyper(groupInd).DatasCorr(chanToPlot,:, thisGroupBlockCoords ) ,3); %Only pulls specified cycles
                                %Note switched iterator
                            a = a + 1;    
                        end
                    end
                end
                %clear groupHyper
            else
                %"Flies as subjects"
                for s = 1:size(overVar,2) %Flies
                    chanToPlot = overChansOfInterestActive(s,chanInd); %New
                    chanToPlotStr = ['Channel ',num2str(chanToPlot)];
                    preDataArray = [];
                    for i = 1:size(overVar(s).overPerm(groupInd).permStruct(chanInd).trial,2) %Blocks (currently)
                        if isempty(overVar(s).overPerm(groupInd).permStruct(chanInd).trial) ~= 1
                            preDataArray(i,:) = overVar(s).overPerm(groupInd).permStruct(chanInd).trial{i}; %Will almost certainly crash if dimension mismatch exists
                            %Apply post-hoc forced correction if so requested
                            if postHocCorrectPerms == 1
                                preDataArray(i,:) = preDataArray(i,:) - preDataArray(i,1);
                            elseif postHocCorrectPerms == 2
                                preDataArray(i,:) = preDataArray(i,:) - preDataArray(i,floor(captureWindowSize*(-captureWindowGeometryActive(1)))); 
                            end
                        else
                            if i ~= 1
                                preDataArray(i,:) = NaN; %Will cause big issues likely if this is first row
                                %failedGroups = [failedGroups ; groupInd,s]; %Group, Fly said group failed for
                            else
                                ['## Alert: Cannot (easily) nanify first row of preDataArray ##']
                                crash = yes
                            end
                        end
                    end
                    %{
                    %(See above consolidation of normalisation)
                    if normalisePerms == 2
                        preDataArray = preDataArray / flyNormValues(s); %Normalise by earlier calculated value
                    end
                    %}
                    dataArray{s} = nanmean(preDataArray,1); %Cells in dataArray now represent average of fly for each hyperGroup
                end
            end
            %Clean dataArray
            %a = 1; %Independent iterator needed because if deletion occurs, s will become desynchronised
            for s = size(overVar,2):-1:1 %Reverse iterating because inline deletion
                if isempty(dataArray{s}) == 1 || nansum(isnan(dataArray{s}) == 1) == size(dataArray{s},2)
                    dataArray(s) = [];
                    disp(['## Fly ',num2str(s),' lacked data for hyperGroup ',num2str(groupInd),' and was removed from analysis for said group ##'])
                    failedGroups = [failedGroups ; groupInd,s]; %Group, Fly said group failed for 
                end
                %a = a + 1;
            end
            if isempty( dataArray ) ~= 1 && nansum( cellfun('isempty',dataArray) == 0 ) > 0
                %timeSeconds = {1/generalStruct.resampleFreq:1/generalStruct.resampleFreq:size(dataArray{1},2)/generalStruct.resampleFreq}; %Use 1st as exemplar for size
                timeSeconds = {1/generalStruct.resampleFreq:1/generalStruct.resampleFreq:size(dataArray{find( cellfun('isempty',dataArray) == 0 , 1 , 'first' )},2)/generalStruct.resampleFreq}; 
                    %Use first non-zero entry of dataArray
            else
                timeSeconds = {NaN};
                disp(['-# Caution: No non-zero data groups existed for perm comp group ',num2str(groupInd),' #-'])
            end
            %else
            %    %disp(['# hyperGroup ',num2str(groupInd),' - "',groupDescriptors{groupInd},'" could not be permutation analysed #'])
            %    failedGroups = [failedGroups,groupInd];
            %    timeSeconds = [];
            %end

            flyPermStruct(chanInd).trial = dataArray;
            flyPermStruct(chanInd).label = {chanToPlotStr}; %In original code this was three-rowed, to account for the channel positions, but currently this is one at a time
            flyPermStruct(chanInd).fsample = generalStruct.resampleFreq;
            flyPermStruct(chanInd).time = repmat(timeSeconds,[1 size(dataArray,2)]);
            if isempty( dataArray ) ~= 1 && nansum( cellfun('isempty',dataArray) == 0 ) > 0
            %if isempty(groupHyper(groupInd).Lists) ~= 1 %Flawed implementation of individual method
                flyPermStruct(chanInd).output = ft_timelockanalysis(preCfg, flyPermStruct(chanInd)); %Will probs fail if all flies lack data for a group
            else
                flyPermStruct(chanInd).output = [];
            end
            flyPermStruct(chanInd).Descriptor = overVar(1).overPerm(groupInd).permStruct(chanInd).Descriptor; %Pull descriptor from first fly
                %Not executable currently
            
        end

        flyOverPerm(groupInd).flyPermStruct = flyPermStruct; %Save data for overuse
    end

    %Post-hoc reporting of any failures
    if size(failedGroups,1) > 0
        %disp(['# hyperGroup/s ',num2str(failedGroups),' could not be permutation analysed #'])
        ['# Some hyperGroups could not be permutation analysed with all flies data #']
    end
    

    %Calculate stats between groups
    if grandSubjectType == 1 
        disp([char(10),'-- Calculating permutation statistics between ',num2str(size(permCompGroups,1)),' combinations of groups for averaged blocks --',char(10)])
    else
        disp([char(10),'-- Calculating permutation statistics between ',num2str(size(permCompGroups,1)),' combinations of groups for averaged flies --',char(10)])
    end
    %Invariant
    cfg                  = [];
    cfg.method           = 'montecarlo'; % use the Monte Carlo Method to calculate the significance probability
    cfg.latency          = 'all';
    cfg.statistic        = 'indepsamplesT'; % use the independent samples T-statistic as a measure to evaluate the effect at the sample level
    cfg.correctm         = 'cluster';
    cfg.neighbours       = []; %Empty, to force usage of temporal clusters
    cfg.clusteralpha     = 0.05;       % alpha level of the sample-specific test statistic that will be used for thresholding
    cfg.clusterstatistic = 'maxsum';   % test statistic that will be evaluated under the permutation distribution.
    cfg.tail             = 0;          % -1, 1 or 0 (default = 0); one-sided or two-sided test
    cfg.alpha            = permAlpha;      % alpha level of the permutation test
    cfg.numrandomization = permRandomisations;        % number of draws from the permutation distribution (Note: value of 1000 is arbitrary currently)
    cfg.correcttail      = 'prob';

    overStatStruct = struct;
    for permInd = 1:size(permCompGroups,1)
        cfg.design = [];
        groupOne = permCompGroups(permInd,1);
        groupTwo = permCompGroups(permInd,2);
        groupOneDesc = flyOverPerm(groupOne).flyPermStruct.Descriptor;
        groupTwoDesc = flyOverPerm(groupTwo).flyPermStruct.Descriptor;
        
        overStatStruct(permInd).compGroups = [groupOne , groupTwo];
        %%overStatStruct(permInd).compGroupsDesc = [{groupDescriptors{groupOne}} , {groupDescriptors{groupTwo}} ];
        overStatStruct(permInd).compGroupsDesc = [{groupOneDesc} , {groupTwoDesc}];

        for chanInd = 1:size(overChansOfInterestActive,2)
            %%chanToPlot = chansOfInterestActive(chanInd); %Currently disabled
            %Variant
            n_fc  = size(flyOverPerm(groupOne).flyPermStruct(chanInd).trial,2);
            n_fic = size(flyOverPerm(groupTwo).flyPermStruct(chanInd).trial,2);
            if n_fc > 0 && n_fic > 0
                cfg.design = [ones(1,n_fic), ones(1,n_fc)*2]; %*2 because that is identity of group two
                [stat] = ft_timelockstatistics(cfg, flyOverPerm(groupOne).flyPermStruct(chanInd).output, flyOverPerm(groupTwo).flyPermStruct(chanInd).output);
            else
                cfg.design = [];
                [stat] = [];
                disp(['-# Perm ',num2str(permInd),' not calculable due to one or more empty groups #-'])
            end
            overStatStruct(permInd).stat{chanInd} = stat;
            %%disp(['- Perm ',num2str(permInd),' - "',groupOneDesc,'" vs "',groupTwoDesc, '" calculated - (Ch ',num2str(chanToPlot),')', char(10)])
            %%disp(['- Perm ',num2str(permInd),' - "',groupDescriptors{groupOne},'" vs "',groupDescriptors{groupTwo}, '" calculated -', char(10)])
            disp(['- Perm ',num2str(permInd),' - "',groupOneDesc,'" vs "',groupTwoDesc, '" calculated - (Ch ',num2str(NaN),')', char(10)]) %Cbf dealing with variable chans atm
        end
    end

    %%
    
    %Plot data and signific.
        %Can probably be run post-hoc, but not with new permCompGroups
    for chanInd = 1:size(overChansOfInterestActive,2)
        %%chanToPlot = chansOfInterestActive(chanInd);
        figure

        figStr = [];
        gcaList = []; %Will hold the figs for YLim purposes
        for permInd = 1:size(permCompGroups,1)
            if size(permCompGroups,1) < 4
                subplot(1,size(permCompGroups,1),permInd) %1 row, <number of comparison groups> columns
            else
                subplot(ceil( size(permCompGroups,1)/4 ) , 4 , permInd) %Variable number of rows, 4 columns
            end
            if isempty( flyOverPerm( permCompGroups(permInd,1) ).flyPermStruct(chanInd).trial ) ~= 1 && isempty( flyOverPerm( permCompGroups(permInd,2) ).flyPermStruct(chanInd).trial ) ~= 1 
                %Source data
                plotData = [];
                for i = 1:size(permCompGroups,2)
                    plotData{i} = [];
                    thisPermCompGroup = permCompGroups(permInd,i);
                    for s = 1:size(flyOverPerm(thisPermCompGroup).flyPermStruct(chanInd).trial,2)
                        plotData{i} = [plotData{i}; flyOverPerm(thisPermCompGroup).flyPermStruct(chanInd).trial{s}]; 
                        plot( flyOverPerm(thisPermCompGroup).flyPermStruct(chanInd).trial{s}, 'Color', groupColours(thisPermCompGroup,:) ) %Note: Will probably fail if not cell
                        hold on
                    end
                end

                %Means and things
                meanData = [];
                semData = [];
                for i = 1:size(permCompGroups,2)
                    thisPermCompGroup = permCompGroups(permInd,i);
                    meanData{i} = nanmean(plotData{i},1);
                    semData{i} = nanstd(plotData{i},1) / sqrt(size(plotData{i},1));
                    plot( meanData{i}, 'Color', groupColours(thisPermCompGroup,:), 'LineWidth', 2 )
                    hold on
                    shadeCoordsX = [1:1:size(meanData{i},2),size(meanData{i},2):-1:1];
                    shadeCoordsY = [meanData{i}+semData{i},flip(meanData{i}-semData{i})];
                    fill(shadeCoordsX, shadeCoordsY, groupColours(thisPermCompGroup,:)) %Error shading
                    alpha(0.15)
                end

                %Sig
                if isempty( overStatStruct(permInd).stat{chanInd} ) ~= 1
                    p_binary = double(overStatStruct(permInd).stat{chanInd}.prob > overStatStruct(permInd).stat{chanInd}.cfg.alpha); %Removed incorrect row specification
                    p_binary = p_binary*255; %Manual scaling to ensure correct orientation
                else

                end
                currYLims = get(gca,'YLim');
                imHeight = ceil(abs(currYLims(1)-currYLims(2))*0.1);
                sigPlotImage = repmat(p_binary,imHeight,1);
                hImage = image(sigPlotImage , 'XData', [0 , size(sigPlotImage,2)] , 'YData', ...
                    [nanmax(get(gca,'YLim')) + imHeight*0.25 , nanmax(get(gca,'YLim')) + imHeight*0.25] ); 
                colormap gray;
                set(hImage,'AlphaData', 0.25)

                %Lims and things
                xlim([0 , size(sigPlotImage,2)])
                %{
                title([ groupDescriptors{permCompGroups(permInd,1)},' (J:', num2str(groupJitters(permCompGroups(permInd,1))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,1)).permStruct.trial,2)),')', char(10), ...
                    ' vs ', char(10), ...
                    groupDescriptors{permCompGroups(permInd,2)},' (J:', num2str(groupJitters(permCompGroups(permInd,2))),'; n= ', num2str(size(overPerm(permCompGroups(permInd,2)).permStruct.trial,2)),')', char(10), ...
                    '[p < ', num2str(overStatStruct(permInd).stat.cfg.alpha),']' ])
                %}
                    %Note: If descriptors in saved data differ from current settings this may cause an issue
                titleStr = [ overStatStruct(permInd).compGroupsDesc{1},' (N= ', num2str(size(flyOverPerm(permCompGroups(permInd,1)).flyPermStruct(chanInd).trial,2)),')', char(10), ...
                    ' vs ', char(10), ...
                    overStatStruct(permInd).compGroupsDesc{2},' (N= ', num2str(size(flyOverPerm(permCompGroups(permInd,2)).flyPermStruct(chanInd).trial,2)),')', char(10), ...
                    '[p < ', num2str(overStatStruct(permInd).stat{chanInd}.cfg.alpha),']' ];
                if useAutoList == 1
                    titleStr = [titleStr ,char(10), 'List: ', listToUse];
                end
                if normaliseERPs ~= 0
                    titleStr = [titleStr, char(10), normaliseIndex{normaliseERPs}];
                else
                    titleStr = [titleStr, char(10), '(Not normalised)'];
                end
                if postHocCorrectPerms == 1
                    titleStr = [titleStr, char(10),'(Traces post-hoc corrected to start at 0)'];
                elseif postHocCorrectPerms == 2
                    titleStr = [titleStr, char(10),'(Traces post-hoc corrected to be 0 at stimulus onset)'];
                end
                title(titleStr);

                %line([ captureWindowSize*(-captureWindowGeometry(1)),captureWindowSize*(-captureWindowGeometry(1)) ],[-300,300], 'LineStyle', ':', 'Color', 'k') %Stimulus onset (more or less)
                if isempty(fixedPhotodiodeScale) ~= 1 %&& normalisePerms == 0
                    line([ captureWindowSize*(-captureWindowGeometryActive(1)),captureWindowSize*(-captureWindowGeometryActive(1)) ],[-fixedPhotodiodeScale,fixedPhotodiodeScale], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
                else
                    line([ captureWindowSize*(-captureWindowGeometryActive(1)),captureWindowSize*(-captureWindowGeometryActive(1)) ],[-nanmax(get(gca,'YLim')),nanmax(get(gca,'YLim'))], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
                end

                gcaList(permInd) = gca;
                figStr = [figStr, 'G',num2str(permCompGroups(permInd,1)),'vsG',num2str(permCompGroups(permInd,2)),'--'];
            else
                titleStr = [ overStatStruct(permInd).compGroupsDesc{1},' (N= ', num2str(size(flyOverPerm(permCompGroups(permInd,1)).flyPermStruct(chanInd).trial,2)),')', char(10), ...
                    ' vs ', char(10), ...
                    overStatStruct(permInd).compGroupsDesc{2},' (N= ', num2str(size(flyOverPerm(permCompGroups(permInd,2)).flyPermStruct(chanInd).trial,2)),')'];
                title(titleStr);
            end
        end
        %figStr = [figStr, 'C', num2str(chanToPlot), ' ', num2str( size(permCompGroups,1) ), ' comparisons'];
        figStr = [figStr, 'C', num2str(NaN), ' ', num2str( size(permCompGroups,1) ), ' comparisons']; %See above cbf
        figStr = [figStr,'_',rerefIndex{rerefMode}]; %Add reref info to filename
        %Pull max lims
        %try
        if size(permCompGroups,1) > 1
            yl = cell2mat(get(gcaList, 'Ylim'));
            ylnew = [min(yl(:,1)) max(yl(:,2))];
            set(gcaList, 'YLim', ylnew)
        else
            ylim('auto')
        end
        %catch
        %    ['## Unspecified error while attempting to apply uniform Y-limit to permutation statistics plot ##']
        %end
        %thisFigName = ['GrandAvPermComps - Ch ',num2str(chanToPlot)];
        thisFigName = ['GrandAvPermComps - Ch ',chansOfInterestStr{chanInd}];
        if useAutoList == 1
            set(gcf,'Name',[listToUse,' - ', thisFigName]);
        else
            set(gcf,'Name',['GrandAv - ', thisFigName]);
        end


        %###########
        %Save figure
        if saveFigs == 1
            try
                savePlot(saveName,thisFigName,figStr)
            catch 
                ['-# Alert: Failure to save plot #-']
            end
        end
        %###########
    end
    
    %%
    
    rmpath(genpath(ftPath)) 
    
end

%#######
acknowledged = 0;
%%
%parakeet

%Peak to Trough calculations
superOverFlyPTTStruct = struct;
for chanInd = 1:size(overChansOfInterestActive,2)
 
    figure
    hasWarned = 0;
    %%chanToPlot = chansOfInterestActive(chanInd); %Old
   
    titleStr = [];
    figStr = []; %Similar, but for fig autosaving
    vsStr = [repmat({' vs '},1,size(groupTargets,2)-1),{''}]; %Assembles a correct number of ' vs 's
    
    overFlyPTTs = [];
    overFlyPTTInds = [];
    overMaxMin = [0,0]; %Will hold the record largest and smallest values for shared axis purposes
    %figure
    for targInd = 1:size(targsOfInterest,2)%size(groupTargets,2)
        targToPlot = targsOfInterest(targInd); %Only used for interfaces with hyperData structures (since non-linear)
        if hidePTTLocsSubplots ~= 1
            subplot(4,size(targsOfInterest,2),targInd) %4 rows; Individual data, bar plot of PTTs, bar plots of peak/trough inds
        else
            subplot(2,size(targsOfInterest,2),targInd) %2 rows; Individual data and bar plot of PTTs
        end

        flyData = [];
        flyPeakTroughAmps = []; %Indexes of peak and trough respectively
        flyPeakTroughInds = []; %Indexes of peak and trough respectively
        flyPTTs = []; %Peak to Trough, per fly
        sumN = 0; %Tracks the total underlying number of cycles for this group "I sumN Blue Eyes White Dragon and place it face up in Attack mode"
        for fly = 1:size(overVar,2)
            chanToPlot = overChansOfInterestActive(fly,chanInd); %New
            
            plotData = [];
            groupAvData = [];
            if isempty(overVar(fly).groupHyper(targToPlot).Lists) ~= 1 && length( overVar(fly).groupHyper(targToPlot).Lists ) ~= 0
                %Assemble 3D and 2D matrices
                if showCorrected == 0
                    plotData = overVar(fly).groupHyper(targToPlot).Datas(chanToPlot,:,:); %Uncorrected
                else
                    plotData = overVar(fly).groupHyper(targToPlot).DatasCorr(chanToPlot,:,:); %Corrected
                end
                %{
                plotDataFlat = [];
                for i = 1:size(plotData,3)
                    plotDataFlat(i,:) = plotData(:,:,i);
                end
                %}
                %Apply post-hoc subsampling if requested
                if doPostHocSubSampling == 1
                    if size(overVar(fly).groupHyper(targToPlot).Datas(chanToPlot,:,:),3) >=  size(overVar(fly).groupHyper(postHocSubSampleTarget).Datas(chanToPlot,:,:),3)
                        plotData = plotData(:,:, [randsample( size(overVar(fly).groupHyper(targToPlot).Datas,3) ,  size(overVar(fly).groupHyper(postHocSubSampleTarget).Datas,3) )] );
                            %Subsample according to size of postHocSubSampleTarget
                    else
                        plotData = nan( 1 , size(overVar(fly).groupHyper(targToPlot).Datas,2),1 ); %Experimental wiping code
                        if hasWarned ~= 1 %Simple console spam protection
                            disp(['#- One or more groups contained less data than the postHocSubSampleTarget (G',num2str(postHocSubSampleTarget),') -#'])
                            hasWarned = 1;
                        end
                    end
                end
                
                sumN = sumN + size(plotData,3);

                %Means etc
                groupAvData = nanmean(plotData(1,:,:) ,3); %Row index of 1 because channel specification done earlier
                %groupDataSDs{targInd} = nanstd(groupPlotDatas{targInd}(1,:,:), [] ,3);
                forcedMeanNormalisation = 0; 
                %Normalise if requested
                if normaliseERPs == 1 || ( normaliseERPs == 3 && isnan(overVar(fly).groupHyper(targToPlot).cycleColoursNum) == 1 )
                    groupAvData = groupAvData / overVar(fly).descriptive.overOnsetAmpMeans{chanToPlot}; %Normalise by mean of every detected peak
                    if normaliseERPs == 3
                        forcedMeanNormalisation = 1;
                    end
                elseif normaliseERPs == 2
                    groupAvData = groupAvData / nanmax(abs(groupAvData)); %Normalise by own max of plot
                elseif normaliseERPs == 3
                    %groupAvData = groupAvData / overVar(fly).descriptive.overColourMaxMeans{ overVar(fly).groupHyper(targToPlot).cycleColoursNum }(chanToPlot); %Normalise by mean of peaks of this colour (May crash if called when colours weren't specified)     
                    groupAvData = groupAvData / abs( overVar(fly).descriptive.overColourMaxMeans{ overVar(fly).groupHyper(targToPlot).cycleColoursNum }(chanToPlot) ); %9.35
                end

                flyData(fly,:) = groupAvData; %Will only work as long as groupAvData has 1 row

                %Calculate Peak to Trough distance per fly, based on this data
                if enforcePTTPostStimulus == 1
                    onsetPosition = ceil( overVar(fly).ancillary.captureWindowSize*(-overVar(fly).ancillary.captureWindowGeometryActive(1)) );
                else
                    onsetPosition = 1;
                end
                if enforcePTTPrecedence == 1
                    temp = [];
                    %[~, temp(1)] = nanmin(groupAvData); %Whole trace (Susceptible to first element being min/max)
                    %[~, temp(2)] = nanmax(groupAvData);
                    [~, temp(1)] = nanmin( groupAvData( onsetPosition:end ) ); %Force post stim onset
                    [~, temp(2)] = nanmax( groupAvData( onsetPosition:end ) );
                    temp = temp + onsetPosition - 1; %Put back in correct reference frame
                    %QA
                    if nansum( temp == 1 ) > 0
                        ['## Alert: One or more PTT indices equal to start ##']
                        crash = yes %Very high chance of oversensitivity
                    end
                    %Enforce
                    %[peakAmp, peakInd] = nanmax( groupAvData( 1:temp(pttPrecedencePerChan(chanInd)) ) );
                    %[troughAmp, troughInd] = nanmin( groupAvData( 1:temp(pttPrecedencePerChan(chanInd)) ) );
                    [peakAmp, peakInd] = nanmax( groupAvData( onsetPosition:temp(pttPrecedencePerChan(chanInd)) ) );
                    [troughAmp, troughInd] = nanmin( groupAvData( onsetPosition:temp(pttPrecedencePerChan(chanInd)) ) );
                    %peakInd = peakInd + onsetPosition - 1; 
                    %troughInd = troughInd + onsetPosition - 1;
                else
                    %[peakAmp, peakInd] = nanmax( groupAvData );
                    %[troughAmp, troughInd] = nanmin( groupAvData );
                    [peakAmp, peakInd] = nanmax( groupAvData(onsetPosition:end) );
                    [troughAmp, troughInd] = nanmin( groupAvData(onsetPosition:end) );
                end
                peakInd = peakInd + onsetPosition - 1; 
                troughInd = troughInd + onsetPosition - 1;
                
                flyPeakTroughAmps(fly,:) = [peakAmp,troughAmp];
                flyPeakTroughInds(fly,:) = [peakInd,troughInd];
                flyPTTs(fly,1) = abs(peakAmp - troughAmp); %Theoretically calculates the sign-invariant distance between the peak and the trough
            else
                if fly ~= 1
                    flyData(fly,:) = NaN;
                    flyPeakTroughAmps(fly,:) = [NaN,NaN];
                    flyPeakTroughInds(fly,:) = [NaN,NaN];
                    flyPTTs(fly,1) = NaN;
                else
                    flyData(fly,1:captureWindowSize) = NaN;
                    flyPeakTroughAmps(fly,1:2) = [NaN,NaN];
                    flyPeakTroughInds(fly,1:2) = [NaN,NaN];
                    flyPTTs(fly,1) = NaN;
                end
            end
            
            %QA
            if nansum( flyPTTs ) == 0 > 0
                ['## Caution: Non-zero number of zero-amplitude PTTs exist']
                %crash = yes
                break
            end
            
            %Shared axes preparation
            if nanmax(nanmax(flyData)) > overMaxMin(1)
                overMaxMin(1) = nanmax(nanmax(flyData));
            end
            if nanmin(nanmin(flyData)) < overMaxMin(2)
                overMaxMin(2) = nanmin(nanmin(flyData));
            end
                       
        end
        
        %Average/SD across flies
        %flyDataAv = nanmean(flyData,1);
        %flyDataSEM = nanstd(flyData,1) / sqrt(size(flyData,1));

        %Plot
        %plot(flyDataAv, 'Color', groupColours(targToPlot,:))
        %hold on
        %groupShadeCoordsX = [1:1:size(flyDataAv,2),size(flyDataAv,2):-1:1];
        %groupShadeCoordsY = [flyDataAv+flyDataSEM,flip(flyDataAv-flyDataSEM)];
        %fill(groupShadeCoordsX, groupShadeCoordsY, groupColours(targToPlot,:)) %Error shading
        %alpha(0.15)
        
        %Plot individual flies
        for i = 1:size(flyData,1)
            %%thisFlyUniqueNumber = overVar(i).ancillary.thisFlyUniqueNumber;
            plot(flyData(i,:), ':', 'LineWidth', 2, 'Color', groupColours(targToPlot,:)) %Colours consistent with group
            %%plot(flyData(i,:), '--', 'LineWidth', 2, 'Color', flyColours(thisFlyUniqueNumber,:))
            hold on
            plot(flyData(i,:), '--', 'LineWidth', 2, 'Color', flyColours(i,:)) %Individual colours for datasets, not flies
            
            %Plot PtT
            line([flyPeakTroughInds(i,1),flyPeakTroughInds(i,2)],[flyPeakTroughAmps(i,1),flyPeakTroughAmps(i,2)],'Color','k')
        end

        %Ancillary text
        %safePosS = linspace(0.2*captureWindowSize,0.8*captureWindowSize,size(targsOfInterest,2));
        %safePos = floor(safePosS(targInd));
        %text(safePos,flyDataAv(floor(safePos)), ['G:',num2str(targToPlot),'(',num2str(targInd),')',',C:',num2str(chanToPlot)], 'Color', 'r')

        %Strings
        if chanInd == size(overChansOfInterestActive,2) %Only assemble on final loop
            titleStr = [titleStr, groupDescriptors{targToPlot}, '(J:',num2str(groupJitters(targToPlot)),')', vsStr{targInd}, char(10)];
        end
        
        %Add (approximate) onset line
        line([ captureWindowSize*(-captureWindowGeometryActive(1)),captureWindowSize*(-captureWindowGeometryActive(1)) ],[nanmin(flyPeakTroughAmps(:,2)),nanmax(flyPeakTroughAmps(:,1))], 'LineStyle', ':', 'Color', 'k')

        %Save for overuse
        overFlyPTTs{targInd} = flyPTTs;
        overFlyPTTInds{targInd} = flyPeakTroughInds;
        
        %Titles and things
        %subplotTitleStr = [groupDescriptors{targToPlot}, '(J:',num2str(groupJitters(targToPlot)),') - G',num2str(targToPlot)];
        %if size(targsOfInterest,2) > 4 %"Enough comparisons that subplot titles likely to overlap"
        if targInd / 2 == floor(targInd / 2 ) %Bootleg even/odd calculation
            subplotTitleStr = [char(10),groupDescriptors{targToPlot}, '(J:',num2str(groupJitters(targToPlot)),')-G',num2str(targToPlot),'(?n:',num2str(sumN),')']; %Place a blank row above
        else
            subplotTitleStr = [groupDescriptors{targToPlot}, '(J:',num2str(groupJitters(targToPlot)),')-G',num2str(targToPlot),'(?n:',num2str(sumN),')',char(10)]; %Place a blank row below
        end
        %else
        %    subplotTitleStr = [groupDescriptors{targToPlot}, '(J:',num2str(groupJitters(targToPlot)),')-G',num2str(targToPlot),'(?n:',num2str(sumN),')'];
        %end
        if forcedMeanNormalisation == 1
            subplotTitleStr = [subplotTitleStr,char(10),'(FMN)'];
        end
        title(subplotTitleStr)
        xlim([0, captureWindowSize])
        
    end
    %Shared axes
    for targInd = 1:size(targsOfInterest,2)
        if hidePTTLocsSubplots ~= 1
            subplot(4,size(targsOfInterest,2),targInd)
        else
            subplot(2,size(targsOfInterest,2),targInd)
        end
        try
            ylim([overMaxMin(2),overMaxMin(1)])
        catch
            ['-# Axis limit failure! #-']
        end
    end
       
    %Bar plot of PTTs
    if size(targsOfInterest,2) > 1
        if hidePTTLocsSubplots ~= 1
            subplot(4,size(targsOfInterest,2),[size(targsOfInterest,2)+1:size(targsOfInterest,2)*2])
        else
            subplot(2,size(targsOfInterest,2),[size(targsOfInterest,2)+1:size(targsOfInterest,2)*2])
        end
    else
        if hidePTTLocsSubplots ~= 1
            subplot(4,1,2);
        else
            subplot(2,1,2);
        end
    end
    barMeanData = [];
    barSEMData = [];
    exTicks = [];
    for targInd = 1:size(targsOfInterest,2)
        targToPlot = targsOfInterest(targInd);
        barMeanData(targInd) = nanmean(overFlyPTTs{targInd});
        barSEMData(targInd) = nanstd(overFlyPTTs{targInd}) / sqrt(size(overFlyPTTs{targInd},1));
        
        %Plot bars
        h = bar(targInd,barMeanData(targInd), 0.25);
        line([targInd,targInd],[barMeanData(targInd) - barSEMData(targInd),barMeanData(targInd) + barSEMData(targInd)], 'Color', 'k', 'LineWidth', 2)
        %line([barP,barP],[thisTargAUCMean - 0.5*thisTargAUCSD,thisTargAUCMean + 0.5*thisTargAUCSD], 'Color', 'k', 'LineStyle', ':', 'LineWidth', 2)
                %BOOTLEG CUSTOM ERROR BARS
        hold on
        set(h,'FaceColor',groupColours(targToPlot,:));
        set(h,'FaceAlpha',0.5);
        
        %Individual points
        if doIndividualColours == 1 && nansum( ~isnan(overFlyPTTs{targInd}) ) >= 1
            scatter([repmat(targInd,1,size(overFlyPTTs{targInd},1))],overFlyPTTs{targInd}, [], flyColours(:,:)) %Note: Colours will be borked if some flies have some targGroups but not others/etc
            if doAncillaryText == 1
                for fly = 1:size(overFlyPTTs{targInd},1)
                    text([targInd],[overFlyPTTs{targInd}(fly)],[num2str(fly)],'Color','r', 'FontSize', 8)
                end
            end
        else
            scatter([repmat(targInd,1,size(overFlyPTTs{targInd},1))],overFlyPTTs{targInd}, [], groupColours(targToPlot,:)) %Technically empty-safe lol
        end
        
        %Axes and things
        exTicks{targInd} = ['G',num2str(targToPlot)];
    end
    set(gca,'XTick',[1:size(targsOfInterest,2)])
    xticklabels(exTicks)
    titleStr = ['PTT barplot - Channel ',num2str(chanToPlot)];
    grid on
    if doSubSampling == 1
        titleStr = [titleStr,char(10),'(Data subsampled)'];
    end
    if doPostHocSubSampling == 1
         titleStr = [titleStr,char(10),'(Data post-hoc subsampled)'];
    end
    title(titleStr)
    
    if size(overFlyPTTs,2) > 1
        %New, barStats-based system
        barStats( cell2mat(overFlyPTTs), alphaValue, [], 1 );
        
        %Old
        %{
        %####
        %Follow-on stats
        %Stats
        statsData = []; %The data
        statsDataGroups = []; %The groups
        for x = 1:size(overFlyPTTs,2)
            statsData = [statsData,overFlyPTTs{x}'];
            statsDataGroups = [statsDataGroups,repmat(x,1,size(overFlyPTTs{x},1))];
        end
        [P,ANOVATAB,STATS]=anova1([statsData],[statsDataGroups], 'off');
        statCompare = multcompare(STATS, 'CType', 'bonferroni', 'display', 'off');
        %Plotting
        statBaseHeight = nanmax(get(gca,'YLim'))*1.1; %Default altitude to put stat indication at
        statInterval = 0.04*statBaseHeight; %How much space to leave between each group
        statOccupation = nan(size(overFlyPTTs,2)*4,size(overFlyPTTs,2)); %WIll indicate what airspace is already occupied by a stat indicator (A convoluted system to cut down on having to make a very high series of indicators needlessly)
        for i = 1:size(statCompare,1)
            if statCompare(i,6) < alphaValue
                %Check to see if airspace unoccupied
                statAltitude = 1;
                while nansum( isnan(statOccupation(statAltitude,statCompare(i,1):statCompare(i,2))) ) ~= statCompare(i,2) - statCompare(i,1) + 1 %Will probs crash if exceeds number of targets
                    statAltitude = statAltitude + 1;
                end
                line([statCompare(i,1)+0.05,statCompare(i,2)-0.05],[statBaseHeight+statAltitude*statInterval,statBaseHeight+statAltitude*statInterval],'Color', [0.60,0.60,0.60], 'LineWidth', 1.5)
                statOccupation(statAltitude,statCompare(i,1):statCompare(i,2)) = 1;
            end
        end
        %}
        %Identify outliers
        for x = 1:size(overFlyPTTs,2)
            outlierStatus = isoutlier(overFlyPTTs{x}); %"More like...outFlier"
            if nansum(outlierStatus) > 0 %Outliers detected
                disp(['## Warning: Fly number/s ',num2str(find(outlierStatus == 1)'),' for Group ', num2str(targsOfInterest(x)) ,' detected to be outliers for PTT plot ##'])
            end
        end
        %####

    end
    
    if hidePTTLocsSubplots ~= 1
        %Bar plot of peak/trough positions
        titleIndex = [{'Peak location'},{'Trough location'}];
        for i = 1:2
            if size(targsOfInterest,2) > 1
                %subplot(2,size(targsOfInterest,2),[size(targsOfInterest,2)+1:size(targsOfInterest,2)*2])
                subplot(4,size(targsOfInterest,2), [2*size(targsOfInterest,2)+1 + (i-1)*size(targsOfInterest,2) : 2*size(targsOfInterest,2) + size(targsOfInterest,2) + (i-1)*size(targsOfInterest,2)])
            else
                %subplot(2,1,2);
                subplot(4,1,3);
            end
            posBarMeanData = [];
            posBarSEMData = [];
            for targInd = 1:size(targsOfInterest,2)
                targToPlot = targsOfInterest(targInd);
                posBarMeanData(targInd) = nanmean(overFlyPTTInds{targInd}(:,i));
                posBarSEMData(targInd) = nanstd(overFlyPTTInds{targInd}(:,i)) / sqrt(size(overFlyPTTInds{targInd}(:,i),1));

                %Plot bars
                h = bar(targInd,posBarMeanData(targInd), 0.25);
                line([targInd,targInd],[posBarMeanData(targInd) - posBarSEMData(targInd),posBarMeanData(targInd) + posBarSEMData(targInd)], 'Color', 'k', 'LineWidth', 2)
                        %BOOTLEG CUSTOM ERROR BARS
                hold on
                set(h,'FaceColor',groupColours(targToPlot,:));
                set(h,'FaceAlpha',0.5);

                %Individual points
                if doIndividualColours == 1
                    scatter([repmat(targInd,1,size(overFlyPTTInds{targInd}(:,i),1))],overFlyPTTInds{targInd}(:,i), [], flyColours(:,:))
                    if doAncillaryText == 1
                        for fly = 1:size(overFlyPTTs{targInd},1)
                            text([targInd],[overFlyPTTInds{targInd}(fly,i)],[num2str(fly)],'Color','r', 'FontSize', 8)
                        end
                    end
                else
                    scatter([repmat(targInd,1,size(overFlyPTTInds{targInd}(:,i),1))],overFlyPTTInds{targInd}(:,i), [], groupColours(targToPlot,:))
                end

            end
            set(gca,'XTick',[1:size(targsOfInterest,2)])
            ylim([0, captureWindowSize])
            view([90 90]) %Rotate plot onto side
            xticklabels(exTicks)
            %thisColour = groupColours(targToPlot,:);
            %titleStr = ['\color{colourStruct.thisColour}',titleIndex{i}];
            titleStr = [titleIndex{i}];
            title(titleStr)
            grid on
        end
    end
    
    %thisFigName = ['GrandAvPTT' , ' - Ch', num2str(chanToPlot)];
    thisFigName = ['GrandAvPTT' , ' - Ch: ', chansOfInterestStr{chanInd}];
    figStr = [figStr,rerefIndex{rerefMode}]; %Add reref info to filename
    %bar([1:size(targsOfInterest,2)],barMeanData, 'Color', groupColours)
    %
    
    if useAutoList == 1
        set(gcf,'Name',[listToUse,' - ', thisFigName]);
    else
        set(gcf,'Name',['GrandAv - ', thisFigName]);
    end
    
    %###########
    %Save figure
    if saveFigs == 1
        try
            savePlot(saveName,thisFigName,figStr)
        catch 
            ['-# Alert: Failure to save plot #-']
        end
    end
    %###########

    %Follow-on line plot
        %Note: This plot designed to work with continuous groups, not disparate ones
    figure
    figStr = [];
    plotData = [];
    pttMeanData = [];
    pttSEMData = [];
    exTicks = [];
    a = 1;
    for targInd = 1:size(targsOfInterest,2)
        targToPlot = targsOfInterest(targInd); %Only used for exTicks here
        plotData(:,targInd) = overFlyPTTs{targInd};
        exTicks{a} = ['G',num2str(targToPlot)];
        a = a + 1;
    end
    pttMeanData = nanmean(plotData);
    pttSEMData = nanstd(plotData) / sqrt( size(plotData,1) ); %Note: Will not be accurate if one or more points/rows are NaN
    
    if doBootStrapping == 1
        %Calculate bootstrap trend line
            %"More like...bootleg trend line"
                %"Bootleg 2: Boot Harder"
        bootData = nan( size(plotData,1) , size(plotData,2) , numBoots ); %Will fail if numBoots not called into being
        %bootData = plotData;
        for bootI = 1:numBoots %"Heh"
            bootData(:,:,bootI) = plotData( : , randperm(size(plotData,2)) );
        end
        temp = nanmean(bootData,3);
        bootPTTMeanData = nanmean( temp , 1); %Double layered nanmean to first compress depth, then rows
        bootPTTSEMData = nanstd( temp ) ./ sqrt( size( temp ,1) );
    end
    
    %Plot
    plot(pttMeanData, '-ok', 'LineWidth', 2)
    hold on
    %Error shading
    groupShadeCoordsX = [1:1:size(pttMeanData,2),size(pttMeanData,2):-1:1];
    groupShadeCoordsY = [pttMeanData+pttSEMData,flip(pttMeanData-pttSEMData)];
    fill(groupShadeCoordsX, groupShadeCoordsY, 'k') %Error shading
    alpha(0.15)
    
    if doIndividualColours == 1
        %Plot individuals
        for fly = 1:size(plotData,1)
            plot(plotData(fly,:), '-o', 'Color', flyColours(fly,:))
            if doAncillaryText == 1
                text([size(plotData,2)+0.15],[plotData(fly,size(plotData,2))],[num2str(fly)],'Color','r', 'FontSize', 8)
            end
        end
    end
    
    if doBootStrapping
        %Plot boot
        plot(bootPTTMeanData, '-o', 'LineWidth', 2, 'Color', [0.6,0.6,0.6])
        %Error shading
        groupShadeCoordsX = [1:1:size(bootPTTMeanData,2),size(bootPTTMeanData,2):-1:1];
        groupShadeCoordsY = [bootPTTMeanData+bootPTTSEMData,flip(bootPTTMeanData-bootPTTSEMData)];
        h = fill(groupShadeCoordsX, groupShadeCoordsY, 'k'); %Error shading
        %alpha(0.05)
        set(h,'FaceAlpha',0.05)
    end
    
    xlabel(['Group'])
    xticklabels(exTicks)
    ylabel(['Average PTT distance (vertical)'])
    set(gca,'XTick',[1:size(targsOfInterest,2)])
    xlim([0,size(targsOfInterest,2)+1])
    %ylim([overMaxMin(2)*1.1,overMaxMin(1)*1.1]) %Automatic axes
    %ylim([0,400]) %Custom axes
    %disp('#- Caution: Custom axes enforced for grand average pttLinePlot -#')
    %thisFigName = ['PTTLinePlot' , ' - Ch', num2str(chanToPlot)];
    thisFigName = ['PTTLinePlot' , ' - Ch: ', chansOfInterestStr{chanInd}];
    figStr = [figStr,rerefIndex{rerefMode}]; %Add reref info to filename
    
    if useAutoList == 1
        set(gcf,'Name',[listToUse,' - ', thisFigName]);
    else
        set(gcf,'Name',['GrandAv - ', thisFigName]);
    end
    
    %###########
    %Save figure
    if saveFigs == 1
        try
            savePlot(saveName,thisFigName,figStr)
        catch 
            ['-# Alert: Failure to save plot #-']
        end
    end
    %###########
    
    if size(targsOfInterest,2) > 1 %Only do if trend could actually be calculated
        %GLM follow-on
        glmX = [];
        for i = 1:size( plotData,2 )
            glmX = [glmX,repmat(i, 1, size(plotData,1) )];
        end
        glmY = [];
        for i = 1:size( plotData,2 )
            glmY = [glmY,plotData(:,i)'];
        end
        [B , dev] = glmfit( glmX , glmY , 'Normal');
        [Bflat , devFlat] = glmfit( ones(1,size(glmX,2)) , glmY , 'Normal', 'Constant', 'off');
        glmP = 1 - chi2cdf([devFlat - dev] , size(plotData,2)-1 );
        yFit = glmX * B(2) + B(1);
        yFitFlat = repmat(Bflat, [1,size(glmX,2)]);

        %Plot GLM scatter
        figure
        scatter( glmX , glmY , [], 'k' )
        hold on
        scatter( glmX, yFit, [], 'g' )
        plot( glmX, yFit, 'Color', 'g' )
        scatter( glmX, yFitFlat, [], 'r' )
        plot( glmX, yFitFlat, 'Color', 'r' )
        xticks([1:size(plotData,2)])
        xticklabels(exTicks)
        xlabel(['Group'])
        ylabel(['Average PTT distance (vertical)'])
        xlim([0,size(plotData,2)+1])
        title(['GLM vs flat p = ',num2str(glmP),' (DoF UNVERIFIED [',num2str(size(plotData,2)-1),'])',char(10),'(Slope: ',num2str(B(2)),' + Icpt: ',num2str(B(1)),')',char(10),'Note: Only valid with continuous groups'])
        set(gcf, 'Name',['PTT GLM plot - Ch. ',chansOfInterestStr{chanInd}])
    end
    
    %###########
    %Save figure
    if saveFigs == 1
        try
            savePlot(saveName,thisFigName,figStr)
        catch 
            ['-# Alert: Failure to save plot #-']
        end
    end
    %###########
    
    %-----------------
    
    %Bar plot of peak/trough positions
    figure
    titleIndex = [{'Peak location'},{'Trough location'}];
    for i = 1:2
        %{
        if size(targsOfInterest,2) > 1
            %subplot(2,size(targsOfInterest,2),[size(targsOfInterest,2)+1:size(targsOfInterest,2)*2])
            subplot(4,size(targsOfInterest,2), [2*size(targsOfInterest,2)+1 + (i-1)*size(targsOfInterest,2) : 2*size(targsOfInterest,2) + size(targsOfInterest,2) + (i-1)*size(targsOfInterest,2)])
        else
            %subplot(2,1,2);
            subplot(4,1,3);
        end
        %}
        subplot(1,2,i)
        posBarMeanData = [];
        posBarSEMData = [];
        for targInd = 1:size(targsOfInterest,2)
            targToPlot = targsOfInterest(targInd);
            posBarMeanData(targInd) = nanmean(overFlyPTTInds{targInd}(:,i));
            posBarSEMData(targInd) = nanstd(overFlyPTTInds{targInd}(:,i)) / sqrt(size(overFlyPTTInds{targInd}(:,i),1));

            %Plot bars
            h = bar(targInd,posBarMeanData(targInd), 0.25);
            line([targInd,targInd],[posBarMeanData(targInd) - posBarSEMData(targInd),posBarMeanData(targInd) + posBarSEMData(targInd)], 'Color', 'k', 'LineWidth', 2)
                    %BOOTLEG CUSTOM ERROR BARS
            hold on
            set(h,'FaceColor',groupColours(targToPlot,:));
            set(h,'FaceAlpha',0.5);

            %Individual points
            if doIndividualColours == 1
                scatter([repmat(targInd,1,size(overFlyPTTInds{targInd}(:,i),1))],overFlyPTTInds{targInd}(:,i), [], flyColours(:,:))
                if doAncillaryText == 1
                    for fly = 1:size(overFlyPTTs{targInd},1)
                        text([targInd],[overFlyPTTInds{targInd}(fly,i)],[num2str(fly)],'Color','r', 'FontSize', 8)
                    end
                end
            else
                scatter([repmat(targInd,1,size(overFlyPTTInds{targInd}(:,i),1))],overFlyPTTInds{targInd}(:,i), [], groupColours(targToPlot,:))
            end

        end
        set(gca,'XTick',[1:size(targsOfInterest,2)])
        ylim([0, captureWindowSize])
        view([90 90]) %Rotate plot onto side
        xticklabels(exTicks)
        %thisColour = groupColours(targToPlot,:);
        %titleStr = ['\color{colourStruct.thisColour}',titleIndex{i}];
        titleStr = [titleIndex{i}];
        title(titleStr)
        grid on
        %Stats
        inputData = cell2mat( overFlyPTTInds );
        inputData = inputData(:,i:2:end);
        barStats(inputData,alphaValue,[],1);
    end
    set(gcf,'Name',['Pooled PTT latencies - Ch. ',chansOfInterestStr{chanInd}])
    
    %...and relative version
        %As in, how the peak/trough locations change across group per fly
            %Note: This calculates rolling difference, not change relative to first group
        
    figure
    titleIndex = [{'Delta peak location'},{'Delta trough location'}];
    for i = 1:2
        subplot(1,2,i)
        plotData = cell2mat( overFlyPTTInds );
        plotData = plotData(:,i:2:end);
        plotData = [zeros(size(plotData,1),1),diff(plotData,[],2)]; %Convert to rel
        %posBarMeanData = [];
        %posBarSEMData = [];
        for targInd = 1:size(targsOfInterest,2)
            targToPlot = targsOfInterest(targInd);
            %posBarMeanData(targInd) = nanmean(overFlyPTTInds{targInd}(:,i));
            %posBarSEMData(targInd) = nanstd(overFlyPTTInds{targInd}(:,i)) / sqrt(size(overFlyPTTInds{targInd}(:,i),1));
            meanData = nanmean( plotData(:,targInd) );
            semData = nanstd( plotData(:,targInd) ) / sqrt(size(plotData,1));
            %Plot bars
            %h = bar(targInd,posBarMeanData(targInd), 0.25);
            h = bar(targInd,meanData, 0.25);
            %line([targInd,targInd],[posBarMeanData(targInd) - posBarSEMData(targInd),posBarMeanData(targInd) + posBarSEMData(targInd)], 'Color', 'k', 'LineWidth', 2)
            line([targInd,targInd],[meanData - semData,meanData + semData], 'Color', 'k', 'LineWidth', 2)
                    %BOOTLEG CUSTOM ERROR BARS
            hold on
            set(h,'FaceColor',groupColours(targToPlot,:));
            set(h,'FaceAlpha',0.5);

            %Individual points
            if doIndividualColours == 1
                %scatter([repmat(targInd,1,size(overFlyPTTInds{targInd}(:,i),1))],overFlyPTTInds{targInd}(:,i), [], flyColours(:,:))
                scatter([repmat(targInd,1,size(plotData,1))],plotData(:,targInd), [], flyColours(:,:))
                if doAncillaryText == 1
                    for fly = 1:size(plotData,1)
                        text([targInd],[plotData(fly,targInd)],[num2str(fly)],'Color','r', 'FontSize', 8)
                    end
                end
            else
                scatter([repmat(targInd,1,size(plotData(:,targInd),1))],plotData(:,targInd), [], groupColours(targToPlot,:))
            end

        end
        set(gca,'XTick',[1:size(targsOfInterest,2)])
        %ylim([0, captureWindowSize])
        view([90 90]) %Rotate plot onto side
        xticklabels(exTicks)
        %thisColour = groupColours(targToPlot,:);
        %titleStr = ['\color{colourStruct.thisColour}',titleIndex{i}];
        titleStr = [titleIndex{i}];
        title(titleStr)
        grid on
        ylabel(['Rolling change in location'])
        %Stats
        barStats(plotData,alphaValue,[],1);
    end
    set(gcf,'Name',['Pooled rolling PTT latency diff - Ch. ',chansOfInterestStr{chanInd}])
    
    %Relative latencies (to first group)
        %As in, how the peak/trough locations change across group per fly
    figure
    titleIndex = [{'Relative peak location'},{'Relative trough location'}];
    for i = 1:2
        subplot(1,2,i)
        plotData = cell2mat( overFlyPTTInds );
        plotData = plotData(:,i:2:end);
        plotData = plotData - plotData(:,1);
        
        titleStr = [titleIndex{i}];
        
        for targInd = 1:size(targsOfInterest,2)
            targToPlot = targsOfInterest(targInd);
            meanData = nanmean( plotData(:,targInd) );
            semData = nanstd( plotData(:,targInd) ) / sqrt(size(plotData,1));
            %Plot bars
            h = bar(targInd,meanData, 0.25);
            line([targInd,targInd],[meanData - semData,meanData + semData], 'Color', 'k', 'LineWidth', 2)
                    %BOOTLEG CUSTOM ERROR BARS
            hold on
            set(h,'FaceColor',groupColours(targToPlot,:));
            set(h,'FaceAlpha',0.5);

            %Individual points
            if doIndividualColours == 1
                %scatter([repmat(targInd,1,size(overFlyPTTInds{targInd}(:,i),1))],overFlyPTTInds{targInd}(:,i), [], flyColours(:,:))
                scatter([repmat(targInd,1,size(plotData,1))],plotData(:,targInd), [], flyColours(:,:))
                if doAncillaryText == 1
                    for fly = 1:size(plotData,1)
                        text([targInd],[plotData(fly,targInd)],[num2str(fly)],'Color','r', 'FontSize', 8)
                    end
                end
            else
                scatter([repmat(targInd,1,size(plotData(:,targInd),1))],plotData(:,targInd), [], groupColours(targToPlot,:))
            end
            
            titleStr = [titleStr,char(10),groupDescriptors{targToPlot}];

        end
        set(gca,'XTick',[1:size(targsOfInterest,2)])
        %ylim([0, captureWindowSize])
        view([90 90]) %Rotate plot onto side
        xticklabels(exTicks)

        title(titleStr)
        ylabel(['Change in location rel. to first group'])
        grid on
        %Stats
        barStats(plotData,alphaValue,[],1);
    end
    set(gcf,'Name',['Pooled relative PTT latencies - Ch. ',chansOfInterestStr{chanInd}])
    
    %-----------------
    
    if doBootStrapping == 1
        %for bootInd = 1:bootRounds
            %"Bootstrap end values (be they pooled data or precalculated)"
            bootPostMeans = [];
            for targInd = 1:size(targsOfInterest,2)
                %bootPostMeans(:,targInd) = bootstrp(numBoots,@mean,bootAllPTTs{targInd}); %Bootstrap pooled PTT values (requires above code to be uncommented)
                bootPostMeans(:,targInd) = bootstrp(numBoots,@mean,overFlyPTTs{targInd}); %Bootstrap original endpoint values
                %{
                if targsOfInterest(targInd) ~= bootTarget
                    %Proper bootstrap implementation (correct operation not confirmed)
                    %bootMeans(:,targInd) = bootstrp(numBoots,@mean,bootAllPTTs{targInd}); %Bootstrap and put data into flat array
                    %Bootleg boostrap implementation (validity not confirmed)
                    for i = 1:numBoots
                        bootMeans(i,targInd) = nanmean( bootAllPTTs{targInd}( randsample(size(bootAllPTTs{targInd},1),numBoots) ) ); %Will crash if any group has less cycles than the target (maybe)
                    end
                else
                    bootMeans(:,targInd) = bootAllPTTs{targInd}; %Put in target data here
                end
                %}
            end

            %QA for empty or NaN
            if nansum(nansum(bootPostMeans == 0)) > 0 
                ['## Alert: Failure in bootstrapping ##']
                crash = yes
            end


            %"Use values that were bootstrapped for indiidual flies/targets"
            %bootPreMeans = overBootValMeans;
            %Means and things
            %meanPreData = nanmean(bootPreMeans,1);                              
            %semPreData = nanstd(bootPreMeans,1) / sqrt(size(bootPreMeans,1));   
            %stdPreData = nanstd(bootPreMeans,1);                                
            meanPostData = nanmean(bootPostMeans,1);
            semPostData = nanstd(bootPostMeans,1) / sqrt(size(bootPostMeans,1));
            stdPostData = nanstd(bootPostMeans,1);
            %Barplot
            figure
            %subplot(2,1,1) %State of affairs: Add in hists of bootstrap values to top row
            exTicks = [];
            for targInd = 1:size(targsOfInterest,2)
                targToPlot = targsOfInterest(targInd);
               
                %Axes and things
                exTicks{targInd} = ['G',num2str(targToPlot)];
                
                %Plot 'original' data as well
                h = bar(targInd,barMeanData(targInd), 0.2);
                line([targInd-0.05,targInd-0.05],[barMeanData(targInd) - barSEMData(targInd),barMeanData(targInd) + barSEMData(targInd)], 'Color', 'k', 'LineWidth', 2)
                hold on
                set(h,'FaceColor',groupColours(targToPlot,:));
                set(h,'FaceAlpha',0.25);
                
                %...and plot data
                h = bar(targInd,meanPostData(targInd), 0.15);
                %line([targInd+0.05,targInd+0.05],[meanPostData(targInd) - semPostData(targInd),meanPostData(targInd) + semPostData(targInd)], 'Color', [0.3,0.3,0.3], 'LineWidth', 2)
                line([targInd+0.05,targInd+0.05],[meanPostData(targInd) - stdPostData(targInd),meanPostData(targInd) + stdPostData(targInd)], 'Color', [0.3,0.3,0.3], 'LineWidth', 2, 'LineStyle', ':')
                hold on
                set(h,'FaceColor',groupColours(targToPlot,:));
                set(h,'FaceAlpha',0.25);
            end
            set(gca,'XTick',[1:size(targsOfInterest,2)])
            xticklabels(exTicks)
            grid('minor')
            titleStr = ['Mean PTT bootstrap'];
            title(titleStr)
            ylabel('Bootstrapped mean value (+- SD)')

            %thisFigName = ['PTTBootstrapPlot - Ch', num2str(chanToPlot)];
            thisFigName = ['PTTBootstrapPlot - Ch: ', chansOfInterestStr{chanInd}];
            figStr = []; %Add reref info to filename

            if useAutoList == 1
                set(gcf,'Name',[listToUse,' - ', thisFigName]);
            else
                set(gcf,'Name',['GrandAv - ', thisFigName]);
            end

            %###########
            %Save figure
            if saveFigs == 1
                try
                    savePlot(saveName,thisFigName,figStr)
                catch 
                    ['-# Alert: Failure to save plot #-']
                end
            end
            %###########

        %end
    end

    
    %Save overinformation
    superOverFlyPTTStruct(chanInd).overFlyPTTs = overFlyPTTs;
    superOverFlyPTTStruct(chanInd).overFlyPTTInds = overFlyPTTInds;
    superOverFlyPTTStruct(chanInd).targsOfInterest = targsOfInterest; %For QA purposes later    
    
end

%nikke

%Combined bar plot
    %If rerunning individually for different groups the preceding section will need to be run too
clear overFlyPTTs %Just in case
inputData = [];
if size(chansOfInterest,2) > 1 %Only do combined plot if actually more than one channel of interest
    figure
    a = 1;
    titleStr = [];
    figStr = []; %Similar, but for fig autosaving
    vsStr = [repmat({' vs '},1,size(groupTargets,2)-1),{''}];
    exTicks = [];
    for chanInd = 1:size(overChansOfInterestActive,2)
        %QA in case of running without full restart
        if size(targsOfInterest,2) ~= size(superOverFlyPTTStruct(chanInd).overFlyPTTs,2)
            ['## Alert: Desynchronisation between original targsOfInterest size and calculated PTTs ##']
            %Note: Won't help if targs differ but number is same
            crash = yes
        end
        barMeanData = [];
        barSEMData = [];
        %exTicks = [];
        for targInd = 1:size(targsOfInterest,2)
            targToPlot = targsOfInterest(targInd);
            barMeanData(targInd) = nanmean(superOverFlyPTTStruct(chanInd).overFlyPTTs{targInd});
            barSEMData(targInd) = nanstd(superOverFlyPTTStruct(chanInd).overFlyPTTs{targInd}) / sqrt(size(superOverFlyPTTStruct(chanInd).overFlyPTTs{targInd},1));

            %Plot bars
            %h = bar(targInd,barMeanData(targInd), 0.25);
            h = bar(a,barMeanData(targInd), 0.25); %All in one
            %line([targInd,targInd],[barMeanData(targInd) - barSEMData(targInd),barMeanData(targInd) + barSEMData(targInd)], 'Color', 'k', 'LineWidth', 2)
            line([a,a],[barMeanData(targInd) - barSEMData(targInd),barMeanData(targInd) + barSEMData(targInd)], 'Color', 'k', 'LineWidth', 2)
            %line([barP,barP],[thisTargAUCMean - 0.5*thisTargAUCSD,thisTargAUCMean + 0.5*thisTargAUCSD], 'Color', 'k', 'LineStyle', ':', 'LineWidth', 2)
                    %BOOTLEG CUSTOM ERROR BARS
            hold on
            set(h,'FaceColor',groupColours(targToPlot,:));
            set(h,'FaceAlpha',0.5);

            %Individual points
            if doIndividualColours == 1
                %scatter([repmat(targInd,1,size(superOverFlyPTTStruct(chanInd).overFlyPTTs{targInd},1))],superOverFlyPTTStruct(chanInd).overFlyPTTs{targInd}, [], flyColours(:,:))
                scatter([repmat(a,1,size(superOverFlyPTTStruct(chanInd).overFlyPTTs{targInd},1))],superOverFlyPTTStruct(chanInd).overFlyPTTs{targInd}, [], flyColours(:,:))
                if doAncillaryText == 1
                    for fly = 1:size(superOverFlyPTTStruct(chanInd).overFlyPTTs{targInd},1)
                        text([a],[superOverFlyPTTStruct(chanInd).overFlyPTTs{targInd}(fly)],[num2str(fly)],'Color','r', 'FontSize', 8)
                    end
                end
            else
                scatter([repmat(a,1,size(superOverFlyPTTStruct(chanInd).overFlyPTTs{targInd},1))],superOverFlyPTTStruct(chanInd).overFlyPTTs{targInd}, [], groupColours(targToPlot,:))
            end

            %Axes and things
            exTicks{a} = ['G',num2str(targToPlot)];
            a = a + 1;
        end
        inputData = [inputData,cell2mat(superOverFlyPTTStruct(chanInd).overFlyPTTs)];
        %{
        if size(superOverFlyPTTStruct(chanInd).overFlyPTTs,2) > 1
            barStats( cell2mat(superOverFlyPTTStruct(chanInd).overFlyPTTs), alphaValue, [], 1 )
            %{
            %####
            %Follow-on stats
            %Stats
            statsData = []; %The data
            statsDataGroups = []; %The groups
            for x = 1:size(superOverFlyPTTStruct(chanInd).overFlyPTTs,2)
                statsData = [statsData,superOverFlyPTTStruct(chanInd).overFlyPTTs{x}'];
                statsDataGroups = [statsDataGroups,repmat(x,1,size(superOverFlyPTTStruct(chanInd).overFlyPTTs{x},1))];
            end
            [P,ANOVATAB,STATS]=anova1([statsData],[statsDataGroups], 'off');
            statCompare = multcompare(STATS, 'CType', 'bonferroni', 'display', 'off');
            %Plotting
            statBaseHeight = nanmax(get(gca,'YLim'))*1.1; %Default altitude to put stat indication at
            statInterval = 0.04*statBaseHeight; %How much space to leave between each group
            statOccupation = nan(size(superOverFlyPTTStruct(chanInd).overFlyPTTs,2)*4,size(superOverFlyPTTStruct(chanInd).overFlyPTTs,2)); %WIll indicate what airspace is already occupied by a stat indicator (A convoluted system to cut down on having to make a very high series of indicators needlessly)
            for i = 1:size(statCompare,1)
                if statCompare(i,6) < alphaValue
                    %Check to see if airspace unoccupied
                    statAltitude = 1;
                    while nansum( isnan(statOccupation(statAltitude,statCompare(i,1):statCompare(i,2))) ) ~= statCompare(i,2) - statCompare(i,1) + 1 %Will probs crash if exceeds number of targets
                        statAltitude = statAltitude + 1;
                    end
                    %line([statCompare(i,1)+0.05,statCompare(i,2)-0.05],[statBaseHeight+statAltitude*statInterval,statBaseHeight+statAltitude*statInterval],'Color', [0.60,0.60,0.60], 'LineWidth', 1.5)
                    %line([a-statCompare(i,1)+0.05,a-statCompare(i,2)-0.05],[statBaseHeight+statAltitude*statInterval,statBaseHeight+statAltitude*statInterval],'Color', [0.60,0.60,0.60], 'LineWidth', 1.5)
                    line([a-1-size(targsOfInterest,2)+statCompare(i,1)+0.05,a-1-size(targsOfInterest,2)+statCompare(i,2)-0.05],[statBaseHeight+statAltitude*statInterval,statBaseHeight+statAltitude*statInterval],'Color', [0.60,0.60,0.60], 'LineWidth', 1.5)
                    %['-# Caution: Significance line X position calculations not verified correct #-']
                    statOccupation(statAltitude,statCompare(i,1):statCompare(i,2)) = 1;
                end
            end
            %####
            %}
        end
        %}
        
    end

    set(gca,'XTick',[1:a-1])
    xticklabels(exTicks)
titleStr = ['PTT combined barplot - Channel/s ',chansOfInterest];
    grid on
    if doSubSampling == 1
        titleStr = [titleStr,char(10),'(Data subsampled)'];
    end
    if doPostHocSubSampling == 1
         titleStr = [titleStr,char(10),'(Data post-hoc subsampled)'];
    end
    try
        if enforcePTTPrecedence == 1
             titleStr = [titleStr,char(10),'(Max/Min precdence enforced)'];
        end
        if enforcePTTPostStimulus == 1
             titleStr = [titleStr,char(10),'(PTT post stimulus onset enforced)'];
        end
    catch
        ['-# Caution: No information about PTT enforcement available #-']
    end
    title(titleStr)
    set(gcf,'Name', 'PTT combined barplot')
    
    barStats( inputData, alphaValue, [] , 1 ); %Advantage of doing this here is that channels can be compared
        %Note: Bonferroni may cause issues if significance was tentative previously
        
end       
 

%Combined plot Mk 3
figure
for chanInd = 1:size(overChansOfInterestActive,2)
    subplot(size(overChansOfInterestActive,2),1,chanInd)
    %meanSubData = [];
    plotData = cell2mat(superOverFlyPTTStruct(chanInd).overFlyPTTs);
    %meanSubData = temp - nanmean(temp,2);

    meanData = nanmean(plotData,1);
    semData = nanstd(plotData,[],1) / sqrt(size(plotData,1));
    if boxPlotMode == 0
        exTicks = [];
        for targInd = 1:size(targsOfInterest,2)
            targToPlot = targsOfInterest(targInd);
            h = bar(targInd,meanData(targInd));
            set(h,'FaceColor',groupColours(targToPlot,:));
            set(h,'FaceAlpha',0.5);
            hold on
            line([targInd,targInd],[meanData(targInd) - semData(targInd),meanData(targInd) + semData(targInd)], 'Color', 'k', 'LineWidth', 2)            
            exTicks{targInd} = ['G',num2str(targToPlot)];
            scatter(repmat(targInd,size(plotData,1),1),plotData(:,targInd),[],flyColours)
        end
    else
        sriBoxPlotMk2(plotData,1,alphaValue)
    end
    for IIDN = 1:size(plotData,1)
        line([1:size(plotData,2)],plotData(IIDN,:),'Color', 'k')
        for gInd = 1:size(plotData,2)
            text(gInd, plotData(IIDN,gInd),num2str(IIDN),'Color', 'r')
        end
    end
    xticks(1:size(targsOfInterest,2))
    xticklabels(exTicks)
    titleStr = ['Comb sep PTT plot - Ch: ', chansOfInterestStr{chanInd}];
    %title(titleStr)
    if nansum(nansum(isnan(plotData))) > 0
        titleStr = [titleStr, char(10), '-# Caution: SEM inaccurate due to NaN presence #-'];
    end

    %####
    title(titleStr)
    if size(plotData,2) > 1 && boxPlotMode == 0
    %    if size(meanSubData,2) > 2
    barStats(plotData, alphaValue, [], 1); %To do: add paired T-test option to barStats
    %    else
    %        [h,p] = ttest(meanSubData(:,1),meanSubData(:,2));
    %    end
    end
    %####

end
set(gcf,'Name','Combined separated PTT plot')

%-------------------------------

%Relative PTTs

figure
for chanInd = 1:size(overChansOfInterestActive,2)
    subplot(size(overChansOfInterestActive,2),1,chanInd)
    relData = [];
    temp = cell2mat(superOverFlyPTTStruct(chanInd).overFlyPTTs);
    %temp = [temp(:,1),temp];
    for row = 1:size(temp,1)
        relData(row,:) = [0,diff(temp(row,:))];
    end

    meanData = nanmean(relData,1);
    semData = nanstd(relData,[],1) / sqrt(size(relData,1));
    exTicks = [];
    for targInd = 1:size(targsOfInterest,2)
        targToPlot = targsOfInterest(targInd);
        h = bar(targInd,meanData(targInd));
        set(h,'FaceColor',groupColours(targToPlot,:));
        set(h,'FaceAlpha',0.5);
        hold on
        line([targInd,targInd],[meanData(targInd) - semData(targInd),meanData(targInd) + semData(targInd)], 'Color', 'k', 'LineWidth', 2)            
        exTicks{targInd} = ['G',num2str(targToPlot)];
    end
    xticks(1:size(targsOfInterest,2))
    xticklabels(exTicks)
    titleStr = ['Relative PTT plot - Ch: ', chansOfInterestStr{chanInd}];
    title(titleStr)

    %####
    if size(relData,2) > 1
        barStats(relData, alphaValue, [], 1);
        %{
        %Follow-on stats
        %Stats
        statsData = []; %The data
        statsDataGroups = []; %The groups
        %for x = 1:size(relData,2)
        %    statsData = [statsData,overFlyPTTs{x}'];
        %    statsDataGroups = [statsDataGroups,repmat(x,1,size(overFlyPTTs{x},1))];
        %end
        statsData = reshape(relData,1,numel(relData));
        statsDataGroups = [1:size(relData,2)];
        statsDataGroups = repmat(statsDataGroups,size(relData,1),1);
        statsDataGroups = reshape(statsDataGroups,1,numel(statsDataGroups));
        [P,ANOVATAB,STATS]=anova1([statsData],[statsDataGroups], 'off');
        statCompare = multcompare(STATS, 'CType', 'bonferroni', 'display', 'off');
        %Plotting
        statBaseHeight = nanmax(get(gca,'YLim'))*1.1; %Default altitude to put stat indication at
        statInterval = 0.04*statBaseHeight; %How much space to leave between each group
        statOccupation = nan(size(relData,2)*4,size(relData,2)); %WIll indicate what airspace is already occupied by a stat indicator (A convoluted system to cut down on having to make a very high series of indicators needlessly)
        for i = 1:size(statCompare,1)
            if statCompare(i,6) < alphaValue
                %Check to see if airspace unoccupied
                statAltitude = 1;
                while nansum( isnan(statOccupation(statAltitude,statCompare(i,1):statCompare(i,2))) ) ~= statCompare(i,2) - statCompare(i,1) + 1 %Will probs crash if exceeds number of targets
                    statAltitude = statAltitude + 1;
                end
                line([statCompare(i,1)+0.05,statCompare(i,2)-0.05],[statBaseHeight+statAltitude*statInterval,statBaseHeight+statAltitude*statInterval],'Color', [0.60,0.60,0.60], 'LineWidth', 1.5)
                statOccupation(statAltitude,statCompare(i,1):statCompare(i,2)) = 1;
            end
        end
        %{
        %Identify outliers
        for x = 1:size(overFlyPTTs,2)
            outlierStatus = isoutlier(overFlyPTTs{x}); %"More like...outFlier"
            if nansum(outlierStatus) > 0 %Outliers detected
                disp(['## Warning: Fly number/s ',num2str(find(outlierStatus == 1)'),' for Group ', num2str(targsOfInterest(x)) ,' detected to be outliers for PTT plot ##'])
            end
        end
        %}
        %}
    end
    %####

end
set(gcf,'Name','Relative PTT plot')


%Combined relative PTT plot
plotData = [];
for chanInd = 1:size(overChansOfInterestActive,2)
    relData = [];
    temp = cell2mat(superOverFlyPTTStruct(chanInd).overFlyPTTs);
    %temp = [temp(:,1),temp];
    for row = 1:size(temp,1)
        relData(row,:) = [0,diff(temp(row,:))];
    end
    plotData = [plotData,relData];
end
meanData = nanmean(plotData,1);
semData = nanstd(plotData,[],1) / sqrt(size(plotData,1));
exTicks = [];
figure
for chanInd = 1:size(overChansOfInterestActive,2)
    for targInd = 1:size(targsOfInterest,2)
        targToPlot = targsOfInterest(targInd);
        thisTargInd = targInd + (chanInd-1)*size(targsOfInterest,2);
        %h = bar(targInd,meanData(targInd));
        h = bar(thisTargInd ,meanData(thisTargInd));
        set(h,'FaceColor',groupColours(targToPlot,:));
        set(h,'FaceAlpha',0.5);
        hold on
        %line([targInd,targInd],[meanData(targInd) - semData(targInd),meanData(targInd) + semData(targInd)], 'Color', 'k', 'LineWidth', 2)
        line([thisTargInd,thisTargInd],[meanData(thisTargInd) - semData(thisTargInd),meanData(thisTargInd) + semData(thisTargInd)], 'Color', 'k', 'LineWidth', 1)
        exTicks{thisTargInd} = ['G',num2str(targToPlot)]; 
    end
    line([thisTargInd+0.5,thisTargInd+0.5],[nanmin(meanData),nanmax(meanData)],'LineStyle', ':', 'Color', 'k')
end
xticks(1:size(plotData,2))
xticklabels(exTicks)
xlabel(['Group'])
ylabel(['Relative change in PTT'])
titleStr = ['Combined relative PTT plot'];
title(titleStr)
set(gcf,'Name','Combined relative PTT plot')
barStats(plotData,alphaValue);
clear relData


%Delta PTTs
%###################
%Note: This code cannot be modified for targsOfInterest without running the section again
%###################
if isequal(targsOfInterest , targsOfInterestOriginal) ~= 1 && acknowledged ~= 1 %Check against original
%if isequal(targsOfInterest , superOverFlyPTTStruct(1).targsOfInterest) ~= 1 %Check against (first channel) PTT struct
    input('INFORMATIVE: CURRENT targsOfInterest DOES NOT MATCH ORIGINAL (ENTER TO ACK)')
    acknowledged = 1;
end

proximalExcludeGroups = 1; %How many of the targsOfInterest to exclude from analysis
    %This is intended primarily to eliminate questions about the validity of doing an ANOVA on a column of flat 0s
figure
for chanInd = 1:size(overChansOfInterestActive,2)
    subplot(size(overChansOfInterestActive,2),1,chanInd)
    delData = [];
    temp = cell2mat(superOverFlyPTTStruct(chanInd).overFlyPTTs);
    %temp = [temp(:,1),temp];
    for row = 1:size(temp,1)
        %relData(row,:) = [0,diff(temp(row,:))];
        delData(row,:) = temp(row,:) - temp(row,1);
    end

    if proximalExcludeGroups > 0 
        delData = delData( : , 1+proximalExcludeGroups : end );
    end
    targsOfInterestDeltaActive = targsOfInterest( 1+proximalExcludeGroups : end );

    meanData = nanmean(delData,1);
    semData = nanstd(delData,[],1) / sqrt(size(delData,1));
    exTicks = [];
    for targInd = 1:size(targsOfInterestDeltaActive,2)
        targToPlot = targsOfInterestDeltaActive(targInd);
        h = bar(targInd,meanData(targInd));
        set(h,'FaceColor',groupColours(targToPlot,:));
        set(h,'FaceAlpha',0.5);
        hold on
        line([targInd,targInd],[meanData(targInd) - semData(targInd),meanData(targInd) + semData(targInd)], 'Color', 'k', 'LineWidth', 2)            
        exTicks{targInd} = ['G',num2str(targToPlot)];
    end
    xticks(1:size(targsOfInterestDeltaActive,2))
    xticklabels(exTicks)
    titleStr = ['Delta PTT plot - Ch: ', chansOfInterestStr{chanInd}];
    if useAutoList == 1
        titleStr = [titleStr, char(10), 'List: ',listToUse];
    end
    title(titleStr)

    %####
    %Follow-on stats
    %Stats
    [P,A,S] = barStats(delData,alphaValue,[],1);
    %figure
    %multcompare(S)
    %rat
    %{
    statsData = []; %The data
    statsDataGroups = []; %The groups
    %for x = 1:size(relData,2)
    %    statsData = [statsData,overFlyPTTs{x}'];
    %    statsDataGroups = [statsDataGroups,repmat(x,1,size(overFlyPTTs{x},1))];
    %end
    statsData = reshape(relData,1,numel(relData));
    statsDataGroups = [1:size(relData,2)];
    statsDataGroups = repmat(statsDataGroups,size(relData,1),1);
    statsDataGroups = reshape(statsDataGroups,1,numel(statsDataGroups));
    [P,ANOVATAB,STATS]=anova1([statsData],[statsDataGroups], 'off');
    statCompare = multcompare(STATS, 'CType', 'bonferroni', 'display', 'off');
    %Plotting
    statBaseHeight = nanmax(get(gca,'YLim'))*1.1; %Default altitude to put stat indication at
    statInterval = 0.04*statBaseHeight; %How much space to leave between each group
    statOccupation = nan(size(relData,2)*4,size(relData,2)); %WIll indicate what airspace is already occupied by a stat indicator (A convoluted system to cut down on having to make a very high series of indicators needlessly)
    for i = 1:size(statCompare,1)
        if statCompare(i,6) < alphaValue
            %Check to see if airspace unoccupied
            statAltitude = 1;
            while nansum( isnan(statOccupation(statAltitude,statCompare(i,1):statCompare(i,2))) ) ~= statCompare(i,2) - statCompare(i,1) + 1 %Will probs crash if exceeds number of targets
                statAltitude = statAltitude + 1;
            end
            line([statCompare(i,1)+0.05,statCompare(i,2)-0.05],[statBaseHeight+statAltitude*statInterval,statBaseHeight+statAltitude*statInterval],'Color', [0.60,0.60,0.60], 'LineWidth', 1.5)
            statOccupation(statAltitude,statCompare(i,1):statCompare(i,2)) = 1;
        end
    end
    %{
    %Identify outliers
    for x = 1:size(overFlyPTTs,2)
        outlierStatus = isoutlier(overFlyPTTs{x}); %"More like...outFlier"
        if nansum(outlierStatus) > 0 %Outliers detected
            disp(['## Warning: Fly number/s ',num2str(find(outlierStatus == 1)'),' for Group ', num2str(targsOfInterest(x)) ,' detected to be outliers for PTT plot ##'])
        end
    end
    %}
    %}
    %####

end
set(gcf,'Name','Delta PTT plot')


%Mean subtraction PTTs
    %At this point we might as well just do Z-scoring...
figure
for chanInd = 1:size(overChansOfInterestActive,2)
    subplot(size(overChansOfInterestActive,2),1,chanInd)
    meanSubData = [];
    temp = cell2mat(superOverFlyPTTStruct(chanInd).overFlyPTTs);
    meanSubData = temp - nanmean(temp,2);

    meanData = nanmean(meanSubData,1);
    semData = nanstd(meanSubData,[],1) / sqrt(size(meanSubData,1)); %Note: Only valid if no NaN data
    exTicks = [];
    if boxPlotMode == 0
        %exTicks = [];
        for targInd = 1:size(targsOfInterest,2)
            targToPlot = targsOfInterest(targInd);
            h = bar(targInd,meanData(targInd));
            set(h,'FaceColor',groupColours(targToPlot,:));
            set(h,'FaceAlpha',0.5);
            hold on
            line([targInd,targInd],[meanData(targInd) - semData(targInd),meanData(targInd) + semData(targInd)], 'Color', 'k', 'LineWidth', 2)            
            exTicks{targInd} = ['G',num2str(targToPlot)];
            scatter(repmat(targInd,size(meanSubData,1),1),meanSubData(:,targInd),[],flyColours)
        end
    else
        for targInd = 1:size(targsOfInterest,2)
            exTicks{targInd} = ['G',num2str(targsOfInterest(targInd))];
        end
        %sriBoxPlotMk2(meanSubData,1,alphaValue,[],[],[],[],[],[],[],1)
        sriBoxPlotMk3(meanSubData,1,'AlphaValue',0.05,'PVals',1,'TitleLoc',2,'FixY',[],...
            'SuppTitle',0,'TitleApp',['Ch: ', chansOfInterestStr{chanInd}])
    end
    for IIDN = 1:size(meanSubData,1)
        line([1:size(meanSubData,2)],meanSubData(IIDN,:),'Color', 'k')
    end
    xticks(1:size(targsOfInterest,2))
    xticklabels(exTicks)
    %title(titleStr)

    %####
    if boxPlotMode == 0
        titleStr = ['Mean sub PTT plot - Ch: ', chansOfInterestStr{chanInd}];
        if nansum(nansum(isnan(meanSubData))) > 0
            titleStr = [titleStr, char(10), '-# Caution: SEM inaccurate due to NaN presence #-'];
        end
        title(titleStr)
    end
    if size(meanSubData,2) > 1 && (boxPlotMode == 0)
    %    if size(meanSubData,2) > 2
    %title(titleStr)
    %barStats(meanSubData, alphaValue, [], 1); %To do: add paired T-test option to barStats
    barStats(meanSubData, alphaValue, [], 1,[],[],[],[],[],1); %To do: add paired T-test option to barStats
    %    else
    %        [h,p] = ttest(meanSubData(:,1),meanSubData(:,2));
    %    end
    end
    %####

end
set(gcf,'Name','Mean subtraction PTT plot')
    
%end

%########

%%
%weAreOkay
%########

%Calculate PTT ratios (if applicable)
%try
    %QA before starting
    if isequal( superOverFlyPTTStruct(chanInd).targsOfInterest , targsOfInterest ) ~= 1
        ['## Alert: PTTs generated with different targsOfInterest to current ##']
        crash = yes
    end
    if exist('ratioCompGroups') ~= 0 && isempty(ratioCompGroups) ~= 1
        if size( intersect(reshape(ratioCompGroups, [1,numel(ratioCompGroups)]),targsOfInterest),2 ) == numel(unique(ratioCompGroups)) %Check that all ratioCompGroup elements exist in targsOfInterest
            overRatioData = [];
            overRatSubData = [];
            for chanInd = 1:size(overChansOfInterestActive,2)
                ratioData = [];
                subData = [];
                for ratIndRow = 1:size(ratioCompGroups,1)
                    if ismember( ratioCompGroups(ratIndRow,1) , targsOfInterest ) == 1 && ismember( ratioCompGroups(ratIndRow,2) , targsOfInterest ) == 1

                        ratTargInds = []; %Find the rat groups within targsOfInterest (because that is how overFlyPTTs is arranged)
                        for i = 1:size(ratioCompGroups,2)
                            ratTargInds = [ratTargInds, find(targsOfInterest == ratioCompGroups(ratIndRow,i))];
                        end

                        ratioData{ratIndRow} = superOverFlyPTTStruct(chanInd).overFlyPTTs{ ratTargInds(1) } ./ superOverFlyPTTStruct(chanInd).overFlyPTTs{ ratTargInds(2) };
                        subData{ratIndRow} = superOverFlyPTTStruct(chanInd).overFlyPTTs{ ratTargInds(1) } - superOverFlyPTTStruct(chanInd).overFlyPTTs{ ratTargInds(2) }; %Note: Not self-normalising like ratio

                    else
                        disp(['-# One or more ratio groups not in targsOfInterest #-'])
                        ratioData{ratIndRow} = NaN;
                        subData{ratIndRow} = NaN;
                    end
                end
                overRatioData{chanInd} = ratioData;
                overRatSubData{chanInd} = subData;
            end

            %Ratio
            figure
            overSubs = []; %Will store max Y lim data
            mAxis = []; %Will store max Y lim for later
            for chanInd = 1:size(overChansOfInterestActive,2)
                %overSubs{chanInd} = subplot(1,size(overChansOfInterestActive,2),chanInd);
                overSubs{chanInd} = subplot(size(overChansOfInterestActive,2),1,chanInd);
                meanData = [];
                semData = [];
                temp = [];
                for ratIndRow = 1:size(ratioCompGroups,1)
                    meanData(ratIndRow) = nanmean( overRatioData{chanInd}{ratIndRow} );
                    semData(ratIndRow) = nanstd( overRatioData{chanInd}{ratIndRow} ) / sqrt(size(overRatioData{chanInd}{ratIndRow},1));
                    temp = [temp, overRatioData{chanInd}{ratIndRow} ];
                end
                barwitherr(semData,meanData)
                hold on
                for IIDN = 1:size(temp,1)
                    scatter([1:size(temp,2)],temp(IIDN,:),[],flyColours(IIDN,:))
                    line([1:size(temp,2)],temp(IIDN,:),'Color', 'k')
                    for gInd = 1:size(temp,2)
                        text(gInd, temp(IIDN,gInd),num2str(IIDN),'Color', 'r')
                    end
                end
                xticklabels(num2str(ratioCompGroups))
                xlabel('Group/s')
                %title(chansOfInterest{chanInd})
                title(['PTT ratio',char(10),chansOfInterest{chanInd}])
                %barStats
                if size(temp,2) > 1
                    barStats(temp, alphaValue, [], 1);
                end
                if isempty(mAxis) == 1 || nanmax( get(gca,'YLim') ) > mAxis
                    mAxis = nanmax( get(gca,'YLim') );
                end
                %ylim([0.75,1.1]) %Force axis (May cut off values)
            end
            set(gcf,'Name','PTT ratios')
            %Rebalance axes
            for plotInd = 1:size(overSubs,2)
                set( overSubs{plotInd}, 'YLim', [0,mAxis] )
            end
            
            %Subtraction
            figure
            overSubs = []; %Will store max Y lim data
            mAxis = []; %Will store max Y lim for later
            for chanInd = 1:size(overChansOfInterestActive,2)
                %overSubs{chanInd} = subplot(1,size(overChansOfInterestActive,2),chanInd);
                overSubs{chanInd} = subplot(size(overChansOfInterestActive,2),1,chanInd);
                meanData = [];
                semData = [];
                temp = [];
                for ratIndRow = 1:size(ratioCompGroups,1)
                    meanData(ratIndRow) = nanmean( overRatSubData{chanInd}{ratIndRow} );
                    semData(ratIndRow) = nanstd( overRatSubData{chanInd}{ratIndRow} ) / sqrt(size(overRatSubData{chanInd}{ratIndRow},1));
                    temp = [temp, overRatSubData{chanInd}{ratIndRow} ];
                end
                barwitherr(semData,meanData)
                hold on
                for IIDN = 1:size(temp,1)
                    scatter([1:size(temp,2)],temp(IIDN,:),[],flyColours(IIDN,:))
                    line([1:size(temp,2)],temp(IIDN,:),'Color', 'k')
                    for gInd = 1:size(temp,2)
                        text(gInd, temp(IIDN,gInd),num2str(IIDN),'Color', 'r')
                    end
                end
                xticklabels(num2str(ratioCompGroups))
                xlabel('Group/s')
                %title(chansOfInterest{chanInd})
                title(['PTT subtraction',char(10),chansOfInterest{chanInd}])
                %barStats
                if size(temp,2) > 1
                    barStats(temp, alphaValue, [], 1);
                end
                if isempty(mAxis) == 1 || nanmax( get(gca,'YLim') ) > mAxis
                    mAxis = nanmax( get(gca,'YLim') );
                end
                %ylim([0.75,1.1]) %Force axis (May cut off values)
            end
            set(gcf,'Name','PTT subtractions')
            %Rebalance axes
            %for plotInd = 1:size(overSubs,2)
            %    set( overSubs{plotInd}, 'YLim', [0,mAxis] )
            %end
            
            %Mean subtracted subtraction
                %"Subception"
            figure
            overSubs = []; %Will store max Y lim data
            mAxis = []; %Will store max Y lim for later
            for chanInd = 1:size(overChansOfInterestActive,2)
                %overSubs{chanInd} = subplot(1,size(overChansOfInterestActive,2),chanInd);
                overSubs{chanInd} = subplot(size(overChansOfInterestActive,2),1,chanInd);
                
                plotData = [];
                temp = cell2mat(overRatSubData{chanInd});
                plotData = temp - nanmean(temp,2);
                
                meanData = [];
                semData = [];
                temp = [];
                for ratIndRow = 1:size(ratioCompGroups,1)
                    meanData(ratIndRow) = nanmean( plotData(:,ratIndRow) );
                    semData(ratIndRow) = nanstd( plotData(:,ratIndRow) ) / sqrt(size(plotData(:,ratIndRow),1));
                    temp = [temp, plotData(:,ratIndRow)];
                end
                barwitherr(semData,meanData)
                hold on
                for IIDN = 1:size(temp,1)
                    scatter([1:size(temp,2)],temp(IIDN,:),[],flyColours(IIDN,:))
                    line([1:size(temp,2)],temp(IIDN,:),'Color', 'k')
                    for gInd = 1:size(temp,2)
                        text(gInd, temp(IIDN,gInd),num2str(IIDN),'Color', 'r')
                    end
                end
                xticklabels(num2str(ratioCompGroups))
                xlabel('Group/s')
                %title(chansOfInterest{chanInd})
                title(['PTT mean sub subtraction',char(10),chansOfInterest{chanInd}])
                %barStats
                if size(temp,2) > 1
                    barStats(temp, alphaValue, [], 1);
                end
                if isempty(mAxis) == 1 || nanmax( get(gca,'YLim') ) > mAxis
                    mAxis = nanmax( get(gca,'YLim') );
                end
                %ylim([0.75,1.1]) %Force axis (May cut off values)
            end
            set(gcf,'Name','PTT mean sub subtractions')
            %Rebalance axes
            %for plotInd = 1:size(overSubs,2)
            %    set( overSubs{plotInd}, 'YLim', [0,mAxis] )
            %end
            
        else
            ['-# Caution: Group/s ',num2str(setdiff(reshape(ratioCompGroups, [1,numel(ratioCompGroups)]),targsOfInterest)),' requested for PTT ratio comparison but were not part of targsOfInterest #-']
            %In theory could have a system to remove elements that can't be processed and proceed with the rest, but cbf
        end
        
    else
        disp(['(No ratioCompGroups existed for comparison)'])
    end
%catch
%    ['## Failure to calculate PTT ratios ##']
%end

%morning
%%
%########

%Averaged freq analysis
viewWindow = [ 0.5 , 1.5*generalStruct.f1];
if exist('jittPSDNormMode') ~= 1
    jittPSDNormMode = 1; 
    ['-# Caution: jitter PSD normalisation mode not specified; Using default #-']
end
nullCoords = []; %Will be used in subtraction of PSDs from each other
for IIDN = 1:size(overVar,2)
    nullCoords{IIDN} = [ [overVar(IIDN).ancillary.f2:overVar(IIDN).ancillary.f2:nanmax(viewWindow)]-0.2 ; ...
        [overVar(IIDN).ancillary.f2:overVar(IIDN).ancillary.f2:nanmax(viewWindow)]+0.2 ];
    nullCoords{IIDN} = [nullCoords{IIDN} , ...
        [[overVar(IIDN).ancillary.f1:overVar(IIDN).ancillary.f1:nanmax(viewWindow)]-0.2 ; ...
        [overVar(IIDN).ancillary.f1:overVar(IIDN).ancillary.f1:nanmax(viewWindow)]+0.2 ]];
end
%QA for different jitt groups in all data
temp = [];
for IIDN = 1:size(overVar,2)
    temp( IIDN , : ) = overVar(IIDN).jittStruct.jittGroups; %Will crash if different number of jittGroups for one fly
        %(But not if a fly has the same numerb of jittGroups but different)
end
if size(unique(temp),1) ~= size(temp,2) && size(unique(temp),2) ~= size(temp,2) %Note: Dimensionality may vary
    ['-# Alert: Inconsistent jittGroups detected #-'] %Not theoretically a dealbreaker, but the below code will have to be adjusted to account for it
    crash = yes
end

for chanInd = 1:size(overChansOfInterestActive,2)
    
    %chanToPlot = chansOfInterestActive(chanInd); %Old
    
    %Quick QA for jittGroups
    for i = 1:size(overVar,2)
        if isequal(overVar(1).jittStruct.jittGroups,overVar(i).jittStruct.jittGroups) == 0
            ['## Alert: Differences in jitter types presented detected for dataset ',num2str(i), ' ##']
            crash = yes
        end
    end
        
    figure
    
    plotData = [];
    photPlotData = [];
    %standSize = [];
    standF = [];
    standViewWindowRange = [];
    for i = 1:size(overVar,2)
        chanToPlot = overChansOfInterestActive(i,chanInd); %New
        %Use first fly as standard
        if i == 1
            standF = overVar(i).jittStruct.data(chanInd).standardF;
            standViewWindowRange = overVar(i).jittStruct.data(chanInd).standViewWindowRange;
            jittGroups = overVar(i).jittStruct.jittGroups;
        end
        %Calculate some normalisation ahead of time (if applicable)
        if jittPSDNormMode == 2
            temp = [];
            tempPhot = [];
            for jittInd = 1:size( overVar(i).jittStruct.data(chanInd).psDataAv, 2 )
                temp = [temp, overVar(i).jittStruct.data(chanInd).psDataAv{jittInd}(standViewWindowRange{jittInd}) ]; %"Rip cell2mat"
                tempPhot = [tempPhot, overVar(i).jittStruct.phot.psDataPhotAv{jittInd}(standViewWindowRange{jittInd}) ]; 
            end
        end
        
        for jittInd = 1:size( overVar(i).jittStruct.data(chanInd).psDataAv, 2 )
            preData = [];
            prePhotData = [];
            %Pull data for fly
            preData = overVar(i).jittStruct.data(chanInd).psDataAv{jittInd};
            prePhotData = overVar(i).jittStruct.phot.psDataPhotAv{jittInd};
            %Normalise data
            if jittPSDNormMode ~= 0
                if jittPSDNormMode == 1
                    preData = preData / nanmax(preData(standViewWindowRange{jittInd}));
                    prePhotData = prePhotData / nanmax(prePhotData(standViewWindowRange{jittInd}));
                elseif jittPSDNormMode == 2
                    preData = preData / nanmax(temp);
                    prePhotData = prePhotData / nanmax(tempPhot);
                end
            end
            if size(preData,2) == size(standF{jittInd},2)
                plotData{jittInd}(i,:) = preData;
                photPlotData{jittInd}(i,:) = prePhotData;
            elseif abs(size(preData,2) - size(standF{jittInd},2)) < 0.05*size(standF{jittInd},2) %Less than 5% size difference
                %Resize data
                preData = imresize( preData, [1,size(standF{jittInd},2)], 'bilinear' );
                plotData{jittInd}(i,:) = preData;
                %Resize phot data
                prePhotData = imresize( prePhotData, [1,size(standF{jittInd},2)], 'bilinear' );
                photPlotData{jittInd}(i,:) = prePhotData;
            else
                ['## Alert: Significant size difference between dataset and standard ##']
                crash = yes
            end
        end
    end
    
    jittColours = winter(size(standF,2));
    
    %Averages, SEM and other delusions
    avData = [];
    semData = [];
    avPhotData = [];
    semPhotData = [];
    for jittInd = 1:size(standF,2)
        avData{jittInd} = nanmean( plotData{jittInd},1 );
        semData{jittInd} = nanstd( plotData{jittInd},[],1 ) / sqrt( size(plotData{jittInd},1) );
        avPhotData{jittInd} = nanmean( photPlotData{jittInd},1 );
        semPhotData{jittInd} = nanstd( photPlotData{jittInd},[],1 ) / sqrt( size(photPlotData{jittInd},1) );
    end
    
    %Plot each to a subplot
    for jittInd = 1:size(standF,2)
        subplot( size(standF,2),1,jittInd )
        %Data
        plot( standF{jittInd}(standViewWindowRange{jittInd})  , avData{jittInd}(standViewWindowRange{jittInd}) , 'Color', jittColours(jittInd,:) );
        hold on
        psShadeCoordsX = [standF{jittInd}(standViewWindowRange{jittInd}),flip(standF{jittInd}(standViewWindowRange{jittInd}))];
        psShadeCoordsY = [avData{jittInd}(standViewWindowRange{jittInd})+semData{jittInd}(standViewWindowRange{jittInd}),flip(avData{jittInd}(standViewWindowRange{jittInd})-semData{jittInd}(standViewWindowRange{jittInd}))]; %+- SEM
        fill(psShadeCoordsX, psShadeCoordsY, [jittColours(jittInd,:)]) %Error shading
        alpha(0.15)
        
        %Photodiode
        avPhotData{jittInd} = avPhotData{jittInd} + nanmax(avData{jittInd}); %Offset
        plot( standF{jittInd}(standViewWindowRange{jittInd})  , avPhotData{jittInd}(standViewWindowRange{jittInd}) , 'Color', jittColours(jittInd,:) );
        hold on
        photShadeCoordsX = [standF{jittInd}(standViewWindowRange{jittInd}),flip(standF{jittInd}(standViewWindowRange{jittInd}))];
        photShadeCoordsY = [avPhotData{jittInd}(standViewWindowRange{jittInd})+semPhotData{jittInd}(standViewWindowRange{jittInd}),flip(avPhotData{jittInd}(standViewWindowRange{jittInd})-semPhotData{jittInd}(standViewWindowRange{jittInd}))]; %+- SEM
        fill(photShadeCoordsX, photShadeCoordsY, [1.0,0.647,0.0]) %Error shading
        alpha(0.15)
        
        %Text
        text(nanmax(viewWindow),avData{jittInd}(end),['Jitter: ',num2str(jittGroups(jittInd))],'Color', jittColours(jittInd,:))
        text(nanmax(viewWindow),avPhotData{jittInd}(end),['Phot'],'Color', [1.0,0.647,0.0])
        
        ylim([0,0.01]) %Note: Will hide phot data
        
        %%title(['Jitter: ',num2str(jittGroups(jittInd)),' (',jittDescriptors{jittInd+1},'), N=',num2str(size(overVar,2)),' flies, Channel: ',num2str(chanToPlot), ' (',specIndex{specMethod},') (Per-fly max normalised)']) %+1 necessary because MATLAB indexing
        %%title(['Jitter: ',num2str(jittGroups(jittInd)),' (',jittDescriptors{jittInd+1},'), N=',num2str(size(overVar,2)),' flies, Channel: ',chansOfInterest{chanInd}, ' (',specIndex{specMethod},') (Per-fly max normalised)']) %Incorrect MATLAB descriptors
        titleStr = ['Jitter: ',num2str(jittGroups(jittInd)),' (',jittDescriptors{jittGroups(jittInd)+1},'), N=',num2str(size(overVar,2)),' flies, Channel: ',chansOfInterest{chanInd}, ' (',specIndex{specMethod},')'];
        titleStr = [titleStr,char(10),jittPSDNormIndex{jittPSDNormMode+1}];
        titleStr = [titleStr,char(10),'(Y limits forced)'];
        title(titleStr)
        xlabel(['Frequency (Hz)'])
        ylabel(['Power (a.u.)'])
        
        xlim(viewWindow)
    end
    
    %thisFigName = ['JittPSDs - Ch', num2str(chanToPlot)];
    thisFigName = ['JittPSDs - Ch: ', chansOfInterestStr{chanInd}];
    figStr = [];
    if useAutoList == 1
        set(gcf,'Name',[listToUse,' - ', thisFigName]);
    else
        set(gcf,'Name',['GrandAv - ', thisFigName]);
    end
    
    %###########
    %Save figure
    if saveFigs == 1
        try
            savePlot(saveName,thisFigName,figStr)
        catch 
            ['-# Alert: Failure to save plot #-']
        end
    end
    %###########
    
    %Difference plot
    diffData = [];
    for x = 1:size(standF,2)
        for y = x:size(standF,2)
            if x ~= y
                %Collect data
                temp = plotData{x};
                temp2 = plotData{y};
                if size(temp,2) ~= size(temp2,2) & abs( size(temp,2) - size(temp2,2) ) > 0.05*nanmax( [size(temp,2) , size(temp2,2)] )
                    ['## SIGNIFICANT DISPARITY BETWEEN JITTPSD SIZES ##']
                    crash = yes
                end
                temp = temp(:, 1:nanmin( [size(temp,2) , size(temp2,2)] ) ); %Resize to smallest
                temp2 = temp2(:, 1:nanmin( [size(temp,2) , size(temp2,2)] ) ); %Resize to smallest
                for IIDN = 1:size(temp,1) %Fly
                    %NaN f1 and f2
                    for i = 1:size(nullCoords{IIDN},2)
                        temp( IIDN, find( standF{x} >= nullCoords{IIDN}(1,i) & standF{x} <= nullCoords{IIDN}(2,i) ) ) = NaN;
                        temp2( IIDN, find( standF{y} >= nullCoords{IIDN}(1,i) & standF{y} <= nullCoords{IIDN}(2,i) ) ) = NaN;
                    end
                end
                diffData{ x,y } = temp - temp2;
            end
        end
    end
    %And plot
    figure
    a = 1;
    for x = 1:size(diffData,1)
        for y = x:size(diffData,2)
            if isempty(diffData{x,y}) ~= 1
                subplot( nansum(nansum(cellfun(@isempty,diffData) == 0)) , 1 , a )
                thisData = diffData{x,y}( :, standViewWindowRange{x});
                plot( standF{x}(standViewWindowRange{x}), nanmean(thisData,1), 'Color', nanmean( [jittColours(x,:);jittColours(y,:)] , 1 ) )
                hold on
                psShadeCoordsX = [standF{x}(standViewWindowRange{x}),flip(standF{x}(standViewWindowRange{x}))];
                psShadeCoordsY = [nanmean(thisData,1)+( nanstd(thisData,[],1) / sqrt(size(thisData,1)) ),...
                    flip(nanmean(thisData,1)-( nanstd(thisData,[],1) / sqrt(size(thisData,1)) ))]; %+- SEM
                fill(psShadeCoordsX, psShadeCoordsY, [nanmean( [jittColours(x,:);jittColours(y,:)] , 1 )]) %Error shading
                alpha(0.15)
                line([0,nanmax(standF{x}(standViewWindowRange{x}))],[0,0],'LineStyle', ':', 'Color', 'k')
                xlabel(['Frequency (Hz)'])
                ylabel(['Subtracted power (a.u.)'])
                titleStr = [num2str(x),'-',jittDescriptors{jittGroups(x)+1},'(J:',num2str(jittGroups(x)),')',' minus ',...
                    num2str(y),'-',jittDescriptors{jittGroups(y)+1},'(J:',num2str(jittGroups(y)),')'];
                titleStr = [titleStr,char(10),chansOfInterestStr{chanInd}];
                title(titleStr)
                a = a + 1;
            end
        end
    end
    set(gcf,'Name',[chansOfInterest{chanInd}, ' Subtracted Jitt PSDs'])
    
end
%%
%#######
%Av filtered ERPs
if doFilteredPlots == 1
    %filtInd = 1;
    for filtInd = 1:size(filterRanges,1)
        filtToPlot = filterRanges(filtInd,:);

        figure

        for chanInd = 1:size(overChansOfInterestActive,2)
            hasWarned = 0;

            %chanToPlot = chansOfInterestActive(chanInd); %Old

            groupPhotData = [];
            maxPhotAv = 0;

            titleStr = [];
            figStr = []; %Similar, but for fig autosaving
            vsStr = [repmat({' vs '},1,size(groupTargets,2)-1),{''}]; %Assembles a correct number of ' vs 's

            %figure
            for targInd = 1:size(targsOfInterest,2)%size(groupTargets,2)
                targToPlot = targsOfInterest(targInd); %Only used for interfaces with hyperData structures (since non-linear)

                flyData = [];
                for fly = 1:size(overVar,2)
                    chanToPlot = overChansOfInterestActive(i,chanInd); %New
                    
                    plotData = [];
                    groupAvData = [];
                    forcedMeanNormalisation = 0; 
                    if isempty( overVar(fly).filterStruct(filtInd).hyper(targToPlot).As ) ~= 1
                        %Assemble 3D and 2D matrices
                        %{
                        if showCorrected == 0
                            plotData = overVar(fly).groupHyper(targToPlot).Datas(chanToPlot,:,:); %Uncorrected
                        else
                            plotData = overVar(fly).groupHyper(targToPlot).DatasCorr(chanToPlot,:,:); %Corrected
                        end
                        %}
                        %Make flat data
                        %{
                        plotDataFlat = [];
                        for i = 1:size(plotData,3)
                            plotDataFlat(i,:) = plotData(:,:,i);
                        end
                        %}
                        %Apply post-hoc subsampling if requested
                        %{
                        if doPostHocSubSampling == 1
                            if size(overVar(fly).groupHyper(targToPlot).Datas(chanToPlot,:,:),3) >=  size(overVar(fly).groupHyper(postHocSubSampleTarget).Datas(chanToPlot,:,:),3)
                                plotData = plotData(:,:, [randsample( size(overVar(fly).groupHyper(targToPlot).Datas(chanToPlot,:,:),3) ,  size(overVar(fly).groupHyper(postHocSubSampleTarget).Datas(chanToPlot,:,:),3) )] );
                                    %Subsample according to size of postHocSubSampleTarget
                            else
                                if hasWarned ~= 1 %Simple console spam protection
                                    disp(['#- One or more groups contained less data than the postHocSubSampleTarget (G',num2str(postHocSubSampleTarget),' -#'])
                                    hasWarned = 1;
                                end
                            end
                        end
                        %}

                        %Means etc
                        %groupAvData = nanmean(plotData(1,:,:) ,3); %Row index of 1 because channel specification done earlier
                        groupAvData = overVar(fly).filterStruct(filtInd).data(chanInd).groupFilterDataAvs{targInd}; %Row index of 1 because channel specification done earlier
                        %groupDataSDs{targInd} = nanstd(groupPlotDatas{targInd}(1,:,:), [] ,3);

                        %Normalise if requested
                        if normaliseERPs == 1 || (normaliseERPs == 3 && isnan(overVar(fly).groupHyper(targToPlot).cycleColoursNum) == 1)
                            groupAvData = groupAvData / overVar(fly).descriptive.overOnsetAmpMeans{chanToPlot}; %Normalise by mean of every detected peak (Now from correct channel)
                            if normaliseERPs == 3
                                forcedMeanNormalisation = 1;
                            end
                        elseif normaliseERPs == 2
                            groupAvData = groupAvData / nanmax(abs(groupAvData)); %Normalise by own max of plot
                        elseif normaliseERPs == 3
                            %groupAvData = groupAvData / overVar(fly).descriptive.overColourMaxMeans{ overVar(fly).groupHyper(targToPlot).cycleColoursNum }(chanToPlot); %Normalise by mean of peaks of this colour (May crash if called when colours weren't specified)               
                            groupAvData = groupAvData / abs( overVar(fly).descriptive.overColourMaxMeans{ overVar(fly).groupHyper(targToPlot).cycleColoursNum }(chanToPlot) ); %9.35
                                %Note: Validity of this method for filtered data not confirmed
                        end

                        flyData(fly,:) = groupAvData; %Will only work as long as groupAvData has 1 row

                        %Photodiode display
                        %{
                        if chanInd == size(chansOfInterest,2) 
                            groupPhotData(fly,:) = nanmean(overVar(fly).groupHyper(targToPlot).Phots(1,:,:),3)*0.001; %Note non-targInd specifier and manipulated scale
                            %Normalise phot (if requested)
                            if normaliseERPs ~= 0
                                groupPhotData(fly,:) = groupPhotData(fly,:) / nanmean(groupPhotData(fly,:)); %Normalise by mean of self
                            end
                        end
                        %}
                    else
                        if fly ~= 1
                            flyData(fly,:) = NaN;
                            groupPhotData(fly,:) = NaN;
                        else
                            flyData(fly,1:captureWindowSize) = NaN;
                            groupPhotData(fly,1:captureWindowSize) = NaN;
                            ['#- Warning: Failure in first fly data; Array size guessed -#']
                        end
                    end
                end

                %Average/SD across flies
                flyDataAv = nanmean(flyData,1);
                %flyDataSEM = nanstd(flyData,1) / sqrt(size(flyData,1)); %Note: Not accurate if significant numbers of flies lack data for this group
                flyDataSEM = nanstd(flyData,1) / sqrt(nansum(isnan(flyData(:,1)) ~= 1)); %Note: Not accurate if significant numbers of flies lack data for this group

                %Plot
                plot(flyDataAv, 'Color', groupColours(targToPlot,:))
                hold on
                groupShadeCoordsX = [1:1:size(flyDataAv,2),size(flyDataAv,2):-1:1];
                groupShadeCoordsY = [flyDataAv+flyDataSEM,flip(flyDataAv-flyDataSEM)];
                fill(groupShadeCoordsX, groupShadeCoordsY, groupColours(targToPlot,:)) %Error shading
                alpha(0.15)

                if doIndivLines == 1
                    %Plot individual flies
                    for i = 1:size(flyData,1)
                        %{
                        thisFlyUniqueNumber = [];
                        for fly = 1:size(uniqueFlies,1)
                            if nansum(uniqueFlies{fly} == [num2str(dataList(i,1)),'-',num2str(dataList(i,2))]) == size(uniqueFlies{fly},2)
                                %BOOTLEG STRING MATCHING CODE
                                thisFlyUniqueNumber = fly;
                            end
                        end
                        %}
                        thisFlyUniqueNumber = overVar(i).ancillary.thisFlyUniqueNumber;
                        plot(flyData(i,:), ':', 'LineWidth', 2, 'Color', groupColours(targToPlot,:)) %Colours consistent with group
                        plot(flyData(i,:), '--', 'LineWidth', 2, 'Color', flyColours(thisFlyUniqueNumber,:))
                        %hold on
                        %pause(1)
                    end
                end

                %Ancillary text
                safePosS = linspace(0.2*captureWindowSize,0.8*captureWindowSize,size(targsOfInterest,2));
                safePos = floor(safePosS(targInd));
                %text(safePos,flyDataAv(floor(safePos)), ['G:',num2str(targToPlot),'(',num2str(targInd),')',',C:',num2str(chanToPlot)], 'Color', 'r')
                text(safePos,flyDataAv(floor(safePos)), ['G:',num2str(targToPlot),'(',num2str(targInd),')',',C:',chansOfInterestStr{chanInd}], 'Color', 'r')

                %Strings
                if chanInd == size(overChansOfInterestActive,2) %Only assemble on final loop
                    titleStr = [titleStr, groupDescriptors{targToPlot}, '(J:',num2str(groupJitters(targToPlot)),')', vsStr{targInd}, char(10)];
                    if forcedMeanNormalisation == 1
                        titleStr = [titleStr,char(10),'(Forced mean norm.)'];
                    end
                end

                %Photodiode
                %{
                if chanInd == size(chansOfInterest,2)
                    %photScale = abs(nanmax(flyDataAv)-nanmin(flyDataAv)) * 0.2; %Scale photodiode to be 20% of max group amplitudes
                    %{
                    if normaliseERPs ~= 0
                        photScale = 1; %Scale photodiode to be 1
                    else
                        photScale = abs(nanmax(flyDataAv)-nanmin(flyDataAv)) * 0.2; %Scale photodiode to be 20% of max group amplitudes
                    end
                    %}
                    plotData = normalize(groupPhotData, 2, 'range', [-1 1]);
                    if normaliseERPs == 0
                        plotData = plotData * ( abs(nanmax(flyDataAv)-nanmin(flyDataAv)) * 0.2 );
                    end
                    %plotData = plotData ./ nanmax(plotData,[],2);
                    flyPhotAv = nanmean(plotData,1);
                    flyPhotSEM = nanstd(plotData,1) / sqrt(size(plotData,1));
                    %{
                    fixFactor = NaN;
                    if isempty(fixedPhotodiodeScale) ~= 1 && nanmax(abs(flyPhotAv)) > fixedPhotodiodeScale
                        fixFactor = fixedPhotodiodeScale / nanmax(abs(flyPhotAv));
                        flyPhotAv = flyPhotAv * fixFactor; %"More like...Fear Factor"
                        flyPhotSEM = flyPhotSEM * fixFactor;
                    end
                    %}
                    groupPhotShadeCoordsX = [1:1:size(flyPhotAv,2),size(flyPhotAv,2):-1:1];
                    %groupPhotShadeCoordsY = [flyPhotAv+0.5*flyPhotSEM,flip(flyPhotAv-0.5*flyPhotSEM)]; %Evidence has indicated that halving SEM may not be correct
                    groupPhotShadeCoordsY = [flyPhotAv+flyPhotSEM,flip(flyPhotAv-flyPhotSEM)]; %+- SEM
                    groupPhotShadeCoordsY = groupPhotShadeCoordsY - groupPhotShadeCoordsY(1); %Offset start
                    fill(groupPhotShadeCoordsX, groupPhotShadeCoordsY, [1.0,0.647,0.0]) %Error shading
                        %Note: Scale and shading of photodiode signal is for display purposes only
                    alpha(0.15)
                    safePos = floor(0.5*size(groupPhotShadeCoordsY,2));
                    text(safePos,groupPhotShadeCoordsY(safePos+targInd), ['G:',num2str(targToPlot),'(',num2str(targInd),')'], 'Color', groupColours(targToPlot,:))
                end
                %}
            end

        end
        %{
        %Photodiode
        flyPhotAv = nanmean(groupPhotData,1);
        %flyPhotSEM = nanstd(groupPhotData,1) / sqrt(size(groupPhotData,1));
        flyPhotSEM = nanstd(groupPhotData,1) / sqrt(nansum(isnan(groupPhotData(:,1))~= 1));
        fixFactor = NaN;
        if isempty(fixedPhotodiodeScale) ~= 1 && nanmax(abs(flyPhotAv)) > fixedPhotodiodeScale
            fixFactor = fixedPhotodiodeScale / nanmax(abs(flyPhotAv));
            flyPhotAv = flyPhotAv * fixFactor; %"More like...Fear Factor"
            flyPhotSEM = flyPhotSEM * fixFactor;
        end
        groupPhotShadeCoordsX = [1:1:size(flyPhotAv,2),size(flyPhotAv,2):-1:1];
        %groupPhotShadeCoordsY = [flyPhotAv+0.5*flyPhotSEM,flip(flyPhotAv-0.5*flyPhotSEM)]; %Evidence has indicated that halving SEM may not be correct
        groupPhotShadeCoordsY = [flyPhotAv+flyPhotSEM,flip(flyPhotAv-flyPhotSEM)]; %+- SEM
        groupPhotShadeCoordsY = groupPhotShadeCoordsY - groupPhotShadeCoordsY(1); %Offset start
        fill(groupPhotShadeCoordsX, groupPhotShadeCoordsY, [1.0,0.647,0.0]) %Error shading
            %Note: Scale and shading of photodiode signal is for display purposes only
        alpha(0.15)
        safePos = floor(0.5*size(groupPhotShadeCoordsY,2));
        text(safePos,groupPhotShadeCoordsY(safePos+targInd), ['G:',num2str(targToPlot),'(',num2str(targInd),')'], 'Color', groupColours(targToPlot,:))
        %}
        %Further ancillaries
        yPull = get(gca,'YLim');
        line([ captureWindowSize*(-captureWindowGeometryActive(1)),captureWindowSize*(-captureWindowGeometryActive(1)) ],[yPull(1),yPull(2)], 'LineStyle', ':', 'Color', 'k') %Marks middle of stimulus cycle
            %Uses captureWindowGeometryActive to back-calculate centroid position
        %{
        if didSine == 0
            line([ (captureWindowSize/2)-(baselineSize*captureWindowSize) , (captureWindowSize/2)-(baselineSize*captureWindowSize) ], [-500,500], 'Color', 'k') %Baseline end
            line([ (captureWindowSize/2) , (captureWindowSize/2) ], [-500,500], 'Color', 'k') %Baseline start
                %Note: Critical assumption of capture window symmetry 
        end
        %}

        xlim([1, captureWindowSize])
        %titleStr = [titleStr,' for channel/s ',num2str(chansOfInterestActive)];
        titleStr = [titleStr,' for channel/s ',num2str(overChansOfInterestActive(:,1)'),' vs ',num2str(overChansOfInterestActive(:,2)')];

        if showCorrected == 1
            titleStr = [titleStr, char(10), ' (',correctedIndex{showCorrected+1},', ' baselineCorrectionDescIndex{baselineCorrectionMethod+1}, ')'];
        else
            titleStr = [titleStr, char(10), ' (',correctedIndex{showCorrected+1},')'];
        end
        if normaliseERPs ~= 0
            titleStr = [titleStr, normaliseIndex{normaliseERPs}];
        else
            titleStr = [titleStr, '(Not normalised)'];
        end
        %{
        if normaliseERPs == 1
            titleStr = [titleStr, '(All-peaks-amplitude normalised)'];
        elseif normaliseERPs == 2 
            titleStr = [titleStr, '(Self-max normalised)'];
        end
        %}
        titleStr = [titleStr, char(10), 'Grand fly average (N=',num2str(size(flyData,1)),')'];
        if useAutoList == 1
            titleStr = [titleStr, char(10), 'List: ',listToUse];
        end
        titleStr = [titleStr, char(10), 'Rereference mode: ', rerefIndex{rerefMode}];
        figStr = [figStr,rerefIndex{rerefMode}]; %Add reref info to filename
        %{
        if doSubSampling == 1
            titleStr = [titleStr,char(10),'(Data subsampled)'];
        end
        if doPostHocSubSampling == 1
             titleStr = [titleStr,char(10),'(Data post-hoc subsampled)'];
        end
        %}
        titleStr = [titleStr, char(10), 'Filter: ',num2str(filtToPlot(1)),' - ',num2str(filtToPlot(2)),'Hz'];
        figStr = [figStr,'_Filtered',num2str(filtToPlot(1)),'-',num2str(filtToPlot(2))]; %Add reref info to filename
        %titleStr = [titleStr,' for channel/s ',num2str(chansOfInterest), ' (',correctedIndex{showCorrected+1},')'];
        title(titleStr)
        xlabel(['Time (ms)'])
        pulledYLims = get(gca,'YLim'); %Used for MMN plot
        thisFigName = ['GrandAvFilteredERP_',num2str(filtToPlot(1)),' - ',num2str(filtToPlot(2)),'Hz'];
        set(gcf,'Name',[thisFigName]);

        %###########
        %Save figure
        if saveFigs == 1
            try
                savePlot(saveName,thisFigName,figStr)
            catch 
                ['-# Alert: Failure to save plot #-']
            end
        end
        %###########
    end
end

%#######
%%
%########

if isfield(overVar, 'overChron') == 1
    %Grand average chronLinePlot for sparsening
    
    flyLineData = [];
    flyPhotData = [];
    flyTrueData = [];
    flySparseningOrientation = [];
    
    blockedData = struct; %Groups data within fly
    As = repmat( 1 , 1 , nanmax(flyBlockOrderList(:,3)) );
    for i = 1:size(overVar,2)
        %Collect data
        for chanInd = 1:size(overChansOfInterestActive,2)
            flyLineData{chanInd}(i,:) = overVar(i).overChron.chronLinePlot.lineData(chanInd,:); %Will fail probs if number of blocks differed for some reason
        end
        flyPhotData(i,:) = overVar(i).overChron.chronLinePlot.linePhotData;
        flyTrueData(i,:) = overVar(i).overChron.chronLinePlot.trueData;
        if flyTrueData(i,1) == 0 %Test if starting from 0 (Note: Will not be accurate in shortened protocols that start from non-zero)
            flySparseningOrientation(i,1) = 1;
        else
            flySparseningOrientation(i,1) = -1;
        end
        
        %Separate into blocks
        for chanInd = 1:size(overChansOfInterestActive,2)
            blockedData(flies(i).withinFlyBlockOrder).flyLineData{chanInd}( As(flies(i).withinFlyBlockOrder) , :) =  flyLineData{chanInd}(i,:);
        end
        blockedData(flies(i).withinFlyBlockOrder).flyPhotData( As(flies(i).withinFlyBlockOrder) , : ) =  flyPhotData(i,:);
        blockedData(flies(i).withinFlyBlockOrder).flyTrueData( As(flies(i).withinFlyBlockOrder) , : ) =  flyTrueData(i,:);
        As(flies(i).withinFlyBlockOrder) = As(flies(i).withinFlyBlockOrder) + 1;
        
    end
    
    %Plot within-fly
    %Warning: This plot is sensitive to the normaliseERPs setting that was used to generate the underlying data
    figure
    for unFly = 1:size(uniqueFlies,1)
        subplot(size(uniqueFlies,1),1,unFly)
        thisFlyExpBlockNum = size(blockedData(unFly).flyPhotData,2); %How many blocks constituted the experiment
            %Note: May crash if this varied between trials (blocks) on the fly
        
        for blockOrderNum = 1:size(blockedData(unFly).flyPhotData,1)
            xCoords = [1+(thisFlyExpBlockNum*(blockOrderNum-1)):thisFlyExpBlockNum*blockOrderNum];
            %LFP data per channel
            for chanInd = 1:size(overChansOfInterestActive,2)
                %chanToPlot = chansOfInterestActive(chanInd); %Old
                chanToPlot = overChansOfInterestActive(unFly,chanInd); %New; Note: May crash here if disparity between overVar and unFlies 
                %QA
                if size(uniqueFlies,1) ~= size(overVar,2)
                    ['## Alert: Dynamicised channel assumptions not valid here ##']
                    writeCodeForThis = yes
                end
                plot(xCoords,blockedData(unFly).flyLineData{chanInd}(blockOrderNum,:), 'LineWidth', 1.25, 'Color', chanColours(chanInd,:))
                hold on
                text(xCoords(floor(thisFlyExpBlockNum*0.5)), blockedData(unFly).flyLineData{chanInd}( blockOrderNum,floor(thisFlyExpBlockNum*0.5) ) , ['C:',num2str(chanToPlot),',B:',num2str(blockOrderNum)], 'Color', 'r')
            end
            %Phot and true data
            plot(xCoords,blockedData(unFly).flyPhotData(blockOrderNum,:), 'LineStyle', ':', 'LineWidth', 1, 'Color', [1.0,0.647,0.0] ) %Orange
            text(xCoords(floor(thisFlyExpBlockNum*0.5)), blockedData(unFly).flyPhotData( blockOrderNum,floor(thisFlyExpBlockNum*0.5) ) , ['Photodiode'], 'Color', [1.0,0.647,0.0])
            plot(xCoords,blockedData(unFly).flyTrueData(blockOrderNum,:), 'LineStyle', ':', 'LineWidth', 1, 'Color', 'k' )
            text(xCoords(floor(thisFlyExpBlockNum*0.5)), blockedData(unFly).flyTrueData( blockOrderNum,floor(thisFlyExpBlockNum*0.5) ) , ['True'], 'Color', 'k' )
            line([xCoords(end),xCoords(end)],[0,nanmax(blockedData(unFly).flyPhotData(blockOrderNum,:))], 'LineStyle', ':', 'Color', 'k') 
        end
        
        xlim([1,xCoords(end)])
        if normaliseERPs ~= 1
            title(uniqueFlies{unFly})
        else
            title([uniqueFlies{unFly}, ' (Normalised)'])
        end
    end
    
    thisFigName = 'ChronLineUniques';
    if useAutoList == 1
        set(gcf,'Name',[listToUse,' - ', thisFigName]);
    else
        set(gcf,'Name',['GrandAv - ', thisFigName]);
    end
    
    %###########
    %Save figure
    if saveFigs == 1
        try
            savePlot(saveName,thisFigName,figStr)
        catch 
            ['-# Alert: Failure to save plot #-']
        end
    end
    %###########
    
    %Plot over sparsening direction
    figure
    
    b = 1;
    for sparsDir = 1:-2:-1
        subplot(2,2,b)
        
        lineData = [];
        photData = [];
        trueData = [];
        chanAs = repmat( 1 , 1 , size(overChansOfInterestActive,2) );
        c = 1;
        for i = 1:size(flySparseningOrientation,1)
            if flySparseningOrientation(i) == sparsDir
                for chanInd = 1:size(overChansOfInterestActive,2)
                    lineData{chanInd}(chanAs(chanInd),:) = flyLineData{chanInd}(i,:);
                    if normaliseERPs == 2
                        lineData{chanInd}(chanAs(chanInd),:) = lineData{chanInd}(chanAs(chanInd),:) / nanmax(lineData{chanInd}(chanAs(chanInd),:));
                            %Note: There is a strong possibility that this is a normalisation applied to already normalised data
                    end
                    chanAs(chanInd) = chanAs(chanInd) + 1;
                end
                photData = [photData ; flyPhotData(i,:)];
                trueData = [trueData ; flyTrueData(i,:)];
                if normaliseERPs == 2
                    photData(c,:) = photData(c,:) / nanmax(photData(c,:));
                    trueData(c,:) = trueData(c,:) / nanmax(trueData(c,:));
                end
                c = c + 1;
            end
        end
        %Calculate means and things
        lineDataMean = []; lineDataSEM = [];
        for chanInd = 1:size(overChansOfInterestActive,2)
            lineDataMean(chanInd,:) = nanmean(lineData{chanInd},1);
            lineDataSEM(chanInd,:) = nanstd(lineData{chanInd},1) / sqrt( size(lineData{chanInd},1) );
        end
        photDataMean = []; trueDataMean = [];
        photDataSEM = []; trueDataSEM = [];
        photDataMean = nanmean(photData,1);
        photDataSEM = nanstd(photData,1) / sqrt(size(photData,1));
        trueDataMean = nanmean(trueData,1);
        trueDataSEM = nanstd(trueData,1) / sqrt(size(trueData,1));
        
        %Plot means
        for chanInd = 1:size(overChansOfInterestActive,2)
            %chanToPlot = chansOfInterestActive(chanInd); %Old
            noNewCaseYet = yes
            plot(lineDataMean(chanInd,:), 'LineWidth', 1.25, 'Color', chanColours(chanInd,:))
            hold on
            text(floor(0.5*size(lineDataMean,2)), lineDataMean(chanInd,floor(0.5*size(lineDataMean,2))) , ['C:',num2str(chanToPlot)], 'Color', 'r')
        end
        plot(photDataMean, 'LineStyle', ':', 'LineWidth', 1, 'Color', [1.0,0.647,0.0] ) %Orange
        text(floor(0.5*size(photDataMean,2)), photDataMean(floor(0.5*size(photDataMean,2))) , ['Photodiode'], 'Color', [1.0,0.647,0.0])
        plot(trueDataMean, 'LineStyle', ':', 'LineWidth', 1, 'Color', 'k' )
        text(floor(0.5*size(trueDataMean,2)), trueDataMean(floor(0.5*size(trueDataMean,2))) , ['True'], 'Color', 'k' )
        %Error shading
        for chanInd = 1:size(overChansOfInterestActive,2)
            shadeCoordsX = [1:1:size(lineDataMean,2),size(lineDataMean,2):-1:1];
            shadeCoordsY = [lineDataMean(chanInd,:)+lineDataSEM(chanInd,:),flip(lineDataMean(chanInd,:)-lineDataSEM(chanInd,:))];
            fill(shadeCoordsX, shadeCoordsY, chanColours(chanInd,:)) %Error shading
            alpha(0.10)
        end
        shadeCoordsX = [1:1:size(photDataMean,2),size(photDataMean,2):-1:1];
        shadeCoordsY = [photDataMean+photDataSEM,flip(photDataMean-photDataSEM)];
        fill(shadeCoordsX, shadeCoordsY, [1.0,0.647,0.0]) %Error shading
        alpha(0.10)
        shadeCoordsX = [1:1:size(trueDataMean,2),size(trueDataMean,2):-1:1];
        shadeCoordsY = [trueDataMean+trueDataSEM,flip(trueDataMean-trueDataSEM)];
        fill(shadeCoordsX, shadeCoordsY, 'k') %Error shading
        alpha(0.10)
        
        xlim([1,size(lineDataMean,2)])
        
        titleStr = ['Direction: ',num2str(sparsDir),' (N=',num2str(size(lineData{b},1)),')'];
        if normaliseERPs ~= 0
            titleStr = [titleStr, char(10), normaliseIndex{normaliseERPs}]; %Note: It appears like this uses the value it was processed with and cannot be post-hoc adjusted
        else
            titleStr = [titleStr, char(10), '(Not normalised)']; 
        end
        title(titleStr)
        
        %Tack-on, deviance calculation
        subplot(2,2,b+2)
        
        devianceData = [];
        for chanInd = 1:size(overChansOfInterestActive,2)
            devianceData(chanInd,:) = lineDataMean(chanInd,:) - trueDataMean; %Note: Will almost certainly look weird if normalising not used
            %{
            %Raw values
            plot(devianceData(chanInd,:), 'LineWidth', 1.5, 'LineStyle', '- -', 'Color', chanColours(chanInd,:))
            hold on
            text(floor(0.5*size(devianceData,2)), devianceData(chanInd,floor(0.5*size(devianceData,2))) , ['Orig.'], 'Color', 'r')
            %Log-transformed data
            plotData = log(devianceData(chanInd,:));
            plot([1:size(devianceData,2)],plotData, 'LineWidth', 2, 'LineStyle', ':', 'Color', chanColours(chanInd,:))
            hold on
            text(floor(0.5*size(plotData,2)), plotData(floor(0.5*size(devianceData,2))) , ['Log'], 'Color', 'r')
            %}
            %Transformed by true data
            plotData = devianceData(chanInd,:)./trueDataMean;
            plot([1:size(plotData,2)],plotData, 'LineWidth', 2, 'LineStyle', ':', 'Color', chanColours(chanInd,:))
            hold on
            text(floor(0.5*size(plotData,2)), plotData(floor(0.5*size(devianceData,2))) , ['Div.'], 'Color', 'r') 
        end
        
        line([1,size(devianceData,2)],[0,0], 'LineStyle', ':', 'Color', 'k')
        ylabel('Deviance from true')
        xlim([1,size(devianceData,2)])
        
        b = b + 1;
    end
    
    thisFigName = 'ChronLineDirectional';
    if useAutoList == 1
        set(gcf,'Name',[listToUse,' - ', thisFigName]);
    else
        set(gcf,'Name',['GrandAv - ', thisFigName]);
    end
    
    %###########
    %Save figure
    if saveFigs == 1
        try
            savePlot(saveName,thisFigName,figStr)
        catch 
            ['-# Alert: Failure to save plot #-']
        end
    end
    %###########
    
end

%########

if isfield(overVar,'red') == 1
    
    plotData = [];
    for IIDN = 1:size(overVar,2)
        %QA
        if overVar(IIDN).ancillary.modernData ~= 1
            ['-- Non-modern data detected for red analysis --'] %Theoretically not a dealbreaker, but too much behavInterp relies on modernData (probably)
            continue
        end
        
        redAcMean = [];
        redCol = find(contains(overVar(IIDN).behavCorrectedLabels,'redLightBool'));   
        acCol = find(contains(overVar(IIDN).behavCorrectedLabels,'rawActivity'));
        %redUns = unique(overVar(IIDN).behavInterp(:,14))';
        redUns = unique(overVar(IIDN).behavInterp(:,redCol))';
        for redSide = redUns
            %redSide = redUns(redIn);
            %redAc{redSide+1} = behavInterp( SplicedRedLightBin == redSide ,13); %Col 13 - acRaw
            %redAcMean(redSide+1) = nanmean( redAc{redSide+1} );
            %redAcMean(redSide+1) = nanmean( overVar(IIDN).behavInterp( overVar(IIDN).behavInterp(:,14) == redSide ,13) );
            redAcMean(redSide+1) = nanmean( overVar(IIDN).behavInterp( overVar(IIDN).behavInterp(:,redCol) == redSide ,acCol) );
            %redAcSD(redSide+1) = nanstd( redAc{redSide+1} );
            %redAcSEM(redSide+1) = nanstd( redAc{redSide+1} ) / sqrt( size( redAc{redSide+1} , 1 ) );
            %highRed(redSide+1) = nanmax(redAc{redSide+1});
            plotData(IIDN,redSide+1) = redAcMean(redSide+1);
        end        
    end
    
    plotMean = nanmean(plotData,1);
    plotSEM = nanstd( plotData,[],1 ) / sqrt(size(plotData,1));
    
    %Plot
    figure
    numRedStates = size(redUns,2);
    %{
    for redSide = redUns
        subplot( numRedStates , 3 , [ (redSide *3) + 1 : (redSide *3) + 2 ] )
        plot( redAc{redSide+1} , 'Color', [1,0,0]*(redSide / nanmax(redUns) ) )
        title(['Activity during red = ',num2str(redSide)])
        ylim([0,nanmax(highRed)])
    end
    %}
    %subplot( numRedStates , 3 , [ 3 : 3 : ((numRedStates-1) *3) + 3 ] )
    barwitherr( plotSEM , plotMean )
    hold on
    for i = 1:size(plotData,2)
        scatter(repmat(i,size(plotData,1),1),plotData(:,i) ,[], [1,0,0]*(redSide / nanmax(redUns) ));
    end
    hold off
    xticks(redUns+1)
    xticklabels(redUns)
    title(['Pooled red state ac/inac mean +- SEM'])
    set(gcf, 'Name', ['Pooled activity not red/red'])
    barStats(plotData,alphaValue, [], 1);
    
    %Delta plot
    plotDelta = plotData - plotData(:,1);
    plotMean = nanmean(plotDelta,1);
    plotSEM = nanstd( plotDelta,[],1 ) / sqrt(size(plotDelta,1));
    figure
    numRedStates = size(redUns,2);
    %subplot( numRedStates , 3 , [ 3 : 3 : ((numRedStates-1) *3) + 3 ] )
    barwitherr( plotSEM , plotMean )
    hold on
    for i = 1:size(plotDelta,2)
        scatter(repmat(i,size(plotDelta,1),1),plotDelta(:,i) ,[], [1,0,0]*(redSide / nanmax(redUns) ));
    end
    for IIDN = 1:size(plotDelta,1)
        line([1:size(plotDelta,2)],plotDelta(IIDN,:))
    end
    hold off
    xticks(redUns+1)
    xticklabels(redUns)
    title(['Pooled red state delta ac/inac mean +- SEM'])
    set(gcf, 'Name', ['Pooled delta activity not red/red'])
    barStats(plotDelta,alphaValue, [], 1);
    
    %Fraction delta plot %i.e. "How fractionally higher/lower was other states than first"
    plotFracDelta = plotData ./ plotData(:,1);
    plotMean = nanmean(plotFracDelta,1);
    plotSEM = nanstd( plotFracDelta,[],1 ) / sqrt(size(plotFracDelta,1));
    figure
    numRedStates = size(redUns,2);
    %subplot( numRedStates , 3 , [ 3 : 3 : ((numRedStates-1) *3) + 3 ] )
    barwitherr( plotSEM , plotMean )
    hold on
    for i = 1:size(plotFracDelta,2)
        scatter(repmat(i,size(plotFracDelta,1),1),plotFracDelta(:,i) ,[], [1,0,0]*(redSide / nanmax(redUns) ));
    end
    for IIDN = 1:size(plotFracDelta,1)
        line([1:size(plotFracDelta,2)],plotFracDelta(IIDN,:))
    end
    hold off
    xticks(redUns+1)
    xticklabels(redUns)
    title(['Pooled red state fraction delta ac/inac mean +- SEM'])
    set(gcf, 'Name', ['Pooled fraction delta activity not red/red'])
    barStats(plotFracDelta,alphaValue, [], 1);
    
    %Mean subtracted plot
    meanSubDelta = plotData - nanmean(plotData,2);
    plotMean = nanmean(meanSubDelta,1);
    plotSEM = nanstd( meanSubDelta,[],1 ) / sqrt(size(meanSubDelta,1));
    figure
    numRedStates = size(redUns,2);
    %subplot( numRedStates , 3 , [ 3 : 3 : ((numRedStates-1) *3) + 3 ] )
    barwitherr( plotSEM , plotMean )
    hold on
    for i = 1:size(meanSubDelta,2)
        scatter(repmat(i,size(meanSubDelta,1),1),meanSubDelta(:,i) ,[], [1,0,0]*(redSide / nanmax(redUns) ));
    end
    for IIDN = 1:size(meanSubDelta,1)
        line([1:size(meanSubDelta,2)],meanSubDelta(IIDN,:))
    end
    hold off
    xticks(redUns+1)
    xticklabels(redUns)
    title(['Pooled red state mean-subtracted delta ac/inac mean +- SEM'])
    set(gcf, 'Name', ['Pooled mean-subtracted delta activity not red/red'])
    barStats(meanSubDelta,alphaValue, [], 1);
    
end

%-----------

%Plot some vaguely useful metrics about block composition
condTypeIndex = [{'carrier'},{'oddball'}];
jittTypeIndex = [{'varying'},{'carrieronly'},{'phasic'},{'uniform'},{'jittering'}];
blockTypeAll = [];
blockTypeSep = [];
%blockOddPrecDistAll = cell(1,3); %Hardcoded 3 max conditions
blockOddPrecDistAll = repmat( {cell(1,5)} , 1, 2 ); %2 conditions, 5 unique jittering states
    %-1 : ???, 0 : Carrieronly, 1 - Phasic, 2 - Uniform, 3 - Jittering
        %For indexing purposes, +2 applied 
blockOddPrecDistSep = [];
for IIDN = 1:size(overVar,2)
    blockTypeAll = [blockTypeAll, [overVar(IIDN).blockStruct.sentConditionNum]];
    blockTypeSep{IIDN} = [overVar(IIDN).blockStruct.sentConditionNum];
    %blockOddPrecDistSep{IIDN} = cell(1,3);
    blockOddPrecDistSep{IIDN} = repmat( {cell(1,5)} , 1, 2 );
    for bInd = 1:size(overVar(IIDN).blockStruct,2)
        if any( ~isnan( overVar(IIDN).blockStruct(bInd).allPeaksList.distFromLastOddball ) )
            %blockOddPrecDistAll{ overVar(IIDN).blockStruct(bInd).sentConditionNum } = [blockOddPrecDistAll{ overVar(IIDN).blockStruct(bInd).sentConditionNum }; overVar(IIDN).blockStruct(bInd).allPeaksList.distFromLastOddball'];
            %blockOddPrecDistSep{IIDN}{ overVar(IIDN).blockStruct(bInd).sentConditionNum } = overVar(IIDN).blockStruct(bInd).allPeaksList.distFromLastOddball';
                %These two lines acquire *all* precedes (As in, cumulative and final)
            temp = overVar(IIDN).blockStruct(bInd).allPeaksList.distFromLastOddball'; %Acquire histories
            temp(1) = NaN; %Just in case
            temp = temp( find(temp == 0)-1 ); %Only select final precede of each oddball instance
            temp = temp( ~isnan(temp) ); %Remove NaN first element
            %blockOddPrecDistAll{ overVar(IIDN).blockStruct(bInd).sentConditionNum } = [blockOddPrecDistAll{ overVar(IIDN).blockStruct(bInd).sentConditionNum }; temp ]; %Does not account for jittering state
            blockOddPrecDistAll{ overVar(IIDN).blockStruct(bInd).sentConditionNum }{ overVar(IIDN).blockStruct(bInd).jittering+2 } = [blockOddPrecDistAll{ overVar(IIDN).blockStruct(bInd).sentConditionNum }{ overVar(IIDN).blockStruct(bInd).jittering+2 }...
                ; temp ];
            %blockOddPrecDistSep{IIDN}{ overVar(IIDN).blockStruct(bInd).sentConditionNum } = temp; %Old, un-jittering-separated
            blockOddPrecDistSep{IIDN}{ overVar(IIDN).blockStruct(bInd).sentConditionNum }{ overVar(IIDN).blockStruct(bInd).jittering+2 } = temp;
        end
    end
end
%Cleanup
    %Deprecated because too many conditions now, easier to do in post
%{
for condType = size(blockOddPrecDistAll,2):-1:1
    if ~isempty( blockOddPrecDistAll{condType} )
        blockOddPrecDistAll{condType} = blockOddPrecDistAll{condType}( ~isnan(blockOddPrecDistAll{condType}) );
    else
        blockOddPrecDistAll{condType} = [];
    end
end
%}

%Plot
%{
for condType = 1:size(blockOddPrecDistAll,2)
    figure
    try
        histogram( blockOddPrecDistAll{condType} , [unique(blockOddPrecDistAll{condType});nanmax(blockOddPrecDistAll{condType}+1)] )
    end
    title(['Hist. of oddball distances (Cond. type ',num2str(condType),')'])
end
%}
for condType = 1:size(blockOddPrecDistAll,2)
    for jType = 1:size(blockOddPrecDistAll{condType},2)
        if ~isempty( blockOddPrecDistAll{condType}{jType} )
            figure
            histogram( blockOddPrecDistAll{condType}{jType}, [unique(blockOddPrecDistAll{condType}{jType});nanmax(blockOddPrecDistAll{condType}{jType}+1)] )
            yTicks = get(gca,'YTick');
            yticklabels(round((yTicks/numel(blockOddPrecDistAll{condType}{jType}))*100,1))
            ylabel('% of all dist.')
            xlabel('Odd. dist. from last odd')
            title(['Hist. of oddball distances (Cond. # ',num2str(condType),'-',condTypeIndex{condType},' : Jitt. ',jittTypeIndex{jType},')'])
            set(gcf,'Name',['Pooled oddb distances cond ',condTypeIndex{condType},' ',jittTypeIndex{jType},])
        end
    end
end

%-----------

%--------------------------------------------------------------------------

%Make for loop to save figures
%Mk 3 (Borrowed from SASIFRAS)
if automatedSavePlots == 1
    tic
    disp(['---- COMMENCING AUTOMATED FIGURE SAVING ----'])
    
    if clearOldFigures == 1
        %disp(['-- Clearing old figures --'])
        %oldName = strcat(autoFigPath,'\', progIdent, '*', additionalFigParams, '*.png');
        oldName = strcat(autoFigPath,'\', '*.png'); %Removed progIdent
        oldName = strrep(oldName, '**', '*'); %Quick strrep to convert **'s to *'s (Because otherwise MATLAB complains)
        oldFigList = dir(oldName);
        
        if size(oldFigList,1) > 0
            disp(['-- Old figures detected; Clearing --'])
        end
        
        s = warning('error', 'MATLAB:DELETE:Permission');
        for i = 1:size(oldFigList,1)
            try   
               delete(strcat([autoFigPath, '\', oldFigList(i).name]));
                    %Note: Theoretically only deletes figures generated by this script
               %disp(['-- Old workspace save deleted --'])
            catch
                ['#### Could not delete existing figure ####']
                error = yes
            end
        end
        if size(oldFigList,1) > 0
            disp(['-- ',num2str(i),' Old figures cleared --'])
        end
    end
    
    
    figList = get(groot, 'Children');
    %figList = findall(groot, 'Type', 'figure');
    figNameTally = 0;
    figFailTally = 0;
    for i = 1:size(figList,1)
        try
                %Note: If being run post-hoc, it seems reverse indexing might be required for correct figure numbers
            figure(figList(i)) %Select figure

            set(gcf, 'Color', 'w');
            set(gcf,'units','normalized','outerposition',[0 0 1 1])

            %Save as PNG
            if isempty(figList(i).Name) ~= 1
                %saveName = strcat(autoFigPath,'\', progIdent, '_Fig_', num2str(figList(i).Number), '_', figList(i).Name ,'.png');
                thisFigName = figList(i).Name;
                [thisFigNameSafe, modified] = matlab.lang.makeValidName(figList(i).Name);
                %Report
                if modified == 1
                    disp(['Fig. ',num2str(i),' - "', figList(i).Name, '" renamed "',thisFigNameSafe,'"'])
                    figNameTally = figNameTally + 1;
                end
                %saveName = strcat(autoFigPath,'\', 'Fig_', num2str(figList(i).Number), '_', thisFigNameSafe ,'.png');
            else
                %saveName = strcat(figPath,'\', progIdent, '_Fig_', num2str(figList(i).Number) ,'.png');
                thisFigNameSafe = [];
                %saveName = strcat(autoFigPath,'\', 'Fig_', num2str(figList(i).Number) , additionalFigParams, '.png');
            end
            saveName = strcat(autoFigPath,'\', 'Fig_', num2str(figList(i).Number), '_', thisFigNameSafe, additionalFigParams ,'.png');
            %export_fig(saveName)
            saveas(gcf,saveName,'png')

            if automatedSaveVectors == 1
                %Attempt save as vector if requested
                %saveName = strcat(vectorAutoFigPath,'\', progIdent, '_Fig_', num2str(figList(i).Number) , additionalFigParams, '.pdf');
                vecSaveName = strcat(vectorAutoFigPath,'\', 'Fig_', num2str(figList(i).Number) , thisFigNameSafe, additionalFigParams, '.pdf');
                try
                    saveas(gca,vecSaveName, 'pdf');
                catch
                    disp(['## Could not vector-save Figure ', num2str(figList(i).Number), ' ##'])
                    figFailTally = figFailTally + 1;
                end
            end

            if closeFiguresAfterSaving == 1
                close gcf %Saves memory
            end
        catch
        %pause(0.25)
            disp(['## Could not save Figure ', num2str(figList(i).Number), ' ##'])
            figFailTally = figFailTally + 1;
        end
    end
    disp(['---- ', num2str(size(figList,1)), ' OPEN FIGURES SAVED ("',autoFigPath,'") in ',num2str(toc),'s ----'])
    if figFailTally > 0
        disp(['(There were ',num2str(figFailTally),' failures)'])
    end
end

%--------------------------------------------------------------------------

%########

codeStartTime = posixtime(currentDateTime);
codeEndTime = posixtime(datetime('now'));
MET = codeEndTime - codeStartTime;
disp(['-- Total elapsed time to process: ',num2str(MET/60),' mins --'])     

disp(['Did you remember to integrate ratioSubPTT code into main branch? (And specialEval changes)'])

%extinction
end

%Functon to save figure
function savePlot(saveName,thisFigName,figStr)   
    %###########
    %Save figure
    %if saveFigs == 1
        figSaveName = strcat([saveName, '_', thisFigName, '_', figStr ,'.png']);
        %Plot preparclation
        set(gcf, 'Color', 'w');
        set(gcf,'units','normalized','outerposition',[0 0 1 1])
        %Save
        proceed = 0;
        tic
        while proceed == 0 & toc < 30
            try
                %Try to delete old version, if existing
                if isempty(dir(figSaveName)) ~= 1
                    try
                       delete(figSaveName) 
                    catch
                       ['#- Could not delete ',figSaveName,' ##'] 
                    end
                end
                saveas(gcf, figSaveName, 'png');
                proceed = 1;
                disp(['- Figure ', figSaveName, ' successfully saved -'])
            catch
                ['# Failure to save ',thisFigName,' to file #']
                pause(5)
            end
        end
    %end
    %###########
end
